<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>51Nod-1126 求递推序列的第N项</title>
    <url>/2022/07/15/51Nod-1126/</url>
    <content><![CDATA[<h2 id="51Nod-1126-求递推序列的第N项"><a href="#51Nod-1126-求递推序列的第N项" class="headerlink" title="51Nod-1126-求递推序列的第N项"></a><a href="https://vjudge.net/problem/51Nod-1126">51Nod-1126-求递推序列的第N项</a></h2><p>有一个序列是这样定义的：f(1) = 1, f(2) = 1, f(n) = (A <em> f(n - 1) + B </em> f(n - 2)) mod 7.<br>给出A，B和N，求f(n)的值。<br>Input<br>输入3个数：A,B,N。数字之间用空格分割。(-10000 &lt;= A, B &lt;= 10000, 1 &lt;= N &lt;= 10^9)<br>Output<br>输出f(n)的值。</p>
<p>Sample<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 -1 5</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>构造矩阵 F1 = [f1,f2], X = {0,B,1,A} 的矩阵 F1 <em> X = [f2,f3],可以推出来 F1</em>X^N = [fn+1,fn]<br>然后利用二进制数的特性将幂n化为二进制数进行矩阵快速幂计算<br><strong>要注意这里需要对数进行取模运算，并且这个数可能为负数</strong></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>,N=<span class="number">2</span>, mod = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A,B,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul1</span><span class="params">(<span class="type">int</span> c[],<span class="type">int</span> a[], <span class="type">int</span> b[][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++)</span><br><span class="line">            tmp[i] =( ( (tmp[i] + (LL)a[j] * b[j][i]) % mod) + mod ) % mod; <span class="comment">// 可能出现负数的情况</span></span><br><span class="line">    <span class="built_in">memcpy</span>(c,tmp,<span class="keyword">sizeof</span> c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul2</span><span class="params">(<span class="type">int</span> c[][N],<span class="type">int</span> a[][N], <span class="type">int</span> b[][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; N; k ++)</span><br><span class="line">                tmp[i][j] =( (tmp[i][j] + (LL)a[i][k] * b[k][j]) % mod + mod ) % mod;</span><br><span class="line">    <span class="built_in">memcpy</span>(c,tmp, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> f1[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">2</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>,B&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,A&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) <span class="built_in">mul1</span>(f1,f1,x);</span><br><span class="line">        <span class="built_in">mul2</span>(x,x,x);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f1[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>矩阵快速幂</tag>
        <tag>负数取模</tag>
        <tag>模版</tag>
      </tags>
  </entry>
  <entry>
    <title>AT-Tree Restoring</title>
    <url>/2022/07/17/AT-Tree-Restoring/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>AcWing 1074. 二叉苹果树</title>
    <url>/2022/08/07/AcWing-1074-%E4%BA%8C%E5%8F%89%E8%8B%B9%E6%9E%9C%E6%A0%91/</url>
    <content><![CDATA[<h2 id="AcWing-1074-二叉苹果树"><a href="#AcWing-1074-二叉苹果树" class="headerlink" title="AcWing 1074. 二叉苹果树"></a><a href="https://www.acwing.com/problem/content/1076/">AcWing 1074. 二叉苹果树</a></h2><p>有一棵二叉苹果树，如果树枝有分叉，一定是分两叉，即没有只有一个儿子的节点。</p>
<p>这棵树共 N 个节点，编号为 1 至 N，树根编号一定为 1。</p>
<p>我们用一根树枝两端连接的节点编号描述一根树枝的位置。</p>
<p>一棵苹果树的树枝太多了，需要剪枝。但是一些树枝上长有苹果，给定需要保留的树枝数量，求最多能留住多少苹果。</p>
<p>这里的保留是指最终与1号点连通。</p>
<p>输入格式<br>第一行包含两个整数 N 和 Q，分别表示树的节点数以及要保留的树枝数量。</p>
<p>接下来 N−1 行描述树枝信息，每行三个整数，前两个是它连接的节点的编号，第三个数是这根树枝上苹果数量。</p>
<p>输出格式<br>输出仅一行，表示最多能留住的苹果的数量。</p>
<p>数据范围<br>1≤Q&lt;N≤100.<br>N≠1,<br>每根树枝上苹果不超过 30000 个。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 2</span><br><span class="line">1 3 1</span><br><span class="line">1 4 10</span><br><span class="line">2 3 20</span><br><span class="line">3 5 20</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>根据题意我们要知道的是对于本题来说选了子节点，其子节点的父亲节点也一定要选，但是选了父节点不一定选子节点，所以知道了从下到上更新困难，从上到下更新简单。</p>
<p>有依赖关系的背包问题划分：<br>dp[i][j]表示以i为根的子树，包含i的这个节点保留边数不大于j的权值之和最大方案</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> dp[N][N];   <span class="comment">// dp[u][m]表示以u为根节点的树保留m条边最多可以留的苹果数目</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; j; k ++)</span><br><span class="line">                dp[u][j] = <span class="built_in">max</span>(dp[u][j], dp[v][k] + dp[u][j-k<span class="number">-1</span>] + w[i]);   <span class="comment">// 要保留u-&gt;v之间的那条边</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="comment">// 不能建立单向边</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1 2 0</span></span><br><span class="line"><span class="comment">            1 5 1</span></span><br><span class="line"><span class="comment">            3 5 100</span></span><br><span class="line"><span class="comment">            4 5 1</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,c),<span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>动态规划</category>
        <category>树形dp</category>
        <category>树上背包</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1077. 皇宫看守</title>
    <url>/2022/08/07/AcWing-1077-%E7%9A%87%E5%AE%AB%E7%9C%8B%E5%AE%88/</url>
    <content><![CDATA[<h3 id="AcWing-1077-皇宫看守"><a href="#AcWing-1077-皇宫看守" class="headerlink" title="AcWing 1077. 皇宫看守"></a><a href="https://www.acwing.com/problem/content/1079/">AcWing 1077. 皇宫看守</a></h3><p>本题要区别于<a href="https://www.acwing.com/problem/content/325/">战略游戏</a><br>战略游戏是要求我们的用最少节点数覆盖到所有点上<br>本题是要求我们用最少的节点数覆盖到所有的边上</p>
<p>比如一个图是<br>1-&gt;2-&gt;3-&gt;4<br>最少点覆盖是用1号点和4号点这样就可以覆盖全图上的所有点（方案不唯一)<br>最少边覆盖是用1，2，3号点才可以实现所有的边覆盖</p>
<p>树形dp<br>状态划分dp[i][3]<br>要注意的是是以i为根的子树也就是只能当前节点的往下去划分集合<br>集合划分：dp[i][0] 表示以i为根的子树父节点被选自己观察的情况， dp[i][1] 表示以i为根的子树父节点被子节点观察的情况,dp[i][2] 表示以i为根的子树父节点被其父节点观察<br>状态转移：<br>当父节点被自己观察的情况下，子节点要么被自己观察要么被被自己的儿子观察<br>dp[u][0] = min(dp[v][0], dp[v][1], dp[v][2]) + w[u];<br>当父亲节点被子节点观察的情况，至少一个子节点是被自己观察，其余的节点可以被自己观察也可以被子节点观察<br>dp[u][1] = min(dp[v][0] + ∑ min(dp[vi][0],dp[vi][1]))<br>当父亲节点被父节点观察的情况，那么其子节点是可以被自己观察也可以被子节点观察的<br>dp[u][2] = min(dp[v][0],dp[v][1])</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1510</span>, M = <span class="number">2</span> * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[N], idx;</span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> n,res = INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    dp[u][<span class="number">0</span>] = w[u];    <span class="comment">// 被自己观察那么至少是选择当前的节点的</span></span><br><span class="line">    dp[u][<span class="number">1</span>] = INF;     <span class="comment">// 被儿子观察，因为要遍历所子节点方案取min所以要初始化为INF</span></span><br><span class="line">    dp[u][<span class="number">2</span>] = <span class="number">0</span>;       <span class="comment">// 被父节点观察的情况下，当下这个节点一定不用选</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(j,u);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;A&quot; &lt;&lt; endl;</span></span><br><span class="line">        dp[u][<span class="number">0</span>] += <span class="built_in">min</span>(dp[j][<span class="number">0</span>], <span class="built_in">min</span>(dp[j][<span class="number">1</span>], dp[j][<span class="number">2</span>]));</span><br><span class="line">        dp[u][<span class="number">2</span>] += <span class="built_in">min</span>(dp[j][<span class="number">0</span>],dp[j][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;B&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// dp[u][2] = sum&#123;min(dp[v][0],dp[v][1])&#125;</span></span><br><span class="line">        <span class="comment">// dp[u][2] - j的贡献就等于其他子节点的贡献总和</span></span><br><span class="line">        dp[u][<span class="number">1</span>] = <span class="built_in">min</span>(dp[u][<span class="number">1</span>], dp[v][<span class="number">0</span>] + dp[u][<span class="number">2</span>] - <span class="built_in">min</span>(dp[v][<span class="number">0</span>],dp[v][<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id,v,cnt;</span><br><span class="line">        cin &gt;&gt; id &gt;&gt; v &gt;&gt; cnt;</span><br><span class="line">        w[id] = v;</span><br><span class="line">        <span class="keyword">while</span>(cnt --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            <span class="built_in">add</span>(id,a), <span class="built_in">add</span>(a,id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(dp[<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1126. 最小花费</title>
    <url>/2022/07/24/AcWing-1126-%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9/</url>
    <content><![CDATA[<h2 id="AcWing-1126-最小花费"><a href="#AcWing-1126-最小花费" class="headerlink" title="AcWing 1126. 最小花费"></a><a href="https://www.acwing.com/problem/content/1128/">AcWing 1126. 最小花费</a></h2><p>在 n 个人中，某些人的银行账号之间可以互相转账。<br>这些人之间转账的手续费各不相同。<br>给定这些人之间转账时需要从转账金额里扣除百分之几的手续费，请问 A 最少需要多少钱使得转账后 B 收到 100 元。</p>
<p>输入格式<br>第一行输入两个正整数 n,m，分别表示总人数和可以互相转账的人的对数。<br>以下 m 行每行输入三个正整数 x,y,z，表示标号为 x 的人和标号为 y 的人之间互相转账需要扣除 z% 的手续费 ( z&lt;100 )。<br>最后一行输入两个正整数 A,B。</p>
<p>数据保证 A 与 B 之间可以直接或间接地转账。</p>
<p>输出格式<br>输出 A 使得 B 到账 100 元最少需要的总费用。</p>
<p>精确到小数点后 8 位。</p>
<p>数据范围<br>1≤n≤2000,<br>m≤105<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 1</span><br><span class="line">2 3 2</span><br><span class="line">1 3 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">103.07153164</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目要求的到帐100元的最少费用<br>100 = x <em> (1-a1) </em> (1 - a2) … x为原来总费用，a1,a2…为手续费<br>可以简化公式为 100 = x <em> (p1 </em> p2 <em> … </em> pn)， 要想求x最小那么就需要（p1 <em> p2 </em> … <em> pn)最大。<br>p1 </em> p2 <em> … </em> pn &lt;=&gt; log(p1 <em> p2 </em> … <em> pn) &lt;=&gt; log p1 + log p2 + .. log pn<br>&lt;=&gt; 由于log函数单调递增，所以要想求`p1 </em> p2 <em> … </em> pn<code>，那么等于求</code>p1 + p2 + … + pn`最大<br><strong>但是要注意的是logx 在 (0,1)logx &lt; 0 只会出现负数， 所以有两种做法，要么求最长（边权为负求最长路），要么边权取反求最短路（边权为正求最短路）， 但是一旦x的限制为 x &gt; 0的话，边权就可正可负了，这个情况下就尽量使用spfa</strong></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; PDI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; <span class="built_in">assert</span>(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, M = <span class="number">100010</span> * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M],idx;</span><br><span class="line"><span class="type">double</span> w[M];</span><br><span class="line"><span class="type">int</span> n, m, start, ed;</span><br><span class="line"><span class="type">double</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">double</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dist);   <span class="comment">// 求最长路，初始化为负无穷</span></span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;PDI&gt; q;  <span class="comment">// 第一维要保存的是double类型的，且要求最短路这里是大根堆</span></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>,start&#125;);</span><br><span class="line">    dist[start] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver = t.se;</span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>; <span class="comment">// 堆优化的dijkstra</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &lt; dist[ver] * w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] * w[i];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="type">double</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a,&amp;b,&amp;c);</span><br><span class="line">        p = (<span class="number">100.0</span>-c) / <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">add</span>(a,b,p);</span><br><span class="line">        <span class="built_in">add</span>(b,a,p);  </span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; start &gt;&gt; ed;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.8lf\n&quot;</span>, <span class="number">100</span> / dist[ed]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1131. 拯救大兵瑞恩</title>
    <url>/2022/09/05/AcWing-1131-%E6%8B%AF%E6%95%91%E5%A4%A7%E5%85%B5%E7%91%9E%E6%81%A9/</url>
    <content><![CDATA[<h2 id="AcWing-1131-拯救大兵瑞恩"><a href="#AcWing-1131-拯救大兵瑞恩" class="headerlink" title="AcWing 1131. 拯救大兵瑞恩"></a><a href="https://www.acwing.com/problem/content/1133/">AcWing 1131. 拯救大兵瑞恩</a></h2><p>1944 年，特种兵麦克接到国防部的命令，要求立即赶赴太平洋上的一个孤岛，营救被敌军俘虏的大兵瑞恩。</p>
<p>瑞恩被关押在一个迷宫里，迷宫地形复杂，但幸好麦克得到了迷宫的地形图。</p>
<p>迷宫的外形是一个长方形，其南北方向被划分为 N 行，东西方向被划分为 M 列， 于是整个迷宫被划分为 N×M 个单元。</p>
<p>每一个单元的位置可用一个有序数对 (单元的行号, 单元的列号) 来表示。</p>
<p>南北或东西方向相邻的 2 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。</p>
<p>注意： 门可以从两个方向穿过，即可以看成一条无向边。</p>
<p>迷宫中有一些单元存放着钥匙，同一个单元可能存放 多把钥匙，并且所有的门被分成 P 类，打开同一类的门的钥匙相同，不同类门的钥匙不同。</p>
<p>大兵瑞恩被关押在迷宫的东南角，即 (N,M) 单元里，并已经昏迷。</p>
<p>迷宫只有一个入口，在西北角。</p>
<p>也就是说，麦克可以直接进入 (1,1) 单元。</p>
<p>另外，麦克从一个单元移动到另一个相邻单元的时间为 1，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。</p>
<p>试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。</p>
<p>输入格式<br>第一行有三个整数,分别表示 N,M,P 的值。</p>
<p>第二行是一个整数 k，表示迷宫中门和墙的总数。</p>
<p>接下来 k 行，每行包含五个整数，Xi1,Yi1,Xi2,Yi2,Gi：当 Gi≥1 时，表示 (Xi1,Yi1) 单元与 (Xi2,Yi2) 单元之间有一扇第 Gi 类的门，当 Gi=0 时，表示 (Xi1,Yi1) 单元与 (Xi2,Yi2) 单元之间有一面不可逾越的墙。</p>
<p>接下来一行，包含一个整数 S，表示迷宫中存放的钥匙的总数。</p>
<p>接下来 S 行，每行包含三个整数 Xi1,Yi1,Qi，表示 (Xi1,Yi1) 单元里存在一个能开启第 Qi 类门的钥匙。</p>
<p>输出格式<br>输出麦克营救到大兵瑞恩的最短时间。</p>
<p>如果问题无解，则输出 -1。</p>
<p>数据范围<br>|Xi1−Xi2|+|Yi1−Yi2|=1,<br>0≤Gi≤P,<br>1≤Qi≤P,<br>1≤N,M,P≤10,<br>1≤k≤150<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 4 9</span><br><span class="line">9</span><br><span class="line">1 2 1 3 2</span><br><span class="line">1 2 2 2 0</span><br><span class="line">2 1 2 2 0</span><br><span class="line">2 1 3 1 0 </span><br><span class="line">2 3 3 3 0</span><br><span class="line">2 4 3 4 1</span><br><span class="line">3 2 3 3 0</span><br><span class="line">3 3 4 3 0</span><br><span class="line">4 3 4 4 0</span><br><span class="line">2</span><br><span class="line">2 1 2 </span><br><span class="line">4 2 1</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><br>样例解释：<br>迷宫如下所示： <img src="https://cdn.acwing.com/media/article/image/2019/11/06/1_17c87ee400-1131.png" alt="AcWing"></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要求从左上脚走到右下角。在途中可能会遇到门，相应的门就需要相应的钥匙，所以途中可能就需要去寻找钥匙，遇到墙就说面不能通过要绕行。<br>如果对于一个有且仅有墙的问题，我们只需要使用dp[x][y] = min(dp[x + dx][y + dy], dp[x][y])转移,但是的本题因为还需要有寻找钥匙的这个一过成，只有具有一定的状态还可以的通过某一个对应的门，所以在这里需要引入一个状态变量，因为只有十种类型的门，所以最多只需要十位的二进制来表示状态就行。</p>
<p>状态划分<br>dp[x][y][state] 表示到(x,y)这点状态为state的最小代价 </p>
<p>状态转移</p>
<ul>
<li>当前如果这个位置有钥匙key，因为取钥匙是不需要任何的代价的所以有钥匙就全部取得<br>dp[x][y][state | key] = min(dp[x][y][state], dp[x][y][state | key])</li>
<li>当前这个点向上下左右四个方向走，可以走的合法方案是（1）没有门和墙 （2）有门且有相应的钥匙<br>d[cx][cy][state] = min(d[cx][cy][state], d[x][y][state] + 1)</li>
</ul>
<p>根据状态转移方程来看我们只有有且仅有边权为0/1， 并没有负数，但有环。所以一定是没有的负环，一定是可以通过最短路来求解不能通过dp来求解.</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>, M = <span class="number">400</span>, STA = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> g[N][N], key[N * N];</span><br><span class="line"><span class="type">int</span> dist[N][STA], dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">bool</span> st[N][STA];</span><br><span class="line"><span class="type">int</span> n, m, P, K;</span><br><span class="line">set&lt;PII&gt; edges;</span><br><span class="line">deque&lt;PII&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 步骤为：枚举每一个点，然后看他的邻接点是否建立边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!i || i &gt; n || !j || j &gt; m) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x = i + dx[k], y = j + dy[k];</span><br><span class="line">                <span class="type">int</span> a = g[i][j], b = g[x][y];</span><br><span class="line">                <span class="keyword">if</span>(!edges.<span class="built_in">count</span>(&#123;a,b&#125;)) <span class="built_in">add</span>(a,b,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">pb</span>(&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.fi, sta = t.se;</span><br><span class="line">        <span class="keyword">if</span>(st[ver][sta]) <span class="keyword">continue</span>;   <span class="comment">//  每个点只会被更新一次</span></span><br><span class="line">        st[ver][sta] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剪枝</span></span><br><span class="line">        <span class="comment">// 每个点的每一种状态只会被更新一遍</span></span><br><span class="line">        <span class="keyword">if</span>(ver == n * m) <span class="keyword">return</span> dist[ver][sta];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断该点上是否有钥匙 </span></span><br><span class="line">        <span class="keyword">if</span>(key[ver])</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="type">int</span> state = sta | key[ver];</span><br><span class="line">           <span class="keyword">if</span>(dist[ver][state] &gt; dist[ver][sta])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[ver][state] = dist[ver][sta];</span><br><span class="line">                q.<span class="built_in">push_front</span>(&#123;ver,state&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个点放邻边走</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];   <span class="comment">// 邻边的编号（该情况一定没有墙，因为有墙的话就不会有边相连，所以这里只用简化到判断是否有门）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前没有门</span></span><br><span class="line">            <span class="keyword">if</span>((!w[i] || sta &gt;&gt; w[i] - <span class="number">1</span> &amp; <span class="number">1</span>) &amp;&amp; dist[j][sta] &gt; dist[ver][sta] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j][sta] = <span class="built_in">min</span>(dist[j][sta], dist[ver][sta] + <span class="number">1</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(&#123;j,sta&#125;);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; P &gt;&gt; K;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了将二维转换成一维的关系，将二维坐标转换成一维的编号方式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, t = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            g[i][j] = t ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立墙和门</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; K; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="type">int</span> a = g[x1][y1], b = g[x2][y2];</span><br><span class="line">        edges.<span class="built_in">insert</span>(&#123;a,b&#125;), edges.<span class="built_in">insert</span>(&#123;b,a&#125;);   <span class="comment">// 这里抱存进set的原因是因为方便后面的建图，判断当前的边是否已经被建立</span></span><br><span class="line">        <span class="comment">// 如果是墙的话就说明没有边（等价于无路可走）</span></span><br><span class="line">        <span class="keyword">if</span>(c) <span class="built_in">add</span>(a,b,c),<span class="built_in">add</span>(b,a,c); <span class="comment">// 在编号为a和b之间建立一条边，边权为c的边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立普通边</span></span><br><span class="line">    <span class="built_in">build</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录每个坐标上的key值</span></span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span><br><span class="line">        <span class="type">int</span> a = g[x][y];</span><br><span class="line">        key[a] |= <span class="number">1</span> &lt;&lt; c - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双端队列求解最短路 </span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>图论</category>
        <category>最短路</category>
        <category>与dp结合</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1134. 最短路计数</title>
    <url>/2022/09/06/AcWing-1134-%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="AcWing-1134-最短路计数"><a href="#AcWing-1134-最短路计数" class="headerlink" title="AcWing 1134. 最短路计数"></a><a href="https://www.acwing.com/problem/content/1136/">AcWing 1134. 最短路计数</a></h2><p>给出一个 N 个顶点 M 条边的无向无权图，顶点编号为 1 到 N。</p>
<p>问从顶点 1 开始，到其他每个点的最短路有几条。</p>
<p>输入格式<br>第一行包含 2 个正整数 N,M，为图的顶点数与边数。</p>
<p>接下来 M 行，每行两个正整数 x,y，表示有一条顶点 x 连向顶点 y 的边，请注意可能有自环与重边。</p>
<p>输出格式<br>输出 N 行，每行一个非负整数，第 i 行输出从顶点 1 到顶点 i 有多少条不同的最短路，由于答案有可能会很大，你只需要输出对 100003 取模后的结果即可。</p>
<p>如果无法到达顶点 i 则输出 0。</p>
<p>数据范围<br>1≤N≤105,<br>1≤M≤2×105<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据dp来划分状态并记录最小花费的所有方案</p>
<ol>
<li>先算出全局最小值</li>
<li>分别求出每个子集中等于全局最小值的元素个数</li>
</ol>
<p>这里说明为什么在dp问题我们可以使用循环的方式来更新，而最短路不行<br> 1.dp能使用循环的方式，是因为当前状态前面的状态已经计算完毕，所以可以利用前面状态来更新当前的状态。这也说明了只有当状态转移不具有依赖关系的时候而具有拓扑序的时候，才可以利用dp方式来求解</p>
<p>最短路算法中即使图中有环也可以将环图转化拓扑图(最短路树) -&gt; 转化为拓扑图之后就可以使用dp求解（图中有负环或零环的情况下求方案数）<br> 由于dist[j] = min(dist[j], dist[t] + w[i])所以每一个点都一定会被前驱节点更新，有可能会被一个节点更新有可能会被多个节点更新，我们只需要要保留一个/多个更新当前节点的前驱节点就可以转化成一个拓扑图</p>
<p> <strong>在这里要注意</strong>， 如果当边权为0的时候，说明当前两个状态之间其实等价的关系，本质上可以相互转化的，这时候就会存在一个权重为0的环，可以在这个环上绕无限圈，所以这个时候是不能使用最短路来求的（等价于图上有负环的时候是不能通过最短路来求）</p>
<p> 由于图上没有负权边，所以如果图上存在一个环，说明这个环一定是边权为0的环（可以通过dist[i] = dist[j] + w[u] == dist[j] = dist[k] + w[v] == dist[k] = dist[i] + w[p] 算出来)</p>
<p>总结：</p>
<ul>
<li>只要图中没有负权图的dp问题即使有正环都是可以使用最短路的方式来求解的。如有有负权边的情况，就需要判断是否有负环，或则能否转化成拓扑图的形式。</li>
<li>如果图中含有负环（或零环）的情况下，使用spfa求解。<ol>
<li>先用spfa跑出来最短距离</li>
<li>建立拓扑树</li>
<li>用dist[j] = dist[t] + w[i]判断是否成立，成立就更新，但必须满足t已经完全更新过。</li>
</ol>
</li>
</ul>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">100003</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">400010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    q[hh] = <span class="number">1</span>;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + <span class="number">1</span>;</span><br><span class="line">                cnt[j] = cnt[t];</span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dist[j] == dist[t] + <span class="number">1</span>) <span class="comment">// 最短路有多条</span></span><br><span class="line">            &#123;</span><br><span class="line">                cnt[j] = (cnt[j] + cnt[t]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">// 题意可能有点问题应该所有边都是无向边</span></span><br><span class="line">        <span class="comment">// 5 5</span></span><br><span class="line">        <span class="comment">// 1 2  </span></span><br><span class="line">        <span class="comment">// 2 3</span></span><br><span class="line">        <span class="comment">// 3 4</span></span><br><span class="line">        <span class="comment">// 4 1</span></span><br><span class="line">        <span class="comment">// 4 5</span></span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最短路计数</span></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        cout &lt;&lt; cnt[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>图论</category>
        <category>最短路</category>
        <category>与dp结合</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1135.新年好</title>
    <url>/2022/07/19/AcWing-1135-%E6%96%B0%E5%B9%B4%E5%A5%BD/</url>
    <content><![CDATA[<h2 id="AcWing-1135-新年好"><a href="#AcWing-1135-新年好" class="headerlink" title="AcWing 1135.新年好"></a><a href="https://www.acwing.com/problem/content/1137/">AcWing 1135.新年好</a></h2><p>重庆城里有 n 个车站，m 条 双向 公路连接其中的某些车站。<br>每两个车站最多用一条公路连接，从任何一个车站出发都可以经过一条或者多条公路到达其他车站，但不同的路径需要花费的时间可能不同。<br>在一条路径上花费的时间等于路径上所有公路需要的时间之和。<br>佳佳的家在车站 1，他有五个亲戚，分别住在车站 a,b,c,d,e。<br>过年了，他需要从自己的家出发，拜访每个亲戚（顺序任意），给他们送去节日的祝福。<br>怎样走，才需要最少的时间？</p>
<p>输入格式<br>第一行：包含两个整数 n,m，分别表示车站数目和公路数目。<br>第二行：包含五个整数 a,b,c,d,e，分别表示五个亲戚所在车站编号。<br>以下 m 行，每行三个整数 x,y,t，表示公路连接的两个车站编号和时间。</p>
<p>输出格式<br>输出仅一行，包含一个整数 T，表示最少的总时间。</p>
<p>数据范围<br>1≤n≤50000,<br>1≤m≤105,<br>1<a,b,c,d,e≤n,
1≤x,y≤n,
1≤t≤100
输入样例：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 6</span><br><span class="line">2 3 4 5 6</span><br><span class="line">1 2 8</span><br><span class="line">2 3 3</span><br><span class="line">3 4 4</span><br><span class="line">4 5 5</span><br><span class="line">5 6 2</span><br><span class="line">1 6 7</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>由题目知道需要从源点到5个点经过路径的最短<br>一. 枚举拜访顺序，对每一种拜访顺序做最短路<br>假如我们的摆放顺序为 <code>a b c d e</code>,那么我们需要做五次最短路 1-&gt;a的最短路 2-&gt;b的最短路….<br>这中枚举方案的时间复杂度O（5！ * n^2)<br>二. 先做预处理，再枚举摆放顺序<br>因为很清楚知道其实不用每次都计算最短路。因为路都是固定的，变的是走的策略，所以可以一开始就预处理最短路，在枚举。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; <span class="built_in">assert</span>(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>, M = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, ans = INF;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M],w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[<span class="number">6</span>][N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> sourse[<span class="number">6</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> dist[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, N * <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,start&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j],j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> start, <span class="type">int</span> distance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u &gt; <span class="number">5</span>) </span><br><span class="line">        ans = <span class="built_in">min</span>(ans,distance);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> next = sourse[i];</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>, i, distance + dist[start][next]);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 本题由于所有边是正权边，且nm大概是5e9的级别的所以spfa是不敢使用的</span></span><br><span class="line">    <span class="comment">// 堆优化的dijkstrea是mlogn大概在1e6的级别，朴素版的在2.5e9所以应该使用的是堆优化</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i ++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;sourse[i]);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a,b,c),<span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i ++)</span><br><span class="line">        <span class="built_in">dijkstra</span>(sourse[i], dist[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>单源最短路</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1137. 选择最佳线路</title>
    <url>/2022/09/04/AcWing-1137-%E9%80%89%E6%8B%A9%E6%9C%80%E4%BD%B3%E7%BA%BF%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="AcWing-1137-选择最佳线路"><a href="#AcWing-1137-选择最佳线路" class="headerlink" title="AcWing 1137. 选择最佳线路"></a><a href="https://www.acwing.com/problem/content/1139/">AcWing 1137. 选择最佳线路</a></h2><p>有一天，琪琪想乘坐公交车去拜访她的一位朋友。</p>
<p>由于琪琪非常容易晕车，所以她想尽快到达朋友家。</p>
<p>现在给定你一张城市交通路线图，上面包含城市的公交站台以及公交线路的具体分布。</p>
<p>已知城市中共包含 n 个车站（编号1~n）以及 m 条公交线路。</p>
<p>每条公交线路都是 单向的，从一个车站出发直接到达另一个车站，两个车站之间可能存在多条公交线路。</p>
<p>琪琪的朋友住在 s 号车站附近。</p>
<p>琪琪可以在任何车站选择换乘其它公共汽车。</p>
<p>请找出琪琪到达她的朋友家（附近的公交车站）需要花费的最少时间。</p>
<p>输入格式<br>输入包含多组测试数据。</p>
<p>每组测试数据第一行包含三个整数 n,m,s，分别表示车站数量，公交线路数量以及朋友家附近车站的编号。</p>
<p>接下来 m 行，每行包含三个整数 p,q,t，表示存在一条线路从车站 p 到达车站 q，用时为 t。</p>
<p>接下来一行，包含一个整数 w，表示琪琪家附近共有 w 个车站，她可以在这 w 个车站中选择一个车站作为始发站。</p>
<p>再一行，包含 w 个整数，表示琪琪家附近的 w 个车站的编号。</p>
<p>输出格式<br>每个测试数据输出一个整数作为结果，表示所需花费的最少时间。</p>
<p>如果无法达到朋友家的车站，则输出 -1。</p>
<p>每个结果占一行。</p>
<p>数据范围<br>n≤1000,m≤20000,<br>1≤s≤n,<br>0&lt; w &lt; n<br>0&lt; t ≤ 1000<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 8 5</span><br><span class="line">1 2 2</span><br><span class="line">1 5 3</span><br><span class="line">1 3 4</span><br><span class="line">2 4 7</span><br><span class="line">2 5 6</span><br><span class="line">2 3 5</span><br><span class="line">3 5 1</span><br><span class="line">4 5 1</span><br><span class="line">2</span><br><span class="line">2 3</span><br><span class="line">4 3 4</span><br><span class="line">1 2 3</span><br><span class="line">1 3 4</span><br><span class="line">2 3 2</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">-1</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于有多个起点但是有且仅有一个终点，我们可以反向建图，从多源点转化成单源点问题</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>, M = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M] ,ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> ed[N], dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, en, m, S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[S] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;dist[S], S&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>(); </span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j],j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m &gt;&gt; S)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            <span class="built_in">add</span>(b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; en;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; en; i ++)</span><br><span class="line">            cin &gt;&gt; ed[i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; en; i ++)</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, dist[ed[i]]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ans == INF) cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>AcWing 340. 通信线路</title>
    <url>/2022/09/01/AcWing-340-%E9%80%9A%E4%BF%A1%E7%BA%BF%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="AcWing-340-通信线路"><a href="#AcWing-340-通信线路" class="headerlink" title="AcWing 340. 通信线路"></a><a href="https://www.acwing.com/problem/content/342/">AcWing 340. 通信线路</a></h2><p>在郊区有 N 座通信基站，P 条 双向 电缆，第 i 条电缆连接基站 Ai 和 Bi。</p>
<p>特别地，1 号基站是通信公司的总站，N 号基站位于一座农场中。</p>
<p>现在，农场主希望对通信线路进行升级，其中升级第 i 条电缆需要花费 Li。</p>
<p>电话公司正在举行优惠活动。</p>
<p>农产主可以指定一条从 1 号基站到 N 号基站的路径，并指定路径上不超过 K 条电缆，由电话公司免费提供升级服务。</p>
<p>农场主只需要支付在该路径上剩余的电缆中，升级价格最贵的那条电缆的花费即可。</p>
<p>求至少用多少钱可以完成升级。</p>
<p>输入格式<br>第 1 行：三个整数 N，P，K。</p>
<p>第 2..P+1 行：第 i+1 行包含三个整数 Ai,Bi,Li。</p>
<p>输出格式<br>包含一个整数表示最少花费。</p>
<p>若 1 号基站与 N 号基站之间不存在路径，则输出 −1。</p>
<p>数据范围<br>0 ≤ K &lt; N ≤ 1000<br>1 ≤ P ≤ 10000,<br>1 ≤ Li ≤ 1000000<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 7 1</span><br><span class="line">1 2 5</span><br><span class="line">3 1 4</span><br><span class="line">2 4 8</span><br><span class="line">3 2 3</span><br><span class="line">5 2 9</span><br><span class="line">3 4 7</span><br><span class="line">4 5 6</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>根据题意：我们知道在这个图上的某两个点之间的所有路径去除K条最贵的路径，剩下的所有边权最大值最小。</p>
<ul>
<li>与最小生成树做对比：这里是路径，是没有必要经过所有的点，所以如果使用kruscal可能求出来的解不对</li>
<li>与最短路径做对比：在极端的情况下最短路径的次大值可能比更长的路径的最大值要大，所以要是求出最短路径然后再求出次大值这样求出来的答案也不一定是正确的</li>
</ul>
<p>不严谨来讲，本题也就是要求第<code>k+1</code>大的边最小(最大值最小 —&gt; 二分思想)<br>但路径上的边数小于<code>K</code>条,那么说明所有的边都被干掉，最优解为<code>0</code></p>
<p>要使用二分就一定要具有二段性的性质（也就是说答案的左边是一个性质，答案的右边是另外一个性质）<br>假设答案定义的在[0,1000001]区间上<br>对于区间中的某一个点<code>x</code>，求出从<code>1</code>走到<code>N</code>中，最少经过几条长度大于<code>x</code>的边，假设最少经过<code>y</code>条。<br>性质的结果就是<code>y &lt;= k</code>。</p>
<p>证明这个性质成立</p>
<ul>
<li>x右区间所有点满足性质<br>所有的路径中的最少经过的长度大于<code>x</code>的边为<code>y</code>条，并且在当前区间为<code>x</code>点下, <code>y &lt;= k</code>，也就是说答案在比x大的情况下一定成立，那么x的右边区域就满足性质。</li>
<li>x的左区间所有点都不满足性质<br>反证法：假设存在一个点满足性质，那么这个点一定是我们答案x’点（因为答案右区间一定满足性质，如果当前的点右区间满足性质，那么答案一定会被更新到这个点上），这样就和我们前提答案为x点矛盾。</li>
</ul>
<p>区间取到<code>0</code> 与 <code>1000001</code></p>
<ul>
<li>取到0时，路径上的边数小于<code>K</code>，这样子答案就为0</li>
<li>取到1000001时，由于本题是又可能<code>1-&gt;N</code>之间不存在路径的，所以是有可能存在无解的情况，如果区间的不取到<code>1000001</code>，而是取到的<code>1000000</code>时，有可能最大值和无解都重合在<code>1000000</code>这个点上具有二义性，所以为了区分情况，多设置了一个点表示无解的情况.</li>
</ul>
<p>求出从1到N最少经过几条长度大于x的边<br>可以将所有的边进行分类，当前边权大于x的边，边权重新设置为1；当前边权小于等于x的边设为0.<br>这样的话，一个图上只有两种边权不是0/1.我们就可以使用双端队列bfs来求出最短路（最短路也就是0越少越好，最短路边权等于大于x的边的数目）</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">20010</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;   <span class="comment">// save 0/1</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> bound)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// deque find the shortest path</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st); <span class="comment">// means all point not update</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// like dijstra</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(st[t]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update dist </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i], v = w[i] &gt; bound; <span class="comment">// value &gt; bound set &#x27;1&#x27; or set &#x27;0&#x27;</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + v) </span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + v;</span><br><span class="line">                <span class="keyword">if</span>(!v) q.<span class="built_in">push_front</span>(j);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的最短路边权值等于大于bound的边数，如果边数比k还要小的话，那么答案应该</span></span><br><span class="line">    <span class="keyword">return</span> dist[n] &lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binary_search</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1000001</span>; <span class="comment">// [0,1e6 + 1]</span></span><br><span class="line">    <span class="comment">// find the minimum of all maximums</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 检查当前的点是否满足性质 y &lt;= k</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid; <span class="comment">//  if statisfy find the lefe interval </span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">1e6</span> + <span class="number">1</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>图论</category>
        <category>最短路</category>
        <category>与二分结合</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 341 最优贸易</title>
    <url>/2022/09/03/AcWing-341-%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93/</url>
    <content><![CDATA[<h2 id="AcWing-341-最优贸易"><a href="#AcWing-341-最优贸易" class="headerlink" title="AcWing 341 最优贸易"></a><a href="https://www.acwing.com/problem/content/343/">AcWing 341 最优贸易</a></h2><p>C 国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。</p>
<p>任意两个城市之间最多只有一条道路直接相连。</p>
<p>这 m 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。</p>
<p>C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。</p>
<p>但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。</p>
<p>商人阿龙来到 C 国旅游。</p>
<p>当他得知“同一种商品在不同城市的价格可能会不同”这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚一点旅费。</p>
<p>设 C 国 n 个城市的标号从 1∼n，阿龙决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。</p>
<p>在旅游的过程中，任何城市可以被重复经过多次，但不要求经过所有 n 个城市。</p>
<p>阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。</p>
<p>因为阿龙主要是来 C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。</p>
<p>现在给出 n 个城市的水晶球价格，m 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。</p>
<p>请你告诉阿龙，他最多能赚取多少旅费。</p>
<p>注意：本题数据有加强。</p>
<p>输入格式<br>第一行包含 2 个正整数 n 和 m，中间用一个空格隔开，分别表示城市的数目和道路的数目。</p>
<p>第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 n 个城市的商品价格。</p>
<p>接下来 m 行，每行有 3 个正整数，x，y，z，每两个整数之间用一个空格隔开。</p>
<p>如果 z=1，表示这条道路是城市 x 到城市 y 之间的单向道路；如果 z=2，表示这条道路为城市 x 和城市 y 之间的双向道路。</p>
<p>输出格式<br>一个整数，表示答案。</p>
<p>数据范围<br>1≤n≤100000,<br>1≤m≤500000,<br>1≤各城市水晶球价格≤100<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">4 3 5 6 1</span><br><span class="line">1 2 1</span><br><span class="line">1 4 1</span><br><span class="line">2 3 2</span><br><span class="line">3 5 1</span><br><span class="line">4 5 2</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="要知道dp是如何和最短路结合的并且是可以结合条件是什么？？"><a href="#要知道dp是如何和最短路结合的并且是可以结合条件是什么？？" class="headerlink" title="要知道dp是如何和最短路结合的并且是可以结合条件是什么？？"></a>要知道dp是如何和最短路结合的并且是可以结合条件是什么？？</h3><p>对于一个具有依赖关系的dp问题<br> 比如<br> dp[2] = min(dp[1] + 1,dp[4] + 1)<br> dp[3] = dp[2] + 1<br> dp[4] = dp[3] + 1<br> dp[5] = dp[4] + 1<br>画出状态转移图，这样就知道了这是一个带环的但是知道每条边的边权都是为正，但是图上没有带负数环所以是可以用最短路来求的。</p>
<p><strong>总结：</strong> 能用最短路来求dp问题的前提条件是的状态转移图不存在负环，且在这个图上由于具有环结构所以是不能用dp的状态转移来求</p>
<p>本题的状态转移和状态划分</p>
<ul>
<li>对于求方案数类型的dp问题要求状态划分做到不重不漏</li>
<li>对于求最优解类型的dp问题最低要求状态划分做到不漏（可以重复）</li>
</ul>
<p>所以对于本题的状态划分为对每个节点的来说在这个节点之前购买的最低价格和在这个节点之后卖出最高价格<br>最后的答案就等于ans = dpmax[i] - dpmin[i]</p>
<p><strong>本题要注意的是，只有点权没有边权，并且点权是不能放在边权上面的。</strong><br>dijkstra实际上就是利用了贪心的思想具有局部最优解—&gt;全局最优解，并且每个点只会被更新一次<br> 如果当前<code>dmin[i]</code> 最小的点是<code>5，</code>那么有可能存在边 5-&gt; 6, 6-&gt; 7, 7-&gt; 5，假设当前<code>dmin[5] = 10</code>，则有可能存在<code>6</code>的价格是11， 但 <code>7</code> 的价格是3，那么<code>dmin[5]</code>的值就应该被更新成3，因此当前最小值也不一定是最终最小值，所以dijkstra算法并不适用，我们只能采用 spfa 算法。</p>
<p><code>SPFA</code>算法最坏的时间复杂度为nm = 100000 * 5000000 ,但是不卡数据的情况下时间复杂度大概在O(m)</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">500000</span> * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> zh[N], rh[N], w[N], e[M], ne[M], idx; </span><br><span class="line"><span class="type">int</span> dpmin[N],dpmax[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> h[],<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> dp[], <span class="type">int</span> S, <span class="type">int</span> h[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dpmin);<span class="comment">// 要求最短路</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dpmax);</span><br><span class="line"></span><br><span class="line">    st[S] = <span class="literal">true</span>;</span><br><span class="line">    dp[S] =  w[S];</span><br><span class="line">    q[hh] = S;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>; <span class="comment">// 循环队列 </span></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(S == <span class="number">1</span> &amp;&amp; dp[j] &gt; <span class="built_in">min</span>(dp[t], w[j]) || S == n &amp;&amp; dp[j] &lt; <span class="built_in">max</span>(dp[t], w[j]) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(S == <span class="number">1</span>) dp[j] = <span class="built_in">min</span>(dp[t], w[j]);</span><br><span class="line">                <span class="keyword">else</span> dp[j] = <span class="built_in">max</span>(dp[t],w[j]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt ++] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(zh, <span class="number">-1</span>, <span class="keyword">sizeof</span> zh);</span><br><span class="line">    <span class="built_in">memset</span>(rh, <span class="number">-1</span>, <span class="keyword">sizeof</span> rh);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(zh, a, b), <span class="built_in">add</span>(rh, b, a);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">add</span>(zh, b, a), <span class="built_in">add</span>(rh, a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spfa</span>(dpmin, <span class="number">1</span>, zh);</span><br><span class="line">    <span class="built_in">spfa</span>(dpmax, n, rh);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = -INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dpmax[i] - dpmin[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>图论</category>
        <category>最短路</category>
        <category>与dp结合</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 342 道路与航线</title>
    <url>/2022/09/02/AcWing-342-%E9%81%93%E8%B7%AF%E4%B8%8E%E8%88%AA%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="AcWing-342-道路与航线"><a href="#AcWing-342-道路与航线" class="headerlink" title="AcWing 342 道路与航线"></a><a href="https://www.acwing.com/problem/content/342/">AcWing 342 道路与航线</a></h2><p>在郊区有 N 座通信基站，P 条 双向 电缆，第 i 条电缆连接基站 Ai 和 Bi。</p>
<p>特别地，1 号基站是通信公司的总站，N 号基站位于一座农场中。</p>
<p>现在，农场主希望对通信线路进行升级，其中升级第 i 条电缆需要花费 Li。</p>
<p>电话公司正在举行优惠活动。</p>
<p>农产主可以指定一条从 1 号基站到 N 号基站的路径，并指定路径上不超过 K 条电缆，由电话公司免费提供升级服务。</p>
<p>农场主只需要支付在该路径上剩余的电缆中，升级价格最贵的那条电缆的花费即可。</p>
<p>求至少用多少钱可以完成升级。</p>
<p>输入格式<br>第 1 行：三个整数 N，P，K。</p>
<p>第 2..P+1 行：第 i+1 行包含三个整数 Ai,Bi,Li。</p>
<p>输出格式<br>包含一个整数表示最少花费。</p>
<p>若 1 号基站与 N 号基站之间不存在路径，则输出 −1。</p>
<p>数据范围<br>0 ≤ K &lt; N ≤ 1000,<br>1 ≤ P ≤ 10000,<br>1 ≤ Li ≤ 1000000<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 7 1</span><br><span class="line">1 2 5</span><br><span class="line">3 1 4</span><br><span class="line">2 4 8</span><br><span class="line">3 2 3</span><br><span class="line">5 2 9</span><br><span class="line">3 4 7</span><br><span class="line">4 5 6</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目告诉</p>
<ul>
<li>道路全为整数且为双向边</li>
<li>航线单向边且边权有正有负但是包含航线的路线是不具有环的（把道路团看成结点后就是是一个拓扑图）</li>
</ul>
<p>对于本题我们不难看出来的本题是一道单源最短路问题且带有边权为负数，<strong>但是sfpa会被卡成nm = 1e9的级别所以不可以用spfa算法</strong></p>
<p>细节处理</p>
<ol>
<li>证明道路可以看成一个团（团内没有航线）<br>反证法：如果团内有航线，由于道路是具有双向边的所以相邻的两点之间一定是相通的，这样就和航线两端是不存在环的，所以一定存在一个团内部的点都有且仅有道路连通</li>
<li>思路上我们把团缩成一个点，大体上做拓扑排序问题内部做dijksra算法问题</li>
<li>如何把全部点分成一个一个团<br>通过dfs/bfs/并查集，我们把通过道路连通的点分成一个团，最后就可以得到不同的团</li>
<li>如何将拓扑序和dijkstra结合起来<br>Step1.读入所有的道路，用dfs算法将所有的道路分成团并对团进行编号<br>Step2.读入所有的航线并记录所有点的入读<br>Step3.做topsort（）<br>Step4.把所有入度为0的团加入到堆当中，然后对团内部做dijkstra算法</li>
<li>dijkstra算法<br>当前的dijkstra算法要平时的不同，对点的邻点做更新。如果id[i] == id[j]说明这两个点在同一个团当中，如果可以更新就进行更新，然后加入到堆当中，如果id[i] != id[j]的话，说明不在同一个团当中通过航相连，并对bock[id[j]]的入度点做减一更新</li>
</ol>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25010</span>, M = <span class="number">50000</span> * <span class="number">3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,p,S;</span><br><span class="line"><span class="type">int</span> h[N],e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> bcnt;</span><br><span class="line"><span class="type">int</span> id[N], bin[N], dist[N]; <span class="comment">// id[x]表示x点在那个团当中 </span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; block[N];   <span class="comment">// 保存是每个团当中的结点编号</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> bid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对id和block数组进行初始化</span></span><br><span class="line">    id[u] = bid, block[bid].<span class="built_in">pb</span>(u);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!id[j])</span><br><span class="line">            <span class="built_in">dfs</span>(j,bid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> bid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 建立heap</span></span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u : block[bid])</span><br><span class="line">        heap.<span class="built_in">push</span>(&#123;dist[u], u&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;   <span class="comment">// 每个点只会被更新一次 </span></span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(id[ver] == id[j])</span><br><span class="line">                    heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(id[j] != id[ver] &amp;&amp; -- bin[id[j]] == <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(id[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[S] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bcnt; i ++)</span><br><span class="line">        <span class="keyword">if</span>(!bin[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">dijkstra</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; S;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过道路建图</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c),<span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立团</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; i ++)</span><br><span class="line">        <span class="keyword">if</span>(!id[i])</span><br><span class="line">            <span class="built_in">dfs</span>(i, ++ bcnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入航线 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; p; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        bin[id[b]] ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i  = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">if</span>(dist[i] &gt; INF / <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;NO PATH&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; dist[i] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AcWing</category>
        <category>图论</category>
        <category>最短路</category>
        <category>多种最短路算法结合</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 920. 最优乘车</title>
    <url>/2022/08/11/AcWing-920-%E6%9C%80%E4%BC%98%E4%B9%98%E8%BD%A6/</url>
    <content><![CDATA[<h2 id="AcWing-920-最优乘车"><a href="#AcWing-920-最优乘车" class="headerlink" title="AcWing 920. 最优乘车"></a><a href="https://www.acwing.com/problem/content/342/">AcWing 920. 最优乘车</a></h2><p>在郊区有 N 座通信基站，P 条 双向 电缆，第 i 条电缆连接基站 Ai 和 Bi。</p>
<p>特别地，1 号基站是通信公司的总站，N 号基站位于一座农场中。</p>
<p>现在，农场主希望对通信线路进行升级，其中升级第 i 条电缆需要花费 Li。</p>
<p>电话公司正在举行优惠活动。</p>
<p>农产主可以指定一条从 1 号基站到 N 号基站的路径，并指定路径上不超过 K 条电缆，由电话公司免费提供升级服务。</p>
<p>农场主只需要支付在该路径上剩余的电缆中，升级价格最贵的那条电缆的花费即可。</p>
<p>求至少用多少钱可以完成升级。</p>
<p>输入格式<br>第 1 行：三个整数 N，P，K。</p>
<p>第 2..P+1 行：第 i+1 行包含三个整数 Ai,Bi,Li。</p>
<p>输出格式<br>包含一个整数表示最少花费。</p>
<p>若 1 号基站与 N 号基站之间不存在路径，则输出 −1。</p>
<p>数据范围<br>0≤K<N≤1000,
1≤P≤10000,
1≤Li≤1000000
输入样例：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 7 1</span><br><span class="line">1 2 5</span><br><span class="line">3 1 4</span><br><span class="line">2 4 8</span><br><span class="line">3 2 3</span><br><span class="line">5 2 9</span><br><span class="line">3 4 7</span><br><span class="line">4 5 6</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>本题难题在于输入以及建图的层面</p>
<p>输入使用sstream(按行读入，甚至是能读入换行符号的)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string line;</span><br><span class="line"><span class="built_in">getline</span>(cin, line); <span class="comment">// 把第一行的换行符给清空</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);</span><br><span class="line">    <span class="function">stringstream <span class="title">ssin</span><span class="params">(line)</span></span>;</span><br><span class="line">    <span class="type">int</span> p, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 因为要求换乘次数最少所以应该同一条线路上的所有点都是相通的</span></span><br><span class="line">    <span class="keyword">while</span>(ssin &gt;&gt; p) stop[cnt ++ ] = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>建图<br>由于题目要求我们求出来换成次数最少所以在建图上一条线路上的所有站两两之间都是的相连通的</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边权为一，bfs可以求最小换成次数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], stop[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> q[N];</span><br><span class="line">    q[++ tt] = <span class="number">1</span>;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + <span class="number">1</span>;</span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line); <span class="comment">// 把第一行的换行符给清空</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin, line);</span><br><span class="line">        <span class="function">stringstream <span class="title">ssin</span><span class="params">(line)</span></span>;</span><br><span class="line">        <span class="type">int</span> p, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 因为要求换乘次数最少所以应该同一条线路上的所有点都是相通的</span></span><br><span class="line">        <span class="keyword">while</span>(ssin &gt;&gt; p) stop[cnt ++ ] = p;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; cnt; j ++)</span><br><span class="line">                <span class="built_in">add</span>(stop[i],stop[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dist[m] == INF) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">max</span>(dist[m] - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>输入问题</tag>
        <tag>建图</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 1699B Almost Ternary Matrix</title>
    <url>/2022/07/13/CF-1699B-Almost-Ternary-Matrix/</url>
    <content><![CDATA[<h2 id="CF-1699B"><a href="#CF-1699B" class="headerlink" title="CF-1699B"></a><a href="https://codeforces.com/problemset/problem/1699/B">CF-1699B</a></h2><p>You are given two even integers 𝑛 and 𝑚. Your task is to find any binary matrix 𝑎 with 𝑛 rows and 𝑚 columns where every cell (𝑖,𝑗) has exactly two neighbours with a different value than 𝑎𝑖,𝑗.</p>
<p>Two cells in the matrix are considered neighbours if and only if they share a side. More formally, the neighbours of cell (𝑥,𝑦) are: (𝑥−1,𝑦), (𝑥,𝑦+1), (𝑥+1,𝑦) and (𝑥,𝑦−1).</p>
<p>It can be proven that under the given constraints, an answer always exists.</p>
<p>Input<br>Each test contains multiple test cases. The first line of input contains a single integer 𝑡 (1≤𝑡≤100) — the number of test cases. The following lines contain the descriptions of the test cases.</p>
<p>The only line of each test case contains two even integers 𝑛 and 𝑚 (2≤𝑛,𝑚≤50) — the height and width of the binary matrix, respectively.</p>
<p>Output<br>For each test case, print 𝑛 lines, each of which contains 𝑚 numbers, equal to 0 or 1 — any binary matrix which satisfies the constraints described in the statement.</p>
<p>It can be proven that under the given constraints, an answer always exists.</p>
<p>Example<br>input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 4</span><br><span class="line">2 2</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><br>output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 0 0 1</span><br><span class="line">0 1 1 0</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">1 0 1 0</span><br><span class="line">0 0 1 1</span><br><span class="line">1 1 0 0</span><br><span class="line">0 1 0 1</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p> <img src="[https://](https://codeforces.com/predownloaded/75/c4/75c46e19cc3cf6f890139b0e74774c3a6fc387db.png" alt="">)<br>我们需要构造上图的2x2矩形，我们可以看出宏观上来看都是每个2个连续出现两次黑块/白块，左上角的坐标记作（1，1）我们可以得到一个公式 (i%4 &lt;=1 != j%4&lt;= 1) / (i%4 &lt;=1 == j%4&lt;= 1)时是黑块</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span>x</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; ((i % <span class="number">4</span> &lt;= <span class="number">1</span>) == (j % <span class="number">4</span> &lt;= <span class="number">1</span>)) &lt;&lt; <span class="string">&quot; \n&quot;</span>[j==m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CodeForces</category>
        <category>思维题</category>
      </categories>
      <tags>
        <tag>思维题</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 631C REPORT</title>
    <url>/2022/07/12/CF-631C-Report/</url>
    <content><![CDATA[<h2 id="CF-631C-REPORT"><a href="#CF-631C-REPORT" class="headerlink" title="CF 631C REPORT"></a><a href="https://codeforces.com/contest/631/problem/C">CF 631C REPORT</a></h2><p>Each month Blake gets the report containing main economic indicators of the company “Blake Technologies”. There are n commodities produced by the company. For each of them there is exactly one integer in the final report, that denotes corresponding revenue. Before the report gets to Blake, it passes through the hands of m managers. Each of them may reorder the elements in some order. Namely, the i-th manager either sorts first ri numbers in non-descending or non-ascending order and then passes the report to the manager i + 1, or directly to Blake (if this manager has number i = m).</p>
<p>Employees of the “Blake Technologies” are preparing the report right now. You know the initial sequence ai of length n and the description of each manager, that is value ri and his favourite order. You are asked to speed up the process and determine how the final report will look like.</p>
<p>Input<br>The first line of the input contains two integers n and m (1 ≤ n, m ≤ 200 000) — the number of commodities in the report and the number of managers, respectively.</p>
<p>The second line contains n integers ai (|ai| ≤ 109) — the initial report before it gets to the first manager.</p>
<p>Then follow m lines with the descriptions of the operations managers are going to perform. The i-th of these lines contains two integers ti and ri (, 1 ≤ ri ≤ n), meaning that the i-th manager sorts the first ri numbers either in the non-descending (if ti = 1) or non-ascending (if ti = 2) order.</p>
<p>Output<br>Print n integers — the final report, which will be passed to Blake by manager number m.</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在本题一共只有两种操作op1是非严格递减op2是非严格递增（也就是说里面可能有相同的数字）<br><strong>优化一</strong>  对于不同的操作，只要后一个操作操作的区间比上一个区间要更加的大的话那么上一个区间的操作就无效，因为会被覆盖掉。所以我们对操作区间做一个单调递减的记录（使用单调栈）<br><strong>优化二</strong>  经过第一步的优化我们可以的得到一个单调递减的操作区间。 对于[1,5],[1,3]区间操作op1，op2。在这个尝试探讨op看是否有特殊性质<br>op1 == op2（操作相同）<br>op2没有意义必然被大区间的操作覆盖<br>op1 != op2<br>假设大区间是非严格递减小区间是非严格递增，那么[4,5]这个区间是[1,5]这个区间是整个大区间里最小的两个数<br>假设大区间是非严格递增小区间是非严格递减，那么[4,5]这个区间是整个大区间里的最大的两个数</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> st[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2是降序 1是升序</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>;st[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>,st[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// st[1]是栈底 st[1][0]为栈底第一元素，表示的是操作范围,st[1][1]为栈底第二元素表示是操作类型</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, op;<span class="built_in">cin</span> &gt;&gt; op &gt;&gt; a;</span><br><span class="line">        <span class="keyword">while</span>(hh &amp;&amp; st[hh][<span class="number">0</span>] &lt;= a) hh --;</span><br><span class="line">        st[++hh][<span class="number">0</span>] = a, st[hh][<span class="number">1</span>] = op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(arr,arr + st[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = st[<span class="number">1</span>][<span class="number">0</span>], k = hh + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p = r;</span><br><span class="line">    st[k][<span class="number">0</span>] = <span class="number">0</span>,st[k][<span class="number">1</span>] = <span class="number">1</span>;   <span class="comment">// 处理边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op = st[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(p &gt; st[i+<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            p --;</span><br><span class="line">            <span class="comment">// 升序取最大值 降序取最小值（这里使用双指针对其赋值）</span></span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">1</span>) ans[p] = arr[--r];</span><br><span class="line">            <span class="keyword">else</span> ans[p] = arr[l++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = st[<span class="number">1</span>][<span class="number">0</span>]; i &lt; n; i ++) ans[i] = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CodeForces</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 337D Book of Evil</title>
    <url>/2022/07/15/CF337D-Book-of-Evil/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>CodeForces - 1529C Parsa&#39;s Humongous Tree</title>
    <url>/2022/08/05/CodeForces-1529C-Parsa-s-Humongous-Tree/</url>
    <content><![CDATA[<h2 id="CodeForces-1529C-Parsa’s-Humongous-Tree"><a href="#CodeForces-1529C-Parsa’s-Humongous-Tree" class="headerlink" title="CodeForces - 1529C Parsa’s Humongous Tree"></a><a href="https://vjudge.net/problem/CodeForces-1529C">CodeForces - 1529C Parsa’s Humongous Tree</a></h2><p>Parsa has a humongous tree on 𝑛 vertices.</p>
<p>On each vertex 𝑣 he has written two integers 𝑙𝑣 and 𝑟𝑣.</p>
<p>To make Parsa’s tree look even more majestic, Nima wants to assign a number 𝑎𝑣 (𝑙𝑣≤𝑎𝑣≤𝑟𝑣) to each vertex 𝑣 such that the beauty of Parsa’s tree is maximized.</p>
<p>Nima’s sense of the beauty is rather bizarre. He defines the beauty of the tree as the sum of |𝑎𝑢−𝑎𝑣| over all edges (𝑢,𝑣) of the tree.</p>
<p>Since Parsa’s tree is too large, Nima can’t maximize its beauty on his own. Your task is to find the maximum possible beauty for Parsa’s tree.</p>
<p>Input<br>The first line contains an integer 𝑡 (1≤𝑡≤250) — the number of test cases. The description of the test cases follows.</p>
<p>The first line of each test case contains a single integer 𝑛 (2≤𝑛≤105) — the number of vertices in Parsa’s tree.</p>
<p>The 𝑖-th of the following 𝑛 lines contains two integers 𝑙𝑖 and 𝑟𝑖 (1≤𝑙𝑖≤𝑟𝑖≤109).</p>
<p>Each of the next 𝑛−1 lines contains two integers 𝑢 and 𝑣 (1≤𝑢,𝑣≤𝑛,𝑢≠𝑣) meaning that there is an edge between the vertices 𝑢 and 𝑣 in Parsa’s tree.</p>
<p>It is guaranteed that the given graph is a tree.</p>
<p>It is guaranteed that the sum of 𝑛 over all test cases doesn’t exceed 2⋅105.</p>
<p>Output<br>For each test case print the maximum possible beauty for Parsa’s tree.</p>
<p><strong>Example</strong><br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1 6</span><br><span class="line">3 8</span><br><span class="line">1 2</span><br><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">4 6</span><br><span class="line">7 9</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">6</span><br><span class="line">3 14</span><br><span class="line">12 20</span><br><span class="line">12 19</span><br><span class="line">2 12</span><br><span class="line">10 17</span><br><span class="line">3 17</span><br><span class="line">3 2</span><br><span class="line">6 5</span><br><span class="line">1 5</span><br><span class="line">2 6</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">8</span><br><span class="line">62</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目要求每个节点在区间[l,r]中选一个值，每一条边的边权 == 两点的之间的绝对值，求出一颗树中的边权的最大值</p>
<p><strong>贪心</strong><br>贪心决策： 实际上每个树的节点只取选取l/r</p>
<p>贪心证明<br>前提父节点为u，父节点有多个子节点，父节点的数值为au,子节点为数值为av，有p个比au大的子节点单av， 有q个比au小的子节点</p>
<ol>
<li>p &gt; q   ∑ |au - av| 那么au 应该越小求和越大(比如在[3,8]区间中选一个中值，x 假设有两个av ==  9， 一个 av = 2，当x取5的时候∑ = 3 + 4 + 4，但是当x取3的时候 ∑ = 1 + 6 + 6,因为比贡献等等于p的个数累加的)</li>
<li>p &lt; q </li>
<li>p = q</li>
</ol>
<p>所以我们就可以定义dp数组<br>dp[i][0]表示选的l,dp[i][1]选r</p>
<p>因为l、r&lt; 1e9 ，所以总和是可能爆int，记得用long long</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">2</span> * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">2</span>];   <span class="comment">// dp[i][0]表示选的l,dp[i][1]选r</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;    <span class="comment">// tree(无向边)</span></span><br><span class="line">PII node[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(j,u);</span><br><span class="line">        dp[u][<span class="number">0</span>] += <span class="built_in">max</span>(dp[j][<span class="number">0</span>] + <span class="built_in">abs</span>(node[u].fi - node[j].fi), dp[j][<span class="number">1</span>] + <span class="built_in">abs</span>(node[u].fi - node[j].se));</span><br><span class="line">        dp[u][<span class="number">1</span>] += <span class="built_in">max</span>(dp[j][<span class="number">0</span>] + <span class="built_in">abs</span>(node[u].se - node[j].fi), dp[j][<span class="number">1</span>] + <span class="built_in">abs</span>(node[u].se - node[j].se));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init()</span></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l, r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            node[i] = &#123;l,r&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;  n - <span class="number">1</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="built_in">add</span>(a,b);</span><br><span class="line">            <span class="built_in">add</span>(b,a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CodeForces</category>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
        <tag>动态规划</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces-295B Greg and Graph</title>
    <url>/2022/07/21/CodeForces-295B-Greg-and-Graph/</url>
    <content><![CDATA[<h2 id="CodeForces-295B-Greg-and-Graph"><a href="#CodeForces-295B-Greg-and-Graph" class="headerlink" title="CodeForces-295B Greg and Graph"></a><a href="https://vjudge.net/problem/CodeForces-295B">CodeForces-295B Greg and Graph</a></h2><p>Greg has a weighed directed graph, consisting of n vertices. In this graph any pair of distinct vertices has an edge between them in both directions. Greg loves playing with the graph and now he has invented a new game:</p>
<p>The game consists of n steps.<br>On the i-th step Greg removes vertex number xi from the graph. As Greg removes a vertex, he also removes all the edges that go in and out of this vertex.<br>Before executing each step, Greg wants to know the sum of lengths of the shortest paths between all pairs of the remaining vertices. The shortest path can go through any remaining vertex. In other words, if we assume that d(i, v, u) is the shortest path between vertices v and u in the graph that formed before deleting vertex xi, then Greg wants to know the value of the following sum: .<br>Help Greg, print the value of the required sum before each step.</p>
<p>Input<br>The first line contains integer n (1 ≤ n ≤ 500) — the number of vertices in the graph.</p>
<p>Next n lines contain n integers each — the graph adjacency matrix: the j-th number in the i-th line aij (1 ≤ aij ≤ 105, aii = 0) represents the weight of the edge that goes from vertex i to vertex j.</p>
<p>The next line contains n distinct integers: x1, x2, …, xn (1 ≤ xi ≤ n) — the vertices that Greg deletes.</p>
<p>Output<br>Print n integers — the i-th number equals the required sum before the i-th step.</p>
<p>Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams of the %I64d specifier.</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>本题需要深入理解floyd原理</strong><br>也就是说给我们每次要删去的点，每次都求一下两点之间的最短路。<br>要是我们每删一个点再去做一遍多源最短路的话，那么时间复杂度会变为O（n^4).<br>这里floyd算法要注意两点：</p>
<ol>
<li>floyd本质上就是一个dp问题，状态转移方程为∑d[i][j]= min(d[i][j],d[i][k] + d[k][j]);<br>这里的状态方程可以表示为从i-&gt;j的最短距离，i到j这个路径上可以被分成了两段，i-&gt;k, k-&gt;j，那我们就可以得到我们的最优子结构了(这里的内层循环k）。</li>
<li>实际上floyd也可以理解为选择一个顶点集作为顶点的中转站 S，假如第一次选了1号ver作为中转，那么我们的所有顶点都可以用1号顶点做为中转站更新距离。（这里是外层循环k）</li>
</ol>
<p>那么本题问题我们就可以转化为加点问题（每次选一个点作为中转，等用于我们加点加入了S集合当中），逆向floyd</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; <span class="built_in">assert</span>(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line">ll g[N][N];</span><br><span class="line"><span class="type">int</span> ver[N];</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) g[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;g[i][j]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ver[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = n; k &gt;= <span class="number">1</span>; k --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = ver[k];</span><br><span class="line">            <span class="comment">// 因为我们要逆序进行floyd，所以我们在计算两点之间的最短距离之前要知道这两个点是否在这个图当中</span></span><br><span class="line">            st[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">                    g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][u] + g[u][j]);</span><br><span class="line"></span><br><span class="line">            ll res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">                    <span class="keyword">if</span>(st[i] &amp;&amp; st[j])</span><br><span class="line">                        res += g[i][j];</span><br><span class="line">            <span class="comment">// 题目要求在我们删点之前计算最长路径，那么逆序就变为加点之后计算最长路径 </span></span><br><span class="line">            ans[k] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld%c&quot;</span>,ans[i],i==n?<span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 629D Babaei and Birthday Cake</title>
    <url>/2022/07/30/CodeForces-629D-Babaei-and-Birthday-Cake/</url>
    <content><![CDATA[<h2 id="CodeForces-629D-Babaei-and-Birthday-Cake-线段树优化dp"><a href="#CodeForces-629D-Babaei-and-Birthday-Cake-线段树优化dp" class="headerlink" title="CodeForces - 629D Babaei and Birthday Cake 线段树优化dp"></a><a href="https://vjudge.net/problem/CodeForces-629D">CodeForces - 629D Babaei and Birthday Cake 线段树优化dp</a></h2><p>As you know, every birthday party has a cake! This time, Babaei is going to prepare the very special birthday party’s cake.<br>Simple cake is a cylinder of some radius and height. The volume of the simple cake is equal to the volume of corresponding cylinder. Babaei has n simple cakes and he is going to make a special cake placing some cylinders on each other.<br>However, there are some additional culinary restrictions. The cakes are numbered in such a way that the cake number i can be placed only on the table or on some cake number j where j &lt; i. Moreover, in order to impress friends Babaei will put the cake i on top of the cake j only if the volume of the cake i is strictly greater than the volume of the cake j.<br>Babaei wants to prepare a birthday cake that has a maximum possible total volume. Help him find this value.</p>
<p>Input<br>The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of simple cakes Babaei has.<br>Each of the following n lines contains two integers ri and hi (1 ≤ ri, hi ≤ 10 000), giving the radius and height of the i-th cake.</p>
<p>Output<br>Print the maximum volume of the cake that Babaei can make. Your answer will be considered correct if its absolute or relative error does not exceed $10^-6$.</p>
<p>Sample 1<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">100 30</span><br><span class="line">40 10</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">942477.796077000</span><br></pre></td></tr></table></figure><br>Sample 2<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">9 7</span><br><span class="line">1 4</span><br><span class="line">10 7</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3983.539484752</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目要求在全部合法方案的中选择cake的体积最大<br>合法方案：当我们选择编号为j时候</p>
<ol>
<li>编号j一定要大于i的编号</li>
<li>j的体积一定要严格小于i</li>
</ol>
<p>普通的dp<br>dp[i]： 表示以i结尾的最大体积<br>所以这里就不能以从i-1转移过来一定是要遍历完全部的1～i-1才可以找到最优解<br>所以普通的dp是$O(n^2)$<br>n是1e5所以我们需要对dp做优化</p>
<p>线段树的优化dp<br>依然是dp[i]，但是我们在作1～i-1区间查询如果使用线段树那么就可以转化成$O(nlogn)$</p>
]]></content>
      <categories>
        <category>CodeForces</category>
        <category>动态规划</category>
        <category>线段树优化</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>线段树优化dp问题</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 777E Hanoi Factory</title>
    <url>/2022/07/31/CodeForces-777E-Hanoi-Factory/</url>
    <content><![CDATA[<h2 id="CodeForces-777E-Hanoi-Factory"><a href="#CodeForces-777E-Hanoi-Factory" class="headerlink" title="CodeForces - 777E Hanoi Factory"></a><a href="https://vjudge.net/problem/CodeForces-777E#author=0">CodeForces - 777E Hanoi Factory</a></h2><p>Of course you have heard the famous task about Hanoi Towers, but did you know that there is a special factory producing the rings for this wonderful game? Once upon a time, the ruler of the ancient Egypt ordered the workers of Hanoi Factory to create as high tower as possible. They were not ready to serve such a strange order so they had to create this new tower using already produced rings.</p>
<p>There are n rings in factory’s stock. The i-th ring has inner radius ai, outer radius bi and height hi. The goal is to select some subset of rings and arrange them such that the following conditions are satisfied:</p>
<p>Outer radiuses form a non-increasing sequence, i.e. one can put the j-th ring on the i-th ring only if bj ≤ bi.<br>Rings should not fall one into the the other. That means one can place ring j on the ring i only if bj &gt; ai.<br>The total height of all rings used should be maximum possible.<br>Input<br>The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of rings in factory’s stock.</p>
<p>The i-th of the next n lines contains three integers ai, bi and hi (1 ≤ ai, bi, hi ≤ 109, bi &gt; ai) — inner radius, outer radius and the height of the i-th ring respectively.</p>
<p>Output<br>Print one integer — the maximum height of the tower that can be obtained.</p>
<p>Sample 1<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 5 1</span><br><span class="line">2 6 2</span><br><span class="line">3 7 3</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><br>Sample 2<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 1</span><br><span class="line">1 3 3</span><br><span class="line">4 6 2</span><br><span class="line">5 7 1</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><br>Note<br>In the first sample, the optimal solution is to take all the rings and put them on each other in order 3, 2, 1.</p>
<p>In the second sample, one can put the ring 3 on the ring 4 and get the tower of height 3, or put the ring 1 on the ring 2 and get the tower of height 4.</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>dp[i] ：以i结尾的所有合法方案的最大值<br>ans = max ∑ dp[i]</p>
<p>合法方案<br>$ai &lt; bj &lt;= bi$ </p>
<p>正常的dp<br>Step1 ：对bi进行从大到小进行排序<br>Step2 : 从前bi个区间中找出所有方案的中的最大价值<br>Step3 ：更新dp[bi]<br>时间复杂度：$O(n^2)$</p>
<p>树状数组优化：<br>主要对step2进行优化的对$O(n)$优化成$O(logn)$</p>
<p>合法方案是包括两个决策变量的</p>
<ol>
<li>ai &lt; bj</li>
<li>bj &lt;= bi<br>通过对bi从大到小排序再去枚举的话我们就可以减少一个决策，然后离散a数组，这样就可以构造出来一个单调的a数组，用线段树进行维护我们就可以的用$O(nlogn)$来解决问题</li>
</ol>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,h;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp; t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b == t.b) <span class="keyword">return</span> a &gt; t.a;</span><br><span class="line">        <span class="keyword">return</span> b &gt; t.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ring[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll maxn;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll dp[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; va;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(va.<span class="built_in">begin</span>(), va.<span class="built_in">end</span>(), x) - va.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].maxn = <span class="built_in">max</span>(tr[u &lt;&lt; <span class="number">1</span>].maxn, tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].maxn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l,r,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l,r,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, ll d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == x &amp;&amp; tr[u].r == x)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].maxn = <span class="built_in">max</span>(tr[u].maxn, d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, d);</span><br><span class="line">        <span class="keyword">if</span>(x &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, d);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tr[u].maxn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) res = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,h;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; h;</span><br><span class="line">        ring[i] = &#123;a,b,h&#125;;</span><br><span class="line">        va.<span class="built_in">pb</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态规划的策略选择是ai &lt; bj &lt;= bi</span></span><br><span class="line">    <span class="comment">// 所以如果先对bi进行排序这样找到选择方案的时候我们不需要判断bj &lt;= bi，因为枚举时候的bj总是的比bi晚枚举</span></span><br><span class="line">    <span class="built_in">sort</span>(ring + <span class="number">1</span>, ring + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(va));</span><br><span class="line">    va.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(va)),va.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 因为已经按照b从大向小排序，所以需要二分找到的是ai &lt; bj</span></span><br><span class="line">        dp[i] = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="built_in">find</span>(ring[i].b) - <span class="number">1</span>) + ring[i].h;</span><br><span class="line">        <span class="comment">// 因为我们是离散构造出来va数组，并利用va数组的单调性二分查找ai &lt; bj所以要在ring[i].a上修改值</span></span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="built_in">find</span>(ring[i].a), dp[i]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CodeForces</category>
        <category>动态规划</category>
        <category>线段树优化</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 91B Queue</title>
    <url>/2022/07/31/CodeForces-91B-Queue/</url>
    <content><![CDATA[<h2 id="CodeForces-91B-Queue"><a href="#CodeForces-91B-Queue" class="headerlink" title="CodeForces - 91B Queue"></a><a href="https://vjudge.net/problem/CodeForces-91B">CodeForces - 91B Queue</a></h2><p>There are n walruses standing in a queue in an airport. They are numbered starting from the queue’s tail: the 1-st walrus stands at the end of the queue and the n-th walrus stands at the beginning of the queue. The i-th walrus has the age equal to ai.</p>
<p>The i-th walrus becomes displeased if there’s a younger walrus standing in front of him, that is, if exists such j (i &lt; j), that ai &gt; aj. The displeasure of the i-th walrus is equal to the number of walruses between him and the furthest walrus ahead of him, which is younger than the i-th one. That is, the further that young walrus stands from him, the stronger the displeasure is.</p>
<p>The airport manager asked you to count for each of n walruses in the queue his displeasure.</p>
<p>Input<br>The first line contains an integer n (2 ≤ n ≤ 105) — the number of walruses in the queue. The second line contains integers ai (1 ≤ ai ≤ 109).</p>
<p>Note that some walruses can have the same age but for the displeasure to emerge the walrus that is closer to the head of the queue needs to be strictly younger than the other one.</p>
<p>Output<br>Print n numbers: if the i-th walrus is pleased with everything, print “-1” (without the quotes). Otherwise, print the i-th walrus’s displeasure: the number of other walruses that stand between him and the furthest from him younger walrus.</p>
<p>Sample 1<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">10 8 5 3 50 45</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1 0 -1 0 -1 </span><br></pre></td></tr></table></figure><br>Sample 2<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">10 4 6 3 2 8 15</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 1 0 -1 -1 -1 </span><br></pre></td></tr></table></figure><br>Sample 3<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5	</span><br><span class="line">10 3 1 10 11</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 0 -1 -1 -1</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>本题要我们求每个数的右边最远的比自己小的数字<br>很明显本题可以通过二分找出右边第一个比当前数字要小的位置。但是二分必须要满足二段性，所以我们需要先预处理一遍数组，使得数字满足二义性。<br>本题预处理的数从数组末尾开始处理的当前位置右边最小的数值是什么。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一定要看清楚题意！！！</span></span><br><span class="line">    <span class="comment">// 我们应该要往右找到最后一个比当前的值要小的数值，并且答案 = r - l</span></span><br><span class="line">    <span class="comment">// 要想使用二分搜索就一定要求有二段性</span></span><br><span class="line">    <span class="built_in">memset</span>(s,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> s);</span><br><span class="line">    <span class="comment">// s[i]表示从n~i之间的最小值，从1～n顺序去看是非严格下降的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">        s[i] = <span class="built_in">min</span>(s[i+<span class="number">1</span>], a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = i, r = n;</span><br><span class="line">        <span class="comment">// 整数二分</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span>&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 要找从右边开始的第一个比a[i]小的数</span></span><br><span class="line">            <span class="keyword">if</span>(s[mid] &lt; a[i]) l = mid;  </span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, l - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CodeForces</category>
        <category>二分</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1026 Ignatius and the Princess I</title>
    <url>/2022/07/21/HDU-1026-Ignatius-and-the-Princess-I/</url>
    <content><![CDATA[<h2 id="HDU-1026-Ignatius-and-the-Princess-I"><a href="#HDU-1026-Ignatius-and-the-Princess-I" class="headerlink" title="HDU-1026 Ignatius and the Princess I"></a><a href="https://vjudge.net/problem/HDU-1026">HDU-1026 Ignatius and the Princess I</a></h2><p>The Princess has been abducted by the BEelzebub feng5166, our hero Ignatius has to rescue our pretty Princess. Now he gets into feng5166’s castle. The castle is a large labyrinth. To make the problem simply, we assume the labyrinth is a N*M two-dimensional array which left-top corner is (0,0) and right-bottom corner is (N-1,M-1). Ignatius enters at (0,0), and the door to feng5166’s room is at (N-1,M-1), that is our target. There are some monsters in the castle, if Ignatius meet them, he has to kill them. Here is some rules:</p>
<p>1.Ignatius can only move in four directions(up, down, left, right), one step per second. A step is defined as follow: if current position is (x,y), after a step, Ignatius can only stand on (x-1,y), (x+1,y), (x,y-1) or (x,y+1).<br>2.The array is marked with some characters and numbers. We define them like this:<br>. : The place where Ignatius can walk on.<br>X : The place is a trap, Ignatius should not walk on it.<br>n : Here is a monster with n HP(1&lt;=n&lt;=9), if Ignatius walk on it, it takes him n seconds to kill the monster.</p>
<p>Your task is to give out the path which costs minimum seconds for Ignatius to reach target position. You may assume that the start position and the target position will never be a trap, and there will never be a monster at the start position.<br><code>Input</code><br>The input contains several test cases. Each test case starts with a line contains two numbers N and M(2&lt;=N&lt;=100,2&lt;=M&lt;=100) which indicate the size of the labyrinth. Then a N*M two-dimensional array follows, which describe the whole labyrinth. The input is terminated by the end of file. More details in the Sample Input.<br><code>Output</code><br>For each test case, you should output “God please help our poor hero.” if Ignatius can’t reach the target position, or you should output “It takes n seconds to reach the target position, let me show you the way.”(n is the minimum seconds), and tell our hero the whole path. Output a line contains “FINISH” after each test case. If there are more than one path, any one is OK in this problem. More details in the Sample Output.</p>
<p>Sample<br><code>Input</code><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 6</span><br><span class="line">.XX.1.</span><br><span class="line">..X.2.</span><br><span class="line">2...X.</span><br><span class="line">...XX.</span><br><span class="line">XXXXX.</span><br><span class="line">5 6</span><br><span class="line">.XX.1.</span><br><span class="line">..X.2.</span><br><span class="line">2...X.</span><br><span class="line">...XX.</span><br><span class="line">XXXXX1</span><br><span class="line">5 6</span><br><span class="line">.XX...</span><br><span class="line">..XX1.</span><br><span class="line">2...X.</span><br><span class="line">...XX.</span><br><span class="line">XXXXX.</span><br></pre></td></tr></table></figure><br><code>Output</code><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">It takes 13 seconds to reach the target position, let me show you the way.</span><br><span class="line">1s:(0,0)-&gt;(1,0)</span><br><span class="line">2s:(1,0)-&gt;(1,1)</span><br><span class="line">3s:(1,1)-&gt;(2,1)</span><br><span class="line">4s:(2,1)-&gt;(2,2)</span><br><span class="line">5s:(2,2)-&gt;(2,3)</span><br><span class="line">6s:(2,3)-&gt;(1,3)</span><br><span class="line">7s:(1,3)-&gt;(1,4)</span><br><span class="line">8s:FIGHT AT (1,4)</span><br><span class="line">9s:FIGHT AT (1,4)</span><br><span class="line">10s:(1,4)-&gt;(1,5)</span><br><span class="line">11s:(1,5)-&gt;(2,5)</span><br><span class="line">12s:(2,5)-&gt;(3,5)</span><br><span class="line">13s:(3,5)-&gt;(4,5)</span><br><span class="line">FINISH</span><br><span class="line">It takes 14 seconds to reach the target position, let me show you the way.</span><br><span class="line">1s:(0,0)-&gt;(1,0)</span><br><span class="line">2s:(1,0)-&gt;(1,1)</span><br><span class="line">3s:(1,1)-&gt;(2,1)</span><br><span class="line">4s:(2,1)-&gt;(2,2)</span><br><span class="line">5s:(2,2)-&gt;(2,3)</span><br><span class="line">6s:(2,3)-&gt;(1,3)</span><br><span class="line">7s:(1,3)-&gt;(1,4)</span><br><span class="line">8s:FIGHT AT (1,4)</span><br><span class="line">9s:FIGHT AT (1,4)</span><br><span class="line">10s:(1,4)-&gt;(1,5)</span><br><span class="line">11s:(1,5)-&gt;(2,5)</span><br><span class="line">12s:(2,5)-&gt;(3,5)</span><br><span class="line">13s:(3,5)-&gt;(4,5)</span><br><span class="line">14s:FIGHT AT (4,5)</span><br><span class="line">FINISH</span><br><span class="line">God please help our poor hero.</span><br><span class="line">FINISH</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>迷宫问题，求解<code>最短路</code>并且要<code>记录路径</code>，可以使用<code>优先队列BFS</code>（等价于dijkstra）<br>要清楚无论是bfs还是dijkstra每一个点只会被更新一次说一到一个点的前面那个点一定是唯一的，换言之到某个点的路径也一定是唯一的。所以要想记录路径则使用path[][]数组记录当前点前面一个点，然后从后往前推导路径。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; <span class="built_in">assert</span>(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="type">int</span> cost[N][N];</span><br><span class="line">PII path[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">    <span class="built_in">node</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> time):<span class="built_in">x</span>(x), <span class="built_in">y</span>(y),<span class="built_in">time</span>(time)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node&amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> time &gt; t.time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                d[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                d[i][j] = g[i][j] - <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; n; i ++)</span></span><br><span class="line">    <span class="comment">//     for(int j = 0; j &lt; m; j ++)</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; d[i][j] &lt;&lt; &quot; \n&quot;[j == m-1];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">            path[i][j] = &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(cost, <span class="number">-1</span>, <span class="keyword">sizeof</span> cost);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    cost[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t.x == n<span class="number">-1</span> &amp;&amp; t.y == m<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nx = t.x + dx[i], ny = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m || d[nx][ny] == INF || cost[nx][ny] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            cost[nx][ny] = cost[t.x][t.y] + d[nx][ny];</span><br><span class="line">            path[nx][ny] = &#123;t.x,t.y&#125;;</span><br><span class="line">            <span class="comment">// 入队是时间的花销，而不是d[nx][ny],如果入队的是当前节点的值，那么很显然不符合全局最优</span></span><br><span class="line">            <span class="comment">// 如果入队的是当前到这个节点的总时间花销，这样就可以一定是全局最优了</span></span><br><span class="line">            q.<span class="built_in">push</span>(&#123;nx,ny,cost[nx][ny]&#125;);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,g[i]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>();    <span class="comment">//先把图边权建立上</span></span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cost[n<span class="number">-1</span>][m<span class="number">-1</span>] != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;It takes &quot;</span> &lt;&lt; cost[n<span class="number">-1</span>][m<span class="number">-1</span>]&lt;&lt; <span class="string">&quot; seconds to reach the target position, let me show you the way.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            vector&lt;PII&gt; ans;</span><br><span class="line">            <span class="type">int</span> tx = n - <span class="number">1</span>, ty = m - <span class="number">1</span>;</span><br><span class="line">            ans.<span class="built_in">pb</span>(&#123;tx,ty&#125;);</span><br><span class="line">            <span class="keyword">while</span>(tx != <span class="number">-1</span> &amp;&amp; ty != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a = path[tx][ty].x, b = path[tx][ty].y;</span><br><span class="line">                tx = a, ty = b;</span><br><span class="line">                ans.<span class="built_in">pb</span>(&#123;tx,ty&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = ans.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt; <span class="number">0</span>; )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tx = ans[i].x, ty = ans[i].y;</span><br><span class="line">                <span class="keyword">if</span>(d[tx][ty] &gt; <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;s:FIGHT AT (&quot;</span> &lt;&lt; tx &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; ty &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; endl;</span><br><span class="line">                    d[tx][ty] --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;s:(&quot;</span> &lt;&lt; ans[i].x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; ans[i].y &lt;&lt; <span class="string">&quot;)-&gt;(&quot;</span> &lt;&lt;</span><br><span class="line">                    ans[i<span class="number">-1</span>].x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; ans[i<span class="number">-1</span>].y &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; endl;</span><br><span class="line">                    i --;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 特判终点</span></span><br><span class="line">            <span class="keyword">while</span>(d[n<span class="number">-1</span>][m<span class="number">-1</span>] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;s:FIGHT AT (&quot;</span> &lt;&lt; n<span class="number">-1</span> &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; m<span class="number">-1</span> &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; endl;</span><br><span class="line">                d[n<span class="number">-1</span>][m<span class="number">-1</span>] --;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;FINISH&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;God please help our poor hero.&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;FINISH&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>输出最优解问题</tag>
        <tag>优先队列bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 2457 DNA repair</title>
    <url>/2022/08/08/HDU-2457-DNA-repair/</url>
    <content><![CDATA[<h2 id="HDU-2457-DNA-repair"><a href="#HDU-2457-DNA-repair" class="headerlink" title="HDU - 2457 DNA repair"></a><a href="https://vjudge.net/problem/HDU-2457#author=0">HDU - 2457 DNA repair</a></h2><p>生物学家终于发明了修复DNA的技术，能够将包含各种遗传疾病的DNA片段进行修复。</p>
<p>为了简单起见，DNA看作是一个由’A’, ‘G’ , ‘C’ , ‘T’构成的字符串。</p>
<p>修复技术就是通过改变字符串中的一些字符，从而消除字符串中包含的致病片段。</p>
<p>例如，我们可以通过改变两个字符，将DNA片段”AAGCAG”变为”AGGCAC”，从而使得DNA片段中不再包含致病片段”AAG”，”AGC”，”CAG”，以达到修复该DNA片段的目的。</p>
<p>需注意，被修复的DNA片段中，仍然只能包含字符’A’, ‘G’ , ‘C’ , ‘T’。</p>
<p>请你帮助生物学家修复给定的DNA片段，并且修复过程中改变的字符数量要尽可能的少。</p>
<p>输入格式<br>输入包含多组测试数据。</p>
<p>每组数据第一行包含整数N，表示致病DNA片段的数量。</p>
<p>接下来N行，每行包含一个长度不超过20的非空字符串，字符串中仅包含字符’A’, ‘G’ , ‘C’ , ‘T’，用以表示致病DNA片段。</p>
<p>再一行，包含一个长度不超过1000的非空字符串，字符串中仅包含字符’A’, ‘G’ , ‘C’ , ‘T’，用以表示待修复DNA片段。</p>
<p>最后一组测试数据后面跟一行，包含一个0，表示输入结束。</p>
<p>输出格式<br>每组数据输出一个结果，每个结果占一行。</p>
<p>输入形如”Case x: y”，其中x为测试数据编号（从1开始），y为修复过程中所需改变的字符数量的最小值，如果无法修复给定DNA片段，则y为”-1”。</p>
<p>数据范围<br>1≤N≤50<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">AAA</span><br><span class="line">AAG</span><br><span class="line">AAAG    </span><br><span class="line">2</span><br><span class="line">A</span><br><span class="line">TG</span><br><span class="line">TGAATG</span><br><span class="line">4</span><br><span class="line">A</span><br><span class="line">G</span><br><span class="line">C</span><br><span class="line">T</span><br><span class="line">AGT</span><br><span class="line">0</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Case 1: 1</span><br><span class="line">Case 2: 4</span><br><span class="line">Case 3: -1</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>根据题目我们知道本题要求我们一条DNA链上对非致癌链进行修改的最小值</p>
<p>对于最优解问题或者求方案数问题的都可以使用动态规划来解决，本题又涉及到多字符串的匹配，所以还需要的ac自动机来维护。</p>
<p>动态规划集合划分<br>集合：dp[i][j]表示的以字符串i结尾的对应的自动机状态事j<br>属性：操作数最小<br>状态转移： f[i+1,trans[j,c]] = min(f[i][j], f[i,trans[j][c]])</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> tr[N][<span class="number">4</span>], idx;</span><br><span class="line"><span class="type">int</span> fail[N], dar[N], q[N];</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="string">&#x27;A&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="string">&#x27;G&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="string">&#x27;C&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">get</span>(str[i]);</span><br><span class="line">        <span class="keyword">if</span>(!tr[p][t])</span><br><span class="line">            tr[p][t] = ++ idx;</span><br><span class="line">        p = tr[p][t];</span><br><span class="line">    &#125;</span><br><span class="line">    dar[p] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>][i])</span><br><span class="line">            q[++ tt] = tr[<span class="number">0</span>][i];    <span class="comment">// 把所有的非空状态先入队</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];   <span class="comment">// 当前层的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> p = tr[t][i];</span><br><span class="line">            <span class="keyword">if</span>(p)</span><br><span class="line">            &#123;</span><br><span class="line">                fail[p] = tr[fail[t]][i];</span><br><span class="line">                q[++ tt] = p;</span><br><span class="line">                <span class="comment">// 如果他的某一个前缀子串的最大相同前后缀（fail[p])出现了另一个模式串匹配成功的状态</span></span><br><span class="line">                <span class="comment">// 说明当前这个状态就是匹配成功的状态</span></span><br><span class="line">                dar[p] |= dar[fail[p]]; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> tr[t][i] = tr[fail[t]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init </span></span><br><span class="line">        <span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="keyword">sizeof</span> tr);</span><br><span class="line">        <span class="built_in">memset</span>(dar, <span class="number">0</span>, <span class="keyword">sizeof</span> dar);</span><br><span class="line">        <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span> fail);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build the trie tree</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">            <span class="built_in">insert</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build the ac automaton</span></span><br><span class="line">        <span class="built_in">build</span>(); </span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= idx; j ++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k ++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 表示当前节点的花费，因为不一定在以（i+1)结尾的字符能和模式串匹配</span></span><br><span class="line">                    <span class="comment">//如果是前缀匹配那么转移就不需要操作（因为前面一定已经加上了贡献）</span></span><br><span class="line">                    <span class="type">int</span> t = <span class="built_in">get</span>(str[i + <span class="number">1</span>]) != k;   </span><br><span class="line">                    <span class="type">int</span> p = tr[j][k];   <span class="comment">// tr[j][k]表示当前状态通过k转移过来</span></span><br><span class="line">                    <span class="comment">// 朴素的版本就是一遍遍检查是否有当前字符串的子串能与模式串匹配的，能匹配就更新，不能匹配就不更新</span></span><br><span class="line">                    <span class="keyword">if</span>(!dar[p]) </span><br><span class="line">                        dp[i + <span class="number">1</span>][p] = <span class="built_in">min</span>(dp[i+<span class="number">1</span>][p], dp[i][j] + t);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="type">int</span> res = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx; i ++)</span><br><span class="line">            res = <span class="built_in">min</span>(res, dp[m][i]);</span><br><span class="line">        <span class="keyword">if</span>(res == INF) res = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>, T ++, res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HDU</category>
        <category>动态规划</category>
        <category>状态机模型</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态机模型</tag>
        <tag>ac自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-4857 逃生</title>
    <url>/2022/07/20/HDU-4857-%E9%80%83%E7%94%9F/</url>
    <content><![CDATA[<h2 id="HDU-4857-逃生"><a href="#HDU-4857-逃生" class="headerlink" title="HDU-4857 逃生"></a><a href="https://vjudge.net/problem/HDU-4857">HDU-4857 逃生</a></h2><p>糟糕的事情发生啦，现在大家都忙着逃命。但是逃命的通道很窄，大家只能排成一行。</p>
<p>现在有n个人，从1标号到n。同时有一些奇怪的约束条件，每个都形如：a必须在b之前。<br>同时，社会是不平等的，这些人有的穷有的富。1号最富，2号第二富，以此类推。有钱人就贿赂负责人，所以他们有一些好处。</p>
<p>负责人现在可以安排大家排队的顺序，由于收了好处，所以他要让1号尽量靠前，如果此时还有多种情况，就再让2号尽量靠前，如果还有多种情况，就让3号尽量靠前，以此类推。</p>
<p>那么你就要安排大家的顺序。我们保证一定有解。<br>Input<br>第一行一个整数T(1 &lt;= T &lt;= 5),表示测试数据的个数。<br>然后对于每个测试数据，第一行有两个整数n(1 &lt;= n &lt;= 30000)和m(1 &lt;= m &lt;= 100000)，分别表示人数和约束的个数。</p>
<p>然后m行，每行两个整数a和b，表示有一个约束a号必须在b号之前。a和b必然不同。<br>Output<br>对每个测试数据，输出一行排队的顺序，用空格隔开。</p>
<p>Sample<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5 10</span><br><span class="line">3 5</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">1 4</span><br><span class="line">2 3</span><br><span class="line">1 5</span><br><span class="line">3 5</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>要注意的是本题不是字典序问题，而是要让小的编号尽量靠前</strong>，字典序问题我们很清楚一般都是可以利用贪心来做，因为字典序每一步都需要要最小，每一步都是局部最优，最后必然是全局最优的。但是编号小的尽可能靠前则不同，应为到编号为i的前面数可以能是很大的值，只要将i排列到所有合法方案的最前面，才是编号小靠前问题，是不能使用贪心来求解的。<br><strong>但是我们知道小的值不一定在前面，但是大的值一定在后面</strong>,于是我们对于编号问题就需要使用逆向建图，使用大根堆进行维护，然后答案保存在vector，倒序输出<br><strong>字典序问题就使用小根堆进行维护，每一步都是局部最优</strong></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; <span class="built_in">assert</span>(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30010</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">top</span>();</span><br><span class="line">        ans.<span class="built_in">pb</span>(t);</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>( -- d[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">        ans.<span class="built_in">clear</span>();</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="built_in">add</span>(b,a);</span><br><span class="line">            d[a] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">topsort</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i --) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; ans[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>HDU</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
        <tag>类字典序问题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1081. Smallest Subsequence of Distinct Characters</title>
    <url>/2022/07/16/LeetCode-1081-Smallest-Subsequence-of-Distinct-Characters/</url>
    <content><![CDATA[<h2 id="LeetCode-1081-Smallest-Subsequence-of-Distinct-Characters"><a href="#LeetCode-1081-Smallest-Subsequence-of-Distinct-Characters" class="headerlink" title="LeetCode 1081. Smallest Subsequence of Distinct Characters"></a><a href="https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/">LeetCode 1081. Smallest Subsequence of Distinct Characters</a></h2><p>题目描述<br>返回字符串 text 中按字典序排列最小的子序列，该子序列包含 text 中所有不同字符一次。</p>
<p>样例<br>输入：<code>&quot;cdadabcc&quot;</code><br>输出：<code>&quot;adbc&quot;</code><br>输入：<code>&quot;abcd&quot;</code><br>输出：<code>&quot;abcd&quot;</code><br>输入：<code>&quot;ecbacba&quot;</code><br>输出：<code>&quot;eacb&quot;</code><br>输入：<code>&quot;leetcode&quot;</code><br>输出：<code>&quot;letcod&quot;</code><br>注意<br>1 &lt;= text.length &lt;= 1000<br>text 由小写英文字母组成。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>单调栈  + 贪心<br>要想字典序越小那么我们的第一个字符一定是越小越好，于是我们就需要维护的是一个单调递增的单调栈<br>入栈： </p>
<ol>
<li>（如果这个字符后面还会再出现） 要求这个字符不在栈中并且栈顶元素比他要更大</li>
<li>(如果这个字符在后面不会再出现）这个字符不在栈中（由于题目要求最后求的字符串每个字符都要出现）所以这个字符一定要入栈</li>
</ol>
<p>出栈： </p>
<ol>
<li>如果栈顶这个字符后面还会再出现，并且当前栈顶字符大于当前字符的话，那么栈顶字符出栈</li>
<li>反之栈顶在这个字符不会再出现，就不能出栈</li>
</ol>
<p>在这里我们用cnt来保存每个字符出现次数，然后再遍历原字符串的时候，每次字符出现cnt—，这里的cnt数组记录的是从这个字符往后的还会出现多少次，如果为0了那么往后就不会再出现了。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>,N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt[<span class="number">30</span>];    <span class="comment">// 记录每个字符出现的次数</span></span><br><span class="line"><span class="type">char</span> st[N];  <span class="comment">//   单调递增栈</span></span><br><span class="line"><span class="type">bool</span> sta[<span class="number">30</span>]; <span class="comment">// 记录字符是否在栈里面出现了</span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">    <span class="type">int</span> n = s.size();</span><br><span class="line">    <span class="comment">// 记录每个字符出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">        cnt[s[i]-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单调栈 + 贪心 处理 字典序问题</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>; st[<span class="number">0</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// &gt; 表示了单调递增，cnt[] &gt; 0 说明了后面这个元素至少还会出现一次</span></span><br><span class="line">        cnt[s[i] - <span class="string">&#x27;a&#x27;</span>] --; <span class="comment">//  每次字符出现一次就把他减去，表示的是从这个字符位置往后还有多少个</span></span><br><span class="line">        <span class="keyword">if</span>(sta[s[i] - <span class="string">&#x27;a&#x27;</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 出栈，更新栈顶指针与栈顶元素的状态</span></span><br><span class="line">        <span class="keyword">while</span>(hh &amp;&amp; st[hh] &gt; s[i] &amp;&amp; cnt[st[hh] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) sta[st[hh] - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">false</span>, hh --;<span class="comment">// 这里要注意hh的顺序是在后面的</span></span><br><span class="line">        st[++hh] = s[i];</span><br><span class="line">        sta[s[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= hh; i ++) <span class="built_in">cout</span> &lt;&lt; st[i];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 1201 Intervals</title>
    <url>/2022/07/22/POJ-1201-Intervals/</url>
    <content><![CDATA[<h2 id="POJ-1201-Intervals"><a href="#POJ-1201-Intervals" class="headerlink" title="POJ - 1201 Intervals"></a><a href="https://vjudge.net/problem/POJ-1201">POJ - 1201 Intervals</a></h2><p>You are given n closed, integer intervals [ai, bi] and n integers c1, …, cn.<br>Write a program that:<br>reads the number of intervals, their end points and integers c1, …, cn from the standard input,<br>computes the minimal size of a set Z of integers which has at least ci common elements with interval [ai, bi], for each i=1,2,…,n,<br>writes the answer to the standard output.<br>Input<br>The first line of the input contains an integer n (1 &lt;= n &lt;= 50000) — the number of intervals. The following n lines describe the intervals. The (i+1)-th line of the input contains three integers ai, bi and ci separated by single spaces and such that 0 &lt;= ai &lt;= bi &lt;= 50000 and 1 &lt;= ci &lt;= bi - ai+1.<br>Output<br>The output contains exactly one integer equal to the minimal size of set Z sharing at least ci elements with interval [ai, bi], for each i=1,2,…,n.</p>
<p>Sample<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 7 3</span><br><span class="line">8 10 3</span><br><span class="line">6 8 1</span><br><span class="line">1 3 1</span><br><span class="line">10 11 1</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>本题要我们去求的选取区间的中的元素个数最少。比如要求[1,6]至少选一个元素，[2,7]至少选一个元素，对于上面这个区间我们只需在其区间交集处选取元素，所以这个问题很有可能是一个<code>线段树问题 + 贪心</code>。<br>算法一<code>树状数组 + 贪心</code><br>（待补）</p>
<p>算法二 <code>差分约束</code><br>差分约束无非就是求解不等式系统问题，所以关键的是我们如果构造出不等式组。<br>在此借用前缀和数组的思想<code>s[i]</code>表示从1～i中选取<code>j</code>个元素<br>因为在这里我们需要求最小值，所以应该化成最长路问题<br>约束条件</p>
<ol>
<li><code>s[i] &gt;= s[i-1]</code></li>
<li><code>s[i] - s[i-1] &lt;= 1</code> -&gt; <code>s[i-1] &gt;= s[i] -1 1</code>(相隔一位的区间最多只能选一个或者不选)</li>
<li><code>s[b] - s[a] &gt;= c</code> -&gt; <code>s[b] &gt;= s[a] + c</code> （因为我们需要在这个区间中选取至少c个元素）</li>
<li>s[0]第0个元素之前没有元素可以选<br><strong>i的下标取值范围[1,50001]，差分约束这里的边要开到点数的三倍，有三个不等数组三组约束</strong><br>本题<br>构造完不等式组我们就可以建图(不会建图可以看这篇<a href="差分约束.md">差分约束</a>，计算最长路即可。</li>
</ol>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; <span class="built_in">assert</span>(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>, M = N * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N],e[M],w[M],ne[M], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> dist[N],q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[tt ++] = <span class="number">0</span>;</span><br><span class="line">    st[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="comment">// 最长路</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &lt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt ++] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀和数组从一开始（都加一）</span></span><br><span class="line">    <span class="comment">// 初始化 si &gt;= si-1 si-1 &gt;= si - 1</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50001</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(i,i<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">add</span>(i<span class="number">-1</span>, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// s[b] &gt;= s[a-1] + c</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        a ++, b ++;</span><br><span class="line">        <span class="built_in">add</span>(a<span class="number">-1</span>, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dist[<span class="number">50001</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>图论</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 1947 Rebuilding Roads</title>
    <url>/2022/08/06/POJ-1947-Rebuilding-Roads/</url>
    <content><![CDATA[<h2 id="POJ-1947-Rebuilding-Roads"><a href="#POJ-1947-Rebuilding-Roads" class="headerlink" title="POJ - 1947 Rebuilding Roads"></a><a href="https://vjudge.net/problem/POJ-1947#author=0">POJ - 1947 Rebuilding Roads</a></h2><p>The cows have reconstructed Farmer John’s farm, with its N barns (1 &lt;= N &lt;= 150, number 1..N) after the terrible earthquake last May. The cows didn’t have time to rebuild any extra roads, so now there is exactly one way to get from any given barn to any other barn. Thus, the farm transportation system can be represented as a tree.</p>
<p>Farmer John wants to know how much damage another earthquake could do. He wants to know the minimum number of roads whose destruction would isolate a subtree of exactly P (1 &lt;= P &lt;= N) barns from the rest of the barns.</p>
<p><strong>Input</strong></p>
<ul>
<li><p>Line 1: Two integers, N and P</p>
</li>
<li><p>Lines 2..N: N-1 lines, each with two integers I and J. Node I is node J’s parent in the tree of roads.</p>
</li>
</ul>
<p><strong>Output</strong><br>A single line containing the integer that is the minimum number of roads that need to be destroyed for a subtree of P nodes to be isolated.</p>
<p>Sample<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11 6</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">2 6</span><br><span class="line">2 7</span><br><span class="line">2 8</span><br><span class="line">4 9</span><br><span class="line">4 10</span><br><span class="line">4 11</span><br></pre></td></tr></table></figure></p>
<p>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>大意：一颗n个节点树要我们剪最少的边最后得到一颗m个节点的树，求剪的最少的边数</p>
<p>树形dp<br>重要的是如何对集合的划分<br>在这里就相当一颗以u为根节点的数的，以他的孩子为根就相当于每一组分组，从每一个种选择某一种方案组成的最优方案<br>属性：剪的最少边数<br>集合：dp[i][j] 以i位根的树保留j个节点需要的剪的最少边数<br>状态转移：dp[u][j] = min(dp[u][j],dp[u][j - k] + dp[v][k]);</p>
<p>但本题有几个细节</p>
<ol>
<li>最优解不一定是通过的根节点决定</li>
<li>树上背包要是通过子节点来更新，那么一定要保留父节点到子节点之间的边</li>
</ol>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">155</span>, M = N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> son[N],dp[N][N];    <span class="comment">// son[i]表示一个节点的子节点有多少个</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的是以u为根节点的树的节点总数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只保留一个节点的话那么就把以u为根的节点到其所有的子节点的边都删掉</span></span><br><span class="line">    dp[u][<span class="number">1</span>] = son[u];</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        sum += <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = sum; j &gt;= <span class="number">0</span>; j --)  </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= j; k ++)    <span class="comment">// 表子树保留k个节点的</span></span><br><span class="line">                dp[u][j] = <span class="built_in">min</span>(dp[u][j],dp[v][k] + dp[u][j-k] - <span class="number">1</span>); <span class="comment">// 要是用v来更新父节点的话，u-&gt;v之间的边是不能删去的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        son[a] ++;</span><br><span class="line">        st[b] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(st[root]) root ++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = dp[root][m];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可能在子树上(也就是如果我们剪一刀就剪出来一颗子树为m个节点那么很显然答案就是“1”)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">if</span>(dp[i][m] &lt; res)</span><br><span class="line">            res = dp[i][m] + <span class="number">1</span>; <span class="comment">// 要加一因为一刀就切出来m个节点的树那么这一刀是切在这颗子树的根节点上面</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>POJ</category>
        <category>动态规划</category>
        <category>树形dp</category>
        <category>树上背包</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 2528 Mayor&#39;s posters</title>
    <url>/2022/07/27/POJ-2528-Mayor-s-posters/</url>
    <content><![CDATA[<h2 id="POJ-2528-Mayor’s-posters"><a href="#POJ-2528-Mayor’s-posters" class="headerlink" title="POJ - 2528 Mayor’s posters"></a><a href="https://vjudge.net/problem/POJ-2528">POJ - 2528 Mayor’s posters</a></h2><p>The citizens of Bytetown, AB, could not stand that the candidates in the mayoral election campaign have been placing their electoral posters at all places at their whim. The city council has finally decided to build an electoral wall for placing the posters and introduce the following rules:<br>Every candidate can place exactly one poster on the wall.<br>All posters are of the same height equal to the height of the wall; the width of a poster can be any integer number of bytes (byte is the unit of length in Bytetown).<br>The wall is divided into segments and the width of each segment is one byte.<br>Each poster must completely cover a contiguous number of wall segments.</p>
<p>They have built a wall 10000000 bytes long (such that there is enough place for all candidates). When the electoral campaign was restarted, the candidates were placing their posters on the wall and their posters differed widely in width. Moreover, the candidates started placing their posters on wall segments already occupied by other posters. Everyone in Bytetown was curious whose posters will be visible (entirely or in part) on the last day before elections.<br>Your task is to find the number of visible posters when all the posters are placed given the information about posters’ size, their place and order of placement on the electoral wall.<br>Input<br>The first line of input contains a number c giving the number of cases that follow. The first line of data for a single case contains number 1 &lt;= n &lt;= 10000. The subsequent n lines describe the posters in the order in which they were placed. The i-th line among the n lines contains two integer numbers li and ri which are the number of the wall segment occupied by the left end and the right end of the i-th poster, respectively. We know that for each 1 &lt;= i &lt;= n, 1 &lt;= li &lt;= ri &lt;= 10000000. After the i-th poster is placed, it entirely covers all wall segments numbered li, li+1 ,… , ri.<br>Output<br>For each input data set print the number of visible posters after all the posters are placed.</p>
<p>The picture below illustrates the case of the sample input.<br><img src="https://vj.csgrandeur.cn/85d8df2191db8df82ba259ebe2bfe93e?v=1658733874" alt="例图"></p>
<p>Sample<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">1 4</span><br><span class="line">2 6</span><br><span class="line">8 10</span><br><span class="line">3 4</span><br><span class="line">7 10</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目要我们求出现完整的没有完全被挡住的海报的个数<br>每次出现一张海报我们都要在该位置坐标上记录其出现次数，用次数来维护没有被完整挡住的海报个数。<br>分类讨论是否仅使用cnt就能维护<br>区间覆盖问题<br>思路一：<br>如果区间被包含的话，那么如果这个区间先被贴上海报的话，那么这个区间就是被覆盖，这样我们就可以知道，前面的区间是会被后面的区间所影响，但是后面的出现的区间却不会被前面的区间影响。所以在计算答案的时候考虑从后面区间往前面区间开始计算。<br>思路二：<br>染色<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> co;</span><br><span class="line">    <span class="type">int</span> tag;    <span class="comment">// tag = 0表示这个区间没有被染色, tag = 1表示这个区间被染色且这个区间是相同颜色, tag = 2表示这个区间被染色但是染色的颜色不是同一种颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> co; <span class="comment">// 表示在区间单色的情况下被染上的颜色</span></span><br><span class="line">    <span class="comment">// 懒标记</span></span><br><span class="line">    <span class="comment">//int tag; // tag = 0表示没有被染色 1表示区间染色的情况是单色, 2表示的是多色</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 表示当前区间被染上的颜色</span></span><br><span class="line">&#125;tr[N * <span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> color[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vx;</span><br><span class="line">PII pos[N];</span><br><span class="line"><span class="type">int</span> n,res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// void pushup(int u) pushup操作比较麻烦（因为设计到判断这个节点是单色还是多色的问题），所以不如去根节点去找不同的染色情况</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(vx.<span class="built_in">begin</span>(),vx.<span class="built_in">end</span>(),x) - vx.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 涉及到懒标记下放的时候这时候区间一定是单色情况</span></span><br><span class="line">    <span class="comment">// 假设不是单色情况，但是懒标记没下放。显然是矛盾的，因为要想不是单色其子区间一定有不同颜色，一定会先涉及到区间修改</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].val)</span><br><span class="line">    &#123;</span><br><span class="line">        node &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], &amp;root = tr[u];</span><br><span class="line">        left.co = root.val;</span><br><span class="line">        right.co = root.val;</span><br><span class="line">        left.val = root.val;</span><br><span class="line">        right.val = root.val;</span><br><span class="line">        root.val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r;</span><br><span class="line">        tr[u].co = <span class="number">0</span>, tr[u].val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r;</span><br><span class="line">        tr[u].co = <span class="number">0</span>, tr[u].val = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l ,<span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].val = d;</span><br><span class="line">        tr[u].co = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == tr[u].r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[tr[u].co] &amp;&amp; tr[u].co)</span><br><span class="line">        &#123;</span><br><span class="line">            color[tr[u].co] = <span class="literal">true</span>;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid =  tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        vx.<span class="built_in">clear</span>();</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="keyword">sizeof</span> color);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            pos[i] = <span class="built_in">mp</span>(a,b);</span><br><span class="line">            vx.<span class="built_in">pb</span>(a<span class="number">-1</span>),vx.<span class="built_in">pb</span>(a),vx.<span class="built_in">pb</span>(b),vx.<span class="built_in">pb</span>(b+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(vx));</span><br><span class="line">        vx.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(vx)),vx.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 本题没有和其他点一样，一个点表示的一个区间，映射下表表示的是单点</span></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,vx.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="built_in">find</span>(pos[i].fi), <span class="built_in">find</span>(pos[i].se), i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, vx.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 3342 Party at Hali-Bula</title>
    <url>/2022/08/03/POJ-3342-Party-at-Hali-Bula/</url>
    <content><![CDATA[<h2 id="POJ-3342-Party-at-Hali-Bula"><a href="#POJ-3342-Party-at-Hali-Bula" class="headerlink" title="POJ - 3342 Party at Hali-Bula"></a><a href="https://vjudge.net/problem/POJ-3342">POJ - 3342 Party at Hali-Bula</a></h2><p>Dear Contestant,</p>
<p>I’m going to have a party at my villa at Hali-Bula to celebrate my retirement from BCM. I wish I could invite all my co-workers, but imagine how an employee can enjoy a party when he finds his boss among the guests! So, I decide not to invite both an employee and his/her boss. The organizational hierarchy at BCM is such that nobody has more than one boss, and there is one and only one employee with no boss at all (the Big Boss)! Can I ask you to please write a program to determine the maximum number of guests so that no employee is invited when his/her boss is invited too? I’ve attached the list of employees and the organizational hierarchy of BCM.</p>
<p>Best,<br>—Brian Bennett</p>
<p>P.S. I would be very grateful if your program can indicate whether the list of people is uniquely determined if I choose to invite the maximum number of guests with that condition.</p>
<p>Input<br>The input consists of multiple test cases. Each test case is started with a line containing an integer n (1 ≤ n ≤ 200), the number of BCM employees. The next line contains the name of the Big Boss only. Each of the following n-1 lines contains the name of an employee together with the name of his/her boss. All names are strings of at least one and at most 100 letters and are separated by blanks. The last line of each test case contains a single 0.</p>
<p>Output<br>For each test case, write a single line containing a number indicating the maximum number of guests that can be invited according to the required condition, and a word Yes or No, depending on whether the list of guests is unique in that case.</p>
<p>Sample<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">Jason</span><br><span class="line">Jack Jason</span><br><span class="line">Joe Jack</span><br><span class="line">Jill Jason</span><br><span class="line">John Jack</span><br><span class="line">Jim Jill</span><br><span class="line">2</span><br><span class="line">Ming</span><br><span class="line">Cho Ming</span><br><span class="line">0</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 Yes</span><br><span class="line">1 No</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>最大独立集唯一性</strong><br>状态转移方程：<br>// 不选i<br>dp[i][0] += max(dp[j][1],dp[j][0]);<br>// 选<br>dp[i][1] += dp[j][0];</p>
<p>前提： 假设是以i为根的树， j是i的子节点</p>
<ol>
<li>显然如果以i位根的树dp[i][0] == dp[i][1]这种情况下，最大独立集不唯一。但是要注意不唯一情况下是有可能出现dp[i][0] != dp[i][1]</li>
<li>如果dp[j][0] == dp[j][1],并且如果max(dp[i][0],dp[i][1]) == dp[i]<a href="也就是说最大独立集通过子树j的最大独立集转移过来所以">0</a>，这个情况下最后的最大独立集一定不唯一<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(dp[j][0] == dp[j][1])</span><br><span class="line">     judge[i][0] = true;</span><br></pre></td></tr></table></figure></li>
<li>如果子节点不选的时候不唯一的情况下，那么当前节点选上了那么整个树也一定不唯一 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(judge[j][0])</span><br><span class="line">    judge[i][1] = true;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>本题要注意的是，在寻找唯一性不能对仅对数组dp检查，因为dp内保存的仅是所有方案中有一中最优方案</strong></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N],idx;</span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> judge[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,res;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; peo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    dp[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[u][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    judge[u][<span class="number">0</span>] = judge[u][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断唯一性（如果子树都不唯一了那么最后最大独立集一定也不唯一）</span></span><br><span class="line">        <span class="comment">// 更新judge数组</span></span><br><span class="line">        <span class="comment">// 当前节点不选的情况下，如果子节点最大独立集不唯一的话，那么总方案一定不唯一</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[j][<span class="number">0</span>] == dp[j][<span class="number">1</span>])</span><br><span class="line">            judge[u][<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 当子节点不选的情况下最大独立集不唯一的，总的最大独立集也不唯一</span></span><br><span class="line">        <span class="keyword">if</span>(!judge[j][<span class="number">0</span>])</span><br><span class="line">            judge[u][<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新dp数组</span></span><br><span class="line">        dp[u][<span class="number">0</span>] += <span class="built_in">max</span>(dp[j][<span class="number">0</span>], dp[j][<span class="number">1</span>]);</span><br><span class="line">        dp[u][<span class="number">1</span>] += dp[j][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init()</span></span><br><span class="line">        peo.<span class="built_in">clear</span>();</span><br><span class="line">        res = <span class="number">0</span>,idx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// big boss(root)</span></span><br><span class="line">        string a,b;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        peo[a] = num ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span>(!peo[a])</span><br><span class="line">                peo[a] = num ++;</span><br><span class="line">            <span class="keyword">if</span>(!peo[b])</span><br><span class="line">                peo[b] = num ++;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">add</span>(peo[b],peo[a]);</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">1</span>][<span class="number">0</span>] &gt; dp[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; judge[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d Yes\n&quot;</span>,dp[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dp[<span class="number">1</span>][<span class="number">0</span>] &lt; dp[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; judge[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d Yes\n&quot;</span>, dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d No\n&quot;</span>,<span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>POJ</category>
        <category>树形dp</category>
        <category>最大独立集唯一性</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
        <tag>最大独立集</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1789 卡车历史</title>
    <url>/2022/07/14/POJ1789%E5%8D%A1%E8%BD%A6%E5%8E%86%E5%8F%B2/</url>
    <content><![CDATA[<h2 id="卡车历史"><a href="#卡车历史" class="headerlink" title="卡车历史"></a><a href="https://www.acwing.com/problem/content/4335/">卡车历史</a></h2><p>有 N 个点，每个点用一个长度为 7 的由小写字母构成的字符串表示。<br>不同点对应的字符串不同。<br>对于任意两点，它们对应的字符串在多少个位置上字母不同，则它们之间的距离就是多少。<br>例如，aaaa 和 baba 在第 1,3 个位置上字母不同，则它们之间的距离为 2。<br>现在，要将这 N 个点用边连接，组成一个树，要求组成树的所有边长之和尽可能小。<br>请你计算并输出最小边长和。</p>
<p>输入格式<br>输入包含多组测试数据。<br>每组数据第一行包含整数 N。<br>接下来 N 行，每行包含一个长度为 7 的由小写字母构成的字符串，表示一个点。<br>当输入 N=0 时，表示输入结束。</p>
<p>输出格式<br>输出一行，格式为 The highest possible quality is 1/Q.，其中 Q 为最小边长和。</p>
<p>数据范围<br>每组输入最多包含 10 组数据。<br>2≤N≤2000,<br>每个输入的所有 N 之和不超过 2000。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">aaaaaaa</span><br><span class="line">baaaaaa</span><br><span class="line">abaaaaa</span><br><span class="line">aabaaaa</span><br><span class="line">0</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The highest possible quality is 1/3.</span><br></pre></td></tr></table></figure></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>本题难点在于看出这是一个最小生成树问题，并对本题进行建图</strong><br>本题要求的是最小变换次数，一次只能改变一个位置的字符串<br>分析样例<br>aaaaaaa </p>
<ul>
<li>与 baaaaaa 只需变换第一位a变为b，一次变换</li>
<li>与 abaaaaa 只需变换第二位a变为b，一次变换</li>
<li>与 aabaaaa 只需变换第三位a变为b，一次变换</li>
</ul>
<p>baaaaaa</p>
<ul>
<li>abaaaaa 变换第一位b变为a，第二位a变为b，两次变换</li>
<li>aabaaaa 变换第一位b变为a，变换第三a变为b，两次变换</li>
</ul>
<p>abaaaaa</p>
<ul>
<li>aabaaaa 第二位b变为a，第三位a变为b，两次变换</li>
</ul>
<p>比如 aaaaaaa变换到baaaaaa  相当于aaaaaaa这个节点与baaaaaa连一条边，这个边的边权等于它们之间变换的次数<br>这样子就可以建立起一张完全图。要想所有的节点都变为相同的字符串，那么必然需要将其所有节点连通，并且最后一定是生成一棵树。</p>
<p>证明： 为什么一定会生成一棵树呢？？因为我们的所有边权都是正值，一定是没有负权边的，所以一共n个节点，其连通为连通图的最小边数为n-1条边就是一颗树的情况，每多加一条边，那么权值之和一定会增加。所以我们就将上面问题转换为一个最小生成树问题。</p>
<p>完全图：边数m = n*(n-1),所以在这里使用Prim算法会更优</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> mp[N][N];</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">char</span> s[N][<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">build</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">7</span>; k ++)</span><br><span class="line">                <span class="keyword">if</span>(s[i][k] != s[j][k]) cnt ++;</span><br><span class="line">            mp[i][j] = mp[j][i] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">prim</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dis[j] &lt; dis[t])) t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; dis[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i) res += dis[t];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) dis[j] = min(dis[j],mp[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(mp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> mp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j ++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; s[i][j];</span><br><span class="line"></span><br><span class="line">        build();</span><br><span class="line">        <span class="type">int</span> ans = prim();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The highest possible quality is 1/&quot;</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>The 2021 CCPC Guilin Onsite I. PTSD</title>
    <url>/2022/07/15/The-2021-CCPC-Guilin-Onsite-I-PTSD/</url>
    <content><![CDATA[<h2 id="The-2021-CCPC-Guilin-Onsite-I-PTSD"><a href="#The-2021-CCPC-Guilin-Onsite-I-PTSD" class="headerlink" title="The 2021 CCPC Guilin Onsite I. PTSD"></a><a href="https://vjudge.net/problem/Gym-103409I#author=sunhaoyu">The 2021 CCPC Guilin Onsite I. PTSD</a></h2><p>有n个战士，编号为1~n，第i个战士的武力值为i，现在需要把n个战士分为若干组，每个战士都必须属于某个组，每个组都至少有一个战士，有一些战士会生一种怪病，就是当他所在的组有且仅有一名战士的武力值比他高时他就会难过qaq，然后现在你需要给这些战士分组，使得患病并难过的战士的武力值之和最大。<br>样例输入<br>有多组样例，第一行输入样例组数T，对于每一组样例：<br>第一行是一个整数 n [1,1e6],表明战士的数量</p>
<p>第二行是一个长度为n的01串，第i个位置为’0’表示第i个战士没有患病，第i个位置为’1’表示第i个战士患病，保证所有样例的n之和不超过1e6</p>
<p>样例输出<br>对于每一组样例，输出一行包含一个整数表示患病并难过的战士的武力值之和的最大值</p>
<p>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">10101</span><br><span class="line">8</span><br><span class="line">11111111</span><br><span class="line">4</span><br><span class="line">1100</span><br><span class="line">4</span><br><span class="line">0110</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">16</span><br><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure><br>Note<br>对于第一组样例，一个有效的分组方法是 [1, 2], [3, 4], [5],它使得第一个战士和第三个战士难过， [1, 2], [3, 5], [4] 也可以</p>
<p>对于第二组样例，一个有效的分组方法是 [1, 2], [3, 4], [5, 6], [7, 8].<br>对于第三组样例，一个有效的分组方法是[1, 3], [2, 4].<br>对于第四组样例，一个有效的分组方法是[1, 2, 3, 4].</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>等价于两两匹配。因为我们需要尽可能的组成更多的组，因为一组只能加一个权值，所以我们要组数越多那么组内的数据就要越小。<br>而且这里的匹配一定是大的数和大的数匹配，因为大的数和小的数匹配，这样最后的到匹配权值之和是&lt;=我们大的数和大的数匹配的（因为权值是加小的数）1111101<br>如果较小的为 PTSD 则对答案有贡献.<br>从大到小枚举每个数, 维护一个初值为 0 的计数器, 如果它是PTSD 且计数器大于 0, 说明有更大的数还未匹配, 那么统计进答案且计数器 −1. 否则计数器 +1. 可以发现这样答案是最优的. 复杂度 O(n)<br><strong>同时要注意这里的答案是有可能爆int的，1+…+1e6 = 1e12的级别</strong></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;    <span class="comment">// 计数器表示有没有比当前数更大的值(这个值有可能是0也有可能是1）没有与&#x27;1&#x27;匹配</span></span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt) res += i,cnt--;</span><br><span class="line">                <span class="keyword">else</span> cnt++;<span class="comment">//比他大的数都匹配完了，那么这个&#x27;1&#x27;就要下一步与别人匹配1110这个序列前两个要相互匹配</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>思维题</category>
      </categories>
      <tags>
        <tag>思维题</tag>
        <tag>构造</tag>
        <tag>CCPC</tag>
        <tag>代码能力</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC - 624 整数划分</title>
    <url>/2022/09/01/UESTC-624-%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<h2 id="UESTC-624-整数划分"><a href="#UESTC-624-整数划分" class="headerlink" title="UESTC - 624 整数划分"></a><a href="https://vjudge.net/problem/UESTC-624#author=0">UESTC - 624 整数划分</a></h2><p>一个整数可以写成多个整数相加的形式，比如44可以写成以下形式</p>
<p>4=4</p>
<p>4=3+1</p>
<p>4=2+2</p>
<p>4=2+1+1</p>
<p>4=1+1+1+1</p>
<p>注意 4=3+1和 4=1+3是一样的，现在多加一个要求，即等式右边的数不能相同，比如对于4来说，后面3种划分方式是不符合要求的，现在给定一个N，问有多少种划分方法，答案 mod 19901014</p>
<p>Input<br>第一行有个整数T，代表数据组数（T &lt;= 10000）</p>
<p>接下来有TT行，每行有个整数NN (1 ≤ N ≤ 1000)</p>
<p>Output<br>输出T行，每行输出一个整数，代表N的划分数 mod 19901014</p>
<p>Sample 1<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">10</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="算法一-类01背包计数类dp"><a href="#算法一-类01背包计数类dp" class="headerlink" title="算法一 类01背包计数类dp"></a>算法一 类01背包<code>计数类dp</code></h3><ul>
<li>错误的划分方法 dp[i][j] 表示整数i的划分的若干整数之和等于j<br>dp[i][j] = dp[i-1][j] + dp[i][j-i]， 这样子的求出来显然是会有相同数在方案里。<br>正确的划分方法 dp[i][j] 表示整数i划分的若干整数中最大值不超过j<br><strong>i &gt;= j时候</strong>   dp[i][j] = dp[i-j][j-1] + dp[i][j-1] (当前划分最大值选j， 当下划分最大值不选j)</li>
</ul>
<p>但是dp的做法最后的时间复杂度为 1000 <em> 1000 </em> 10000 (n <em> n </em> T)</p>
<h3 id="算法二-生成函数"><a href="#算法二-生成函数" class="headerlink" title="算法二 生成函数"></a>算法二 生成函数</h3><p><strong>普通的生成函数</strong>定义了对于有限数列{ai},定义其生成函数为∑ ai * x^i<br>举个例子对于数列为{2,4,6}的生成函数为 2 + 4x + 6x^2</p>
<p>在本题我们要求出来一个整数划分成不同的正整数，也就是说一个整数n划分，可以从1～n中每个数做选或不选即0/1，所以数列为{0,1,0,1…},每个数的数值作为次数<br>生成函数为：<br>g(x) = (1 + x)（1 + x^2)…(1 + x^n)<br>最后展开生成函数就知道划分成整数k的方案数就为生成函数k次项的系数</p>
<p><a href="https://zhuanlan.zhihu.com/p/106522599">生成函数</a></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><h4 id="计数类dp"><a href="#计数类dp" class="headerlink" title="计数类dp"></a>计数类dp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">19901014</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[N][N];  <span class="comment">// dp[i][j]表示 整数i划分成若干正整数最大值不超过j的情况下合法划分方案数</span></span><br><span class="line"><span class="type">int</span> T, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init 多组测试数据需要初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; N; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前的整数i划分最大值不超过j，情况可以分成两类严格不超过j， 非严格不超过j（也就是选j和不选j的情况）</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt;= i) dp[i][j] = (dp[i][j<span class="number">-1</span>] + dp[i-j][j<span class="number">-1</span>]) % mod;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = dp[i][i];</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; dp[n][n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">19901014</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];   <span class="comment">// f[k]:  表示k次项的系数 </span></span><br><span class="line"><span class="type">int</span> a[N], b[N]; <span class="comment">// 在多项式乘法的时候每次都是两个括号进行多项式乘法，a[i]：表示次数为i的系数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Poly</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N - i; j += k)</span><br><span class="line">            f[i + j] += (ll)(a[i] * b[j]) % mod;    <span class="comment">// 可能在乘法这里overflow所以先强制类型转化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>, a[<span class="number">1</span>] = <span class="number">1</span>;     <span class="comment">// 第一个括号(1 + x)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span> b);</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">1</span>, b[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">Poly</span>(i);</span><br><span class="line">        <span class="built_in">memcpy</span>(a,f,<span class="keyword">sizeof</span> f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UESTC</category>
        <category>数论</category>
        <category>生成函数</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA - 11795 Mega Man&#39;s Mission</title>
    <url>/2022/08/05/UVA-11795-Mega-Man-s-Mission/</url>
    <content><![CDATA[<h2 id="UVA-11795-Mega-Man’s-Mission"><a href="#UVA-11795-Mega-Man’s-Mission" class="headerlink" title="UVA - 11795 Mega Man’s Mission"></a><a href="https://vjudge.net/problem/UVA-11795">UVA - 11795 Mega Man’s Mission</a></h2><p>Mega Man is off to save the world again. His objective is to kill the Robots created by Dr. Wily whose motive is to<br>conquer the world. In each mission, he will try to destroy a particular Robot. Initially, Mega Man is equipped with a weapon, called the “Mega Buster” which can be used to destroy the Robots. Unfortunately, it may happen that his weapon is not capable of taking down every Robot. However,to his fortune, he is capable of using the weapons from Robots which he has completely destroyed and these weapons maybe able to take down Robots which he otherwise cannot with his own weapon. Note that, each of these enemy Robots carry exactly one weapon themselves for fighting Mega Man. He is able to take down the Robots in any order as long as he has at least one weapon capable of destroying the Robot at a particular mission. In this problem, given the information about the Robots and their weapons, you will have to determine the number of ways Mega Man can complete his objective of destroying all the Robots.</p>
<p><strong>Input</strong><br>Input starts with an integer T (T ≤ 50), the number of test cases.<br>Each test case starts with an integer N (1 ≤ N ≤ 16). Here N denotes the number of Robots to be<br>destroyed (each Robot is numbered from 1 to N). This line is followed by N + 1 lines, each containing<br>N characters. Each character will either be ‘1’ or ‘0’. These lines represent a (N + 1) × N matrix. The<br>rows are numbered from 0 to N while the columns are numbered from 1 to N. Row 0 represents the<br>information about the “Mega Buster”. The j-th character of Row 0 will be ‘1’ if the “Mega Buster”<br>can destroy the j-th Robot. For the remaining N rows, the j-th character of i-th row will be ‘1’ if<br>the weapon of i-th Robot can destroy the j-th Robot. Note that, a Robot’s weapon could be used to<br>destroy the Robot itself, but this will have no impact as the Robot must be destroyed anyway for its<br>weapon to be acquired.</p>
<p><strong>Output</strong><br>For each case of input, there will be one line of output. It will first contain the case number followed<br>by the number of ways Mega Man can complete his objective. Look at the sample output for exact<br>format.</p>
<p>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">11</span><br><span class="line">01</span><br><span class="line">10</span><br><span class="line">3</span><br><span class="line">110</span><br><span class="line">011</span><br><span class="line">100</span><br><span class="line">000</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Case 1: 1</span><br><span class="line">Case 2: 2</span><br><span class="line">Case 3: 3</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目要我们求杀光所有机器人的总方案数<br>我们有一个初始武器可以kill某几个机器人，然后用我们杀死的机器武器再kill别的机器人。</p>
<p>机器人的数目很少，所以可以考虑用二进制形式的状态压缩来枚举所有的状态</p>
<p>正常的状态压缩步骤</p>
<ol>
<li>预处理所有的合法状态</li>
<li>预处理我们的当前的状态可以从什么状态转移过来</li>
<li>dp</li>
</ol>
<p><strong>本题的预处理技巧值得关注</strong></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1</span> &lt;&lt; N]; <span class="comment">// dp[i]表示当前i状态下的所有方案</span></span><br><span class="line"><span class="type">int</span> head[<span class="number">1</span> &lt;&lt; N];   <span class="comment">// 预处理当前方案可以杀掉的机器人</span></span><br><span class="line"><span class="type">int</span> kill[<span class="number">1</span> &lt;&lt; N];    <span class="comment">// kill[i]表示的i号机器人可以kill的机器人</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="type">int</span> step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init()</span></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">        <span class="built_in">memset</span>(kill,<span class="number">0</span>,<span class="keyword">sizeof</span> kill);</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="comment">// 预处理每一个机器人能kill的其他机器人</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            string s;</span><br><span class="line">            cin &gt;&gt; s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    kill[i] |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理每一种状态下能kill的机器人</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> st = <span class="number">0</span>; st &lt; (<span class="number">1</span> &lt;&lt; n); st ++)</span><br><span class="line">        &#123;</span><br><span class="line">            head[st] = kill[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 从a0～an-1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 当前状态下这一位是1的话，1这个位置对应的机器人能kill的加到st能kill的里面</span></span><br><span class="line">                <span class="keyword">if</span>(st &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">                &#123;</span><br><span class="line">                    head[st] |= kill[i + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>]= <span class="number">1</span>;  <span class="comment">// 所有的机器人都不被杀掉只有一种方案什么都不选</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> st = <span class="number">1</span>; st &lt; (<span class="number">1</span> &lt;&lt; n); st ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从当前状态移除一个1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n<span class="number">-1</span>; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(st &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 移去一个1并判断边界</span></span><br><span class="line">                    <span class="comment">// 判断上一个状态是否可以转移过来当前状态(也就是判断上一个状态是否可以kill我们一去的机器人)</span></span><br><span class="line">                    <span class="keyword">if</span>(head[st^(<span class="number">1</span> &lt;&lt; i)] &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">                        dp[st] += dp[st^(<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %lld\n&quot;</span>,step ++, dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVA</category>
        <category>动态规划</category>
        <category>状态压缩</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>ac自动机</title>
    <url>/2022/08/08/ac%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<p>本文章来自<a href="https://oi-wiki.org/string/ac-automaton/">OI WIKI</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>AC 自动机是 <strong>以 Trie 的结构为基础</strong>，结合 <strong>KMP 的思想</strong> 建立的。</p>
<p>简单来说，建立一个 AC 自动机有两个步骤：</p>
<ol>
<li>基础的 Trie 结构：将所有的模式串构成一棵 Trie。</li>
<li>KMP 的思想：对 Trie 树上所有的结点构造失配指针。</li>
</ol>
<p>然后就可以利用它进行多模式匹配了。</p>
<h2 id="字典树构建"><a href="#字典树构建" class="headerlink" title="字典树构建"></a>字典树构建</h2><p>AC 自动机在初始时会将若干个模式串丢到一个 Trie 里，然后在 Trie 上建立 AC 自动机。这个 Trie 就是普通的 Trie，该怎么建怎么建。</p>
<p>这里需要仔细解释一下 Trie 的结点的含义，尽管这很小儿科，但在之后的理解中极其重要。Trie 中的结点表示的是某个模式串的前缀。我们在后文也将其称作状态。一个结点表示一个状态，Trie 的边就是状态的转移。</p>
<p>形式化地说，对于若干个模式串 $s_1,s_2\dots s_n$，将它们构建一棵字典树后的所有状态的集合记作 $Q$。</p>
<h2 id="失配指针"><a href="#失配指针" class="headerlink" title="失配指针"></a>失配指针</h2><p>AC 自动机利用一个 fail 指针来辅助多模式串的匹配。</p>
<p>状态 $u$ 的 fail 指针指向另一个状态 $v$，其中 $v\in Q$，且 $v$ 是 $u$ 的最长后缀（即在若干个后缀状态中取最长的一个作为 fail 指针）。对于学过 KMP 的朋友，我在这里简单对比一下这里的 fail 指针与 KMP 中的 next 指针：</p>
<ol>
<li>共同点：两者同样是在失配的时候用于跳转的指针。</li>
<li>不同点：next 指针求的是最长 Border（即最长的相同前后缀），而 fail 指针指向所有模式串的前缀中匹配当前状态的最长后缀。</li>
</ol>
<p>因为 KMP 只对一个模式串做匹配，而 AC 自动机要对多个模式串做匹配。有可能 fail 指针指向的结点对应着另一个模式串，两者前缀不同。</p>
<p>没看懂上面的对比不要急（也许我的脑回路和泥萌不一样是吧），你只需要知道，AC 自动机的失配指针指向当前状态的最长后缀状态即可。</p>
<p>AC 自动机在做匹配时，同一位上可匹配多个模式串。</p>
<h3 id="构建指针"><a href="#构建指针" class="headerlink" title="构建指针"></a>构建指针</h3><p>下面介绍构建 fail 指针的 <strong>基础思想</strong>：（强调！基础思想！基础！）</p>
<p>构建 fail 指针，可以参考 KMP 中构造 Next 指针的思想。</p>
<p>考虑字典树中当前的结点 $u$，$u$ 的父结点是 $p$，$p$ 通过字符 <code>c</code> 的边指向 $u$，即 $trie[p,c]=u$。假设深度小于 $u$ 的所有结点的 fail 指针都已求得。</p>
<ol>
<li>如果 $\text{trie}[\text{fail}[p],c]$ 存在：则让 u 的 fail 指针指向 $\text{trie}[\text{fail}[p],c]$。相当于在 $p$ 和 $\text{fail}[p]$ 后面加一个字符 <code>c</code>，分别对应 $u$ 和 $fail[u]$。</li>
<li>如果 $\text{trie}[\text{fail}[p],c]$ 不存在：那么我们继续找到 $\text{trie}[\text{fail}[\text{fail}[p]],c]$。重复 1 的判断过程，一直跳 fail 指针直到根结点。</li>
<li>如果真的没有，就让 fail 指针指向根结点。</li>
</ol>
<p>如此即完成了 $\text{fail}[u]$ 的构建。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面放一张 GIF 帮助大家理解。对字符串 <code>i</code>  <code>he</code>  <code>his</code>  <code>she</code>  <code>hers</code> 组成的字典树构建 fail 指针：</p>
<ol>
<li>黄色结点：当前的结点 $u$。</li>
<li>绿色结点：表示已经 BFS 遍历完毕的结点，</li>
<li>橙色的边：fail 指针。</li>
<li>红色的边：当前求出的 fail 指针。</li>
</ol>
<p><img src="https://oi-wiki.org/string/images/ac-automaton1.gif" alt="AC_automation_gif_b_3.gif"></p>
<p>我们重点分析结点 6 的 fail 指针构建：</p>
<p><img src="https://oi-wiki.org/string/images/ac-automaton1.png" alt="AC_automation_6_9.png"></p>
<p>找到 6 的父结点 5，$\text{fail}[5]=10$。然而 10 结点没有字母 <code>s</code> 连出的边；继续跳到 10 的 fail 指针，$\text{fail}[10]=0$。发现 0 结点有字母 <code>s</code> 连出的边，指向 7 结点；所以 $\text{fail}[6]=7$。最后放一张建出来的图</p>
<p><img src="https://oi-wiki.org/string/images/ac-automaton4.png" alt="finish"></p>
<h2 id="字典树与字典图"><a href="#字典树与字典图" class="headerlink" title="字典树与字典图"></a>字典树与字典图</h2><p>我们直接上代码吧。字典树插入的代码就不分析了（后面完整代码里有），先来看构建函数 <code>build()</code>，该函数的目标有两个，一个是构建 fail 指针，一个是构建自动机。参数如下：</p>
<ol>
<li><code>tr[u,c]</code>：有两种理解方式。我们可以简单理解为字典树上的一条边，即 $\text{trie}[u,c]$；也可以理解为从状态（结点）$u$ 后加一个字符 <code>c</code> 到达的状态（结点），即一个状态转移函数 $\text{trans}(u,c)$。下文中我们将用第二种理解方式继续讲解。</li>
<li>队列 <code>q</code>：用于 BFS 遍历字典树。</li>
<li><code>fail[u]</code>：结点 $u$ 的 fail 指针。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">    <span class="keyword">if</span> (tr[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tr[u][i])</span><br><span class="line">        fail[tr[u][i]] = tr[fail[u]][i], q.<span class="built_in">push</span>(tr[u][i]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        tr[u][i] = tr[fail[u]][i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下上面的代码：build 函数将结点按 BFS 顺序入队，依次求 fail 指针。这里的字典树根结点为 0，我们将根结点的子结点一一入队。若将根结点入队，则在第一次 BFS 的时候，会将根结点儿子的 fail 指针标记为本身。因此我们将根结点的儿子一一入队，而不是将根结点入队。</p>
<p>然后开始 BFS：每次取出队首的结点 u（$\text{fail}[u]$ 在之前的 BFS 过程中已求得），然后遍历字符集（这里是 0-25，对应 a-z，即 $u$ 的各个子节点）：</p>
<ol>
<li>如果 $\text{trans}[u][i]$ 存在，我们就将 $\text{trans}[u][i]$ 的 fail 指针赋值为 $\text{trans}[\text{fail}[u]][i]$。这里似乎有一个问题。根据之前的讲解，我们应该用 while 循环，不停的跳 fail 指针，判断是否存在字符 <code>i</code> 对应的结点，然后赋值，但是这里通过特殊处理简化了这些代码。</li>
<li>否则，令 $\text{trans}[u][i]$ 指向 $\text{trans}[\text{fail}[u]][i]$ 的状态。</li>
</ol>
<p>这里的处理是，通过 <code>else</code> 语句的代码修改字典树的结构。没错，它将不存在的字典树的状态链接到了失配指针的对应状态。在原字典树中，每一个结点代表一个字符串 $S$，是某个模式串的前缀。而在修改字典树结构后，尽管增加了许多转移关系，但结点（状态）所代表的字符串是不变的。</p>
<p>而 $\text{trans}[S][c]$ 相当于是在 $S$ 后添加一个字符 <code>c</code> 变成另一个状态 $S’$。如果 $S’$ 存在，说明存在一个模式串的前缀是 $S’$，否则我们让 $\text{trans}[S][c]$ 指向 $\text{trans}[\text{fail}[S]][c]$。由于 $\text{fail}[S]$ 对应的字符串是 $S$ 的后缀，因此 $\text{trans}[\text{fail}[S]][c]$ 对应的字符串也是 $S’$ 的后缀。</p>
<p>换言之在 Trie 上跳转的时侯，我们只会从 $S$ 跳转到 $S’$，相当于匹配了一个 $S’$；但在 AC 自动机上跳转的时侯，我们会从 $S$ 跳转到 $S’$ 的后缀，也就是说我们匹配一个字符 <code>c</code>，然后舍弃 $S$ 的部分前缀。舍弃前缀显然是能匹配的。那么 fail 指针呢？它也是在舍弃前缀啊！试想一下，如果文本串能匹配 $S$，显然它也能匹配 $S$ 的后缀。所谓的 fail 指针其实就是 $S$ 的一个后缀集合。</p>
<p><code>tr</code> 数组还有另一种比较简单的理解方式：如果在位置 $u$ 失配，我们会跳转到 $\text{fail}[u]$ 的位置。所以我们可能沿着 fail 数组跳转多次才能来到下一个能匹配的位置。所以我们可以用 <code>tr</code> 数组直接记录记录下一个能匹配的位置，这样就能节省下很多时间。</p>
<p>这样修改字典树的结构，使得匹配转移更加完善。同时它将 fail 指针跳转的路径做了压缩（就像并查集的路径压缩），使得本来需要跳很多次 fail 指针变成跳一次。</p>
<p>好的，我知道大家都受不了长篇叙述。上图！我们将之前的 GIF 图改一下：</p>
<p><img src="https://oi-wiki.org/string/images/ac-automaton2.gif" alt="AC_automation_gif_b_pro3.gif"></p>
<ol>
<li>蓝色结点：BFS 遍历到的结点 u</li>
<li>蓝色的边：当前结点下，AC 自动机修改字典树结构连出的边。</li>
<li>黑色的边：AC 自动机修改字典树结构连出的边。</li>
<li>红色的边：当前结点求出的 fail 指针</li>
<li>黄色的边：fail 指针</li>
<li>灰色的边：字典树的边</li>
</ol>
<p>可以发现，众多交错的黑色边将字典树变成了 <strong>字典图</strong>。图中省略了连向根结点的黑边（否则会更乱）。我们重点分析一下结点 5 遍历时的情况。我们求 $\text{trans}[5][s]=6$ 的 fail 指针：</p>
<p><img src="https://oi-wiki.org/string/images/ac-automaton2.png" alt="AC_automation_b_7.png"></p>
<p>本来的策略是找 fail 指针，于是我们跳到 $\text{fail}[5]=10$ 发现没有 <code>s</code> 连出的字典树的边，于是跳到 $\text{fail}[10]=0$，发现有 $\text{trie}[0][s]=7$，于是 $\text{fail}[6]=7$；但是有了黑边、蓝边，我们跳到 $\text{fail}[5]=10$ 之后直接走 $\text{trans}[10][s]=7$ 就走到 $7$ 号结点了。</p>
<p>这就是 build 完成的两件事：构建 fail 指针和建立字典图。这个字典图也会在查询的时候起到关键作用。</p>
<h2 id="多模式匹配"><a href="#多模式匹配" class="headerlink" title="多模式匹配"></a>多模式匹配</h2><p>接下来分析匹配函数 <code>query()</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *t)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> u = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; t[i]; i++) &#123;</span><br><span class="line">    u = tr[u][t[i] - <span class="string">&#x27;a&#x27;</span>];  <span class="comment">// 转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = u; j &amp;&amp; e[j] != <span class="number">-1</span>; j = fail[j]) &#123;</span><br><span class="line">      res += e[j], e[j] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 $u$ 作为字典树上当前匹配到的结点，<code>res</code> 即返回的答案。循环遍历匹配串，$u$ 在字典树上跟踪当前字符。利用 fail 指针找出所有匹配的模式串，累加到答案中。然后清零。在上文中我们分析过，字典树的结构其实就是一个 trans 函数，而构建好这个函数后，在匹配字符串的过程中，我们会舍弃部分前缀达到最低限度的匹配。fail 指针则指向了更多的匹配状态。最后上一份图。对于刚才的自动机：</p>
<p><img src="https://oi-wiki.org/string/images/ac-automaton3.png" alt="AC_automation_b_13.png"></p>
<p>我们从根结点开始尝试匹配 <code>ushersheishis</code>，那么 $p$ 的变化将是：</p>
<p><img src="https://oi-wiki.org/string/images/ac-automaton3.gif" alt="AC_automation_gif_c.gif"></p>
<ol>
<li>红色结点：$p$ 结点</li>
<li>粉色箭头：$p$ 在自动机上的跳转，</li>
<li>蓝色的边：成功匹配的模式串</li>
<li>蓝色结点：示跳 fail 指针时的结点（状态）。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望大家看懂了文章。</p>
<p>时间复杂度：定义 $|s_i|$ 是模板串的长度，$|S|$ 是文本串的长度，$|\Sigma|$ 是字符集的大小（常数，一般为 26）。如果连了 trie 图，时间复杂度就是 $O(\sum|s_i|+n|\Sigma|+|S|)$，其中 $n$ 是 AC 自动机中结点的数目，并且最大可以达到 $O(\sum|s_i|)$。如果不连 trie 图，并且在构建 fail 指针的时候避免遍历到空儿子，时间复杂度就是 $O(\sum|s_i|+|S|)$。</p>
<h3 id="例题-HDU-2222-Keywords-Search"><a href="#例题-HDU-2222-Keywords-Search" class="headerlink" title="例题 HDU - 2222 Keywords Search"></a>例题 <a href="https://vjudge.net/problem/HDU-2222">HDU - 2222 Keywords Search</a></h3><p>给定 n 个长度不超过 50 的由小写英文字母组成的单词准备查询，以及一篇长为 m 的文章，问：文中出现了多少种待查询的单词。多组数据。</p>
<p>输入格式<br>第一行一个整数 T，表示数据组数；</p>
<p>对于每组数据，第一行一个整数 n，接下去 n 行表示 n 个单词，最后一行输入一个字符串，表示文章。</p>
<p>输出格式<br>对于每组数据，输出一个数，表示文中出现了多少个待查询的单词。</p>
<p>输入样例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">she</span><br><span class="line">he</span><br><span class="line">say</span><br><span class="line">shr</span><br><span class="line">her</span><br><span class="line">yasherhs</span><br></pre></td></tr></table></figure><br>输出样例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, S = <span class="number">55</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tr[N * S][<span class="number">26</span>], cnt[N * S], idx;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> str[M];</span><br><span class="line"><span class="type">int</span> q[N * S], fail[N * S];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立一颗trie树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;  <span class="comment">// 从根节点开始找其是否有前缀的相同的字符串放一块（压缩空间）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++)    <span class="comment">// 字符串最后一位是&#x27;\0&#x27;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p][t])</span><br><span class="line">            tr[p][t] = ++ idx;  <span class="comment">// 如果当前节点下没有这个字符的话在这个位置给当前位置字符赋上一个编号</span></span><br><span class="line">        p = tr[p][t];</span><br><span class="line">    &#125;   </span><br><span class="line">    cnt[p] ++;  <span class="comment">// 在没有字符串结尾的地方都记录上这个位置上有多少个字符串（属性值）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化fail数组和自动机</span></span><br><span class="line"><span class="comment">// next数组是找最大后缀和前缀相同，最少可以移动的步数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// next数组的遍历是通过的上一层next数组来对本层next数组进行更新的(所以用到bfs)</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 先把第一层的字符</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)    <span class="comment">// 26个英文字母</span></span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>][i])</span><br><span class="line">            q[++ tt] = tr[<span class="number">0</span>][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> p = tr[t][i];</span><br><span class="line">            <span class="comment">// 朴素的操作是 if(!p) continue;</span></span><br><span class="line">            <span class="comment">// 优化成trie图</span></span><br><span class="line">            <span class="comment">// 如果当前有节点的话那么就要通过其父节点的失配指针指向的节点是否有一条边含义的i，如果没有就继续往上找(直到找到根节点)</span></span><br><span class="line">            <span class="keyword">if</span>(p) </span><br><span class="line">            &#123;</span><br><span class="line">                fail[p] = tr[fail[t]][i];</span><br><span class="line">                q[++ tt] = p;</span><br><span class="line">            &#125;     </span><br><span class="line">            <span class="keyword">else</span> tr[t][i] = tr[fail[t]][i]; <span class="comment">// 这里的是将不存在的状态接到失配指针的对应状态（是为了做一步压缩状态）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line">        <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span> fail);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">            <span class="built_in">insert</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找答案 匹配过程</span></span><br><span class="line">        <span class="comment">// 多模式串匹配过程</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; str[i]; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;   <span class="comment">// 当前遍历的字符</span></span><br><span class="line">            j = tr[j][t];   <span class="comment">// 表示的状态</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> p = j;</span><br><span class="line">            <span class="keyword">while</span>(p)</span><br><span class="line">            &#123;</span><br><span class="line">                res += cnt[p];  <span class="comment">// 如果当前这个状态如果是有字符串的，那么答案的加上</span></span><br><span class="line">                cnt[p] = <span class="number">0</span>; <span class="comment">// 避免过多累计贡献</span></span><br><span class="line">                <span class="comment">// 原串匹配到字符i的时候，最深到达的节点，所以当匹配到当前节点的时候，其节点的前缀节点也一定会匹配所以还要加上fail的分枝的答案</span></span><br><span class="line">                p = fail[p];  <span class="comment">// 同时还需要把这点点失配分支状态下的答案加上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模版</category>
        <category>数据结构</category>
        <category>ac自动机</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/08/31/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>python学习笔记</title>
    <url>/2022/09/09/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-python解释器"><a href="#1-python解释器" class="headerlink" title="1.python解释器"></a>1.python解释器</h2><p>在一开始的时候没有必要直接去使用ide, 在mac上<code>/usr/bin</code>使用命令python3即可以调出pyton解释器</p>
<h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2.数据结构"></a>2.数据结构</h2><h3 id="列表详解"><a href="#列表详解" class="headerlink" title="列表详解"></a>列表详解</h3><p>Python 支持多种 复合 数据类型，可将不同值组合在一起。最常用的<em>列表</em>，是用方括号标注，逗号分隔的一组值。<em>列表</em>可以包含不同类型的元素，但一般情况下，各个元素的类型相同<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">squares</span><br></pre></td></tr></table></figure><br>和字符串一样也支持索引<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squares[<span class="number">0</span>]  <span class="comment"># indexing returns the item</span></span><br><span class="line">squares[-<span class="number">1</span>]</span><br><span class="line">squares[-<span class="number">3</span>:]  <span class="comment"># slicing returns a new list</span></span><br></pre></td></tr></table></figure></p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>append(x) 与 insert(i,x)<br> insert函数必须告诉插入到哪个位置，如果默认插在最后的话那么就退化成append()，设计逻辑上是不对的</p>
<p>remove(x) 与 pop([i])<br> remove函数是根据函数值进行索引去除<br> pop函数是根据下标（索引值）来去除数值</p>
<p>index(x[,start[,end]])<br>用法一 从头开始搜索我们指定的值<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;Runoob 索引值为&#x27;</span>, list1.index(<span class="string">&#x27;Runoob&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;Taobao 索引值为&#x27;</span>, list1.index(<span class="string">&#x27;Taobao&#x27;</span>))</span><br></pre></td></tr></table></figure><br> 输出<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runoob 索引值为 1</span><br><span class="line">Taobao 索引值为 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><br> 用法二 指定位置开始搜索<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;Runoob 索引值为&#x27;</span>, list1.index(<span class="string">&#x27;Runoob&#x27;</span>,<span class="number">1</span>)) <span class="comment"># 从下标为1的位置开始检索</span></span><br><span class="line"><span class="comment">#  异常报错</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;Runoob 索引值为&#x27;</span>, list1.index(<span class="string">&#x27;Runoob&#x27;</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><br> 输出<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runoob 索引值为 1</span><br><span class="line">触发 ValueError 异常。</span><br></pre></td></tr></table></figure></p>
<p>sort(*,key = None, reverse = False)<br> key 表示按照什么规则 比如可以按照长度规则或是按照数值大小规则来进行排序<br> reverse：True 表示要降序，某人为False</p>
<h2 id="3-copy-浅层和深层复制操作"><a href="#3-copy-浅层和深层复制操作" class="headerlink" title="3.copy 浅层和深层复制操作"></a>3.copy 浅层和深层复制操作</h2><p>Python 的赋值语句不复制对象，而是创建目标和对象的绑定关系。对于自身可变，或包含可变项的集合，有时要生成副本用于改变操作，而不必改变原始对象。本模块提供了通用的浅层复制和深层复制操作，（如下所述）。<br>接口摘要：<br>copy.copy(x)<br>返回 x 的浅层复制。<br>copy.deepcopy(x[, memo])<br>返回 x 的深层复制。<br>exception copy.Error<br>针对模块特定错误引发。</p>
<p>上面也就是说明了list实际上表示的一个引用的关系，比如<code>alist = [1]</code>,那么<code>alist</code>本质上等于一个指针指向存储数据1的内存， <code>alist = blist</code>这个赋值关系，实际上就是等同于两个指针都指向同一片内存，如果任意修改一个<code>alist</code> / <code>blist</code> 这时候相当于这一个内存的内容发生变化，只要修改了一个两个list都会同时发生错误。这就是浅拷贝，浅拷贝就是内容之间存在依赖关系，具有相互影响的关系，在c语言的严重极端的情况下，如果要删除一个内存空间，另外一个指针本来只想的地方就消失，很容易造成sf问题（段错误问题），指针指向了一片不明空间，这样是十分危险的。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路问题</title>
    <url>/2022/07/18/%E5%9B%BE%E8%AE%BA%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><h3 id="Bellman-ford算法"><a href="#Bellman-ford算法" class="headerlink" title="Bellman_ford算法"></a>Bellman_ford算法</h3><p>每次对所有边进行松弛操作，并迭代n次最后得到的就是单源最短路。<br>主要用于</p>
<ol>
<li>求含有负环的最短路</li>
<li>求有边数限制的最短路<br><em>因为有了spfa对bellman的优化，所以一般情况下不是求边数限制的话，不会用到bellman算法</em></li>
</ol>
<p>步骤：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 迭代n次（一个图中不含有环的最短路最长边数位n-1条边）  </span><br><span class="line">     for 对每一条边（m条）进行松弛</span><br></pre></td></tr></table></figure></p>
<p>因为内层对每一条边进行松弛，所以可能到不了的边最后也会被更新为非INF，所以在判断是否有最短路不能通过是否等于INF来判断，要通过INF/2来判断</p>
<h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><p>例题 <a href="https://www.acwing.com/problem/content/description/855/">AcWing853. 有边数限制的最短路</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).bEdgein(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,d;</span><br><span class="line">    <span class="comment">// Edge():a(),b(),d()&#123;&#125;</span></span><br><span class="line">    <span class="comment">// Edge(int a, int b, int d): a(a), b(b),d(d)&#123;&#125;</span></span><br><span class="line">&#125;Edge[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; Edge[i].a &gt;&gt; Edge[i].b &gt;&gt; Edge[i].d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="type">int</span> bak[N];</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(bak,dis,<span class="keyword">sizeof</span> dis);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = Edge[j].a, b = Edge[j].b;</span><br><span class="line">            <span class="type">int</span> d = Edge[j].d;</span><br><span class="line">            dis[b] = <span class="built_in">min</span>(dis[b],bak[a] + d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = dis[n];</span><br><span class="line">    <span class="keyword">if</span>(res &gt; INF / <span class="number">2</span>) cout&lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h3><p>对<code>bellman</code>的优化，因为<code>bellman</code>每次都松弛每一条边，但是这种对每一条边都进行松弛是有大量重复的操作的，是没有意义的。所以<code>spfa</code>使用了队列（循环队列）来进行优化，每次将元素出队，有且只会对这个元素的邻边进行更新。</p>
<p>存储方式：使用一个类邻接表的形式，树链前向星。</p>
<h3 id="例题spfa求最短路"><a href="#例题spfa求最短路" class="headerlink" title="例题spfa求最短路"></a>例题<a href="https://www.acwing.com/problem/content/853/">spfa求最短路</a></h3><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。</p>
<p>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 impossible。</p>
<p>数据保证不存在负权回路。</p>
<p>输入格式<br>第一行包含整数 n 和 m。</p>
<p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p>
<p>输出格式<br>输出一个整数，表示 1 号点到 n 号点的最短距离。</p>
<p>如果路径不存在，则输出 impossible。</p>
<p>数据范围<br>1≤n,m≤105,<br>图中涉及边长绝对值均不超过 10000。</p>
<p>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 5</span><br><span class="line">2 3 -3</span><br><span class="line">1 3 4</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[N], w[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;   <span class="comment">// stl里面的queue本质上就是一个循环队列</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">                <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    dist[j] = dist[t] + w[i];</span><br><span class="line">                    <span class="keyword">if</span>(!st[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(j);</span><br><span class="line">                        st[j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; inf / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist[n]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>手写循环队列的spfa版块<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[S] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q[N];</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    q[hh] = S, st[S] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;  <span class="comment">// 这里的状态不同与dijkstra这里是表示的是否在队列当中，一个节点可能被多次更新</span></span><br><span class="line">        <span class="comment">// spfa的过程等于 要想求的i～j之间的最短路，每次更新就在i～j的路径上再加一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j] &gt; dis[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[j] = dis[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt ++] =  j;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="O（n-2-dijkstra"><a href="#O（n-2-dijkstra" class="headerlink" title="O（n^2) dijkstra"></a>O（n^2) dijkstra</h3><p>外层迭代n次，每次选取到源点的最小值，维护dist数组（要注意与最小生成树中的dist数组做区分，最小生成树的中的dist数组是维护到连通块的最小值，在最短路问题中是维护的是到源点的最小值），由于dist是每个点到别的顶点的最短距离，所以内层也是迭代n遍<br>用选出来的这个点对其他点进行更新dist（如果对更新有别的决策要写入到更新边的板块中）<br>如：双权值，dijkstra问题<a href="https://vjudge.net/problem/HDU-3790">最短路径问题</a>,在板子后面会贴出代码</p>
<h4 id="例题Dijkstra求最短路"><a href="#例题Dijkstra求最短路" class="headerlink" title="例题Dijkstra求最短路"></a>例题<a href="https://www.acwing.com/problem/content/851/">Dijkstra求最短路</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t]) ) t = j;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        g[a][b] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dist[n] != inf) cout &lt;&lt; dist[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双权值问题<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; <span class="built_in">assert</span>(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> cost[N][N];</span><br><span class="line"><span class="type">int</span> n, m; </span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 双关键值 最短路问题</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(val,<span class="number">0x3f</span>, <span class="keyword">sizeof</span> val);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    val[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t  == <span class="number">-1</span> || dist[j] &lt; dist[t]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 与单权值问题的区别</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + g[t][j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + g[t][j];</span><br><span class="line">                val[j] = val[t] + cost[t][j];<span class="comment">//即使这里比原来花费的要更大的话也要更新，因为他们是有联系的</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dist[j] == dist[t] + g[t][j] &amp;&amp; val[j] &gt; val[t] + cost[t][j])</span><br><span class="line">            &#123;</span><br><span class="line">                val[j] = val[t] + cost[t][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,d,p;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">memset</span>(cost, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> cost);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;d,&amp;p);</span><br><span class="line">            <span class="keyword">if</span>(g[a][b] &gt; d)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 花费和边长是相互挂钩的</span></span><br><span class="line">                g[a][b] = g[b][a] = d;</span><br><span class="line">                cost[a][b] = cost[b][a] = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(g[a][b] == d &amp;&amp; cost[a][b] &gt; p)</span><br><span class="line">            &#123;</span><br><span class="line">                cost[a][b] = cost[b][a] = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> s,e;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;s,&amp;e);</span><br><span class="line">        <span class="built_in">dijkstra</span>(s);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; dist[e] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val[e] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="O（mlogn）的dijkstra"><a href="#O（mlogn）的dijkstra" class="headerlink" title="O（mlogn）的dijkstra"></a>O（mlogn）的dijkstra</h3><p><strong>对于dijkstra算法和bfs算法都是一样的，每个点只会别迭代一次，迭代完了之后就不会再被更新。</strong>所以一般会在这做优化如果st[i] = true, 就直接跳过更新这个点，而spfa中的st[i]记录的是i点这个点是否在队列当中，spfa不一样的是每个点是可以被更新多次的（所以这个性质也经常被用于求负环当中）<br><strong>实际上堆优化版的dijkstra就是优先队列bfs</strong>，只不过其实现在不同类型的图，假如是给定的图是迷宫图给出了一个迷宫的形状，我们只能上下左右走，那么应该使用bfs。在一些标定图（每个点都标定好编号）使用dijkstra比较方便</p>
<h3 id="例题Dijkstra求最短路-II"><a href="#例题Dijkstra求最短路-II" class="headerlink" title="例题Dijkstra求最短路 II"></a>例题<a href="https://www.acwing.com/problem/content/852/">Dijkstra求最短路 II</a></h3><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为非负值。</p>
<p>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。</p>
<p>输入格式<br>第一行包含整数 n 和 m。</p>
<p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p>
<p>输出格式<br>输出一个整数，表示 1 号点到 n 号点的最短距离。</p>
<p>如果路径不存在，则输出 −1。</p>
<p>数据范围<br>1≤n,m≤1.5×105,<br>图中涉及边长均不小于 0，且不超过 10000。<br>数据保证：如果最短路存在，则最短路的长度不超过 109。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 2</span><br><span class="line">2 3 1</span><br><span class="line">1 3 4</span><br></pre></td></tr></table></figure><br>输出样例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], w[N],idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;   <span class="comment">// 表示这个点的子节点是否有更新，更新过了接下来就不需要再更新了</span></span><br><span class="line">        st[ver] = <span class="literal">true</span>; <span class="comment">// 堆优化的对状态进行判断主要的同bfs一样，每个节点的只会更新一遍，防止其重复更新才做判断（防止走回头路）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dist[ver] + w[i] &lt; dist[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dist[n] != <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; dist[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模版</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>大学数学学习路线</title>
    <url>/2022/08/10/%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h2><p>本人的学习路线为：<a href="https://www.bilibili.com/video/BV1x7411x7XQ?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=a0d3102b058feafe6e998d9731e0f0c6">浙大 微积分</a><br>老师的讲课风格主要在于公式的推导与证明，是适合与0基础的小白上手。讲课风格也非常具有学院派的气息，同时也会结合讲一些例题方便理解。我认为这个老师讲的课不是为了写题而讲，而是为了能过深入理解而学。<br>同时，大家也都推荐的<a href="https://space.bilibili.com/688379639?spm_id_from=333.337.0.0">武忠祥老师</a>、 <a href="https://space.bilibili.com/66607740?spm_id_from=333.337.0.0">宋浩老师</a>、<a href="https://space.bilibili.com/679237565?spm_id_from=333.337.0.0">张宇</a>,这些老师都是考研学生常听的课，有些老师也是出自于高等学府的教授，可以结合网上的课程考虑是否听他们课。</p>
<h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><p><a href="https://www.bilibili.com/video/BV1bb411H7JN?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">MIT 线性代数</a><br>作为美国的高等的学府教学质量自然不用说，教授教授的课程切入角度往往都非常神奇，是一门越看越想看，越看越兴奋的课程。同时网上也有很多的人也看过，同时也有相关方面的资料。但是一旦上这一门课，很有可能进度就与学校线下的课程进度不同，一定要耐住心好好走自己的节奏，学到东西才是根本目的！同时本课程也有可能涉及到没有课本的方面，但是就我个人来说并没有太大理想，当时上网课基本上都是上完课基本所有问题都能解决，很棒的课程。我也有不少的MIT这们课程的资料，日后我会给出，或者向我私信索取。</p>
<p>同理数学类的科目都适用与上面的考研高数老师</p>
]]></content>
  </entry>
  <entry>
    <title>差分约束</title>
    <url>/2022/07/19/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><h3 id="应用一：求解不等式组的可行解（只能求解出来一个组）"><a href="#应用一：求解不等式组的可行解（只能求解出来一个组）" class="headerlink" title="应用一：求解不等式组的可行解（只能求解出来一个组）"></a>应用一：求解不等式组的可行解（只能求解出来一个组）</h3><p>不等式组的的表示形式一般也有两种<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只有相对值的性质</span><br><span class="line">x1 &lt;= x2 + c1</span><br><span class="line">x2 &lt;= x3 + c2</span><br><span class="line">x3 &lt;= x1 + c3</span><br><span class="line">（只含有相对值，是不能可以有最大最小值的，因为没有定值约束）</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">含有一个绝对参数</span><br><span class="line">x1 &lt;= x2 + c1</span><br><span class="line">x2 &lt;= x3 + c2</span><br><span class="line">x3 &lt;= x1 + c3</span><br><span class="line">x1 &gt;= 0(0是坐标系中的绝对地址)</span><br></pre></td></tr></table></figure><br>从不等式的形式转换成图的形式<br>dist[x1] &lt;= dist[x2] + c1<br><strong>构造： 这里从x2-&gt;x1连上一条权值为c1的边</strong><br><em>这里的dist数组维护的是点x到源点的最短距离</em><br>反证法：如果dist[x2] + c1 &lt; dist[x1]的话，那么就说明x1到源点的最短路径应该是从x2到源点的最短路径在经过c1边到x1，所以x1的最短路径是可以被更新的</p>
<p>要知道这些不等式集合是不一定是可解的，所以要求其可行解先，我们应该判断其是否有解。<br>判断是否有解？<br>结论：</p>
<ol>
<li><p><strong>x1 &lt;= x2 + c1这种形式，图中没有负环的情况下是有解的</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x1 &lt;= x2 + c1</span><br><span class="line">x2 &lt;= x3 + c2</span><br><span class="line">x3 &lt;= x1 + c3</span><br></pre></td></tr></table></figure>
<p> 证明角度一：不等式运算<br> 我们可以把上面三个不等式加起来，可以得到<code>x1 + x2 + x3 &lt;= x1 + x2 + x3 + c1 + c2 + c3</code><br> 化简可得<code>0 &lt;= c1 + c2 +c3</code> 得到<code>c1 + c2 + c3</code>大于等于0是是有解的，<code>c1 + c2 + c3</code>是路径包含了x1,x2,x3的环，也就是当图中没有负环的时候是有解的。<br> 证明角度二：放缩<br> <code>x1 &lt;= x2 + c1 &lt;= x3 + c1 + c2 &lt;= x1 + c1 + c2 + c3</code>,化简得到 <code>x1 &lt;= x1 + c1 + c2 + c3</code>,很明显仅当<code>c1 + c2 + c3 &lt;= 0</code>的时候不等式才会成立</p>
</li>
<li><p><strong>x1 &gt;= x2 + c1这种形式，图中没有正环的情况下是有解的</strong></p>
</li>
</ol>
<p>在确定完了有解的情况下，我们求解不等式的可行解<br>我们从上面我们转换成图论问题使用了dist数组，表示到源点的最短/最长距离，所以我们首先要构造出来一个源点。<br>源点需要满足的条件：从源点出发，一定是可以达到所以的<strong>边</strong>的。<br>这里是什么源点是一定达到所有的边而不是所有的点呢？？ 很显然如果不能到达这个点的话，那么说明这个点是孤立点，孤立点不受到任何的约束，所以孤立点是可以去取得任何的值</p>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>先将每个不等式 xi &lt;= xj + cj 转换成一条j-&gt;i边权为cj的边</li>
<li>构造出一个超级源点（虚拟源点），使得源点一定是可以遍历到所有的边的</li>
<li>从源点求一遍单源最短路<ol>
<li>结果1:如果有负环，则原不等式组一定无解</li>
<li>结构2:如果没有负环，则dist[i]就是原不等式组的一个可行解</li>
</ol>
</li>
</ol>
<h3 id="应用二：求解最大值-最小值（每个值的最大值和最小值）"><a href="#应用二：求解最大值-最小值（每个值的最大值和最小值）" class="headerlink" title="应用二：求解最大值/最小值（每个值的最大值和最小值）"></a>应用二：求解最大值/最小值（每个值的最大值和最小值）</h3><p>现的<br><strong>结论：如果求的是最小值话，则应该求最长路，如果求的是最大值的话，则应该求最短路</strong><br>证明：以求xi的最小值为例<br>首先我们要知道这个不等式组一定是形式二，应为只有相对位置，没有绝对坐标约束是不可能有最大最小值的。<br>我们可以通过放缩（应用一的放缩思想）构造出来一些不等式<code>xi &lt;= xj + cj &lt;= ...&lt;= 0(xi &gt;= 0) + c1 + c2 + c3..+cn</code>,这里的c1，c2..是到xi的边，因为到xi的路径有可能有很多条所以，所以要想满足所有的xi &lt;= c1 + … + cn 的不不等式，我们只能取的上确界，也就是取所有路径的最大值，就一定满足所有的不等式了。<strong>于是就将求x的最小值转换成最长路径</strong></p>
<h4 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h4><p>建立一个超级源点，0，然后建立0-&gt;i,边权为c的边(绝对参考值)<br>计算出所有的上界/下界，最终的xi的最大值（最小值）等于所有上界（下界）的最小值（最大值）</p>
<h4 id="注意-与-总结"><a href="#注意-与-总结" class="headerlink" title="注意 与 总结"></a>注意 与 总结</h4><ul>
<li>我们上面的不等式组一定是可以统一成大于等于/小于等于的形式（大于等于和小于等于都是同时存在的，因为有两个变量在不等式的两边，假如对于不等式左边的变量是大于等于，那么就对于不等式右边的变量是小于等于）</li>
<li>求最小值的时候把不等式组统一形式成 a &gt;= b + c1, 把所有的常量（可正可负）都移到不等式的右边，b向a连上一条权值为c1的边（因为求最小值，等于求最长路，dist[a] &gt;= dist[b] + c1, 反证法 b向a有一条权值为c1的边，如果b的最长路径加上一条b-&gt;a路径比原来a的最长路径要大的话，那么就需要对a的最长路径进行更新，矛盾所以我们构造边成立）</li>
<li>求最大值的时候把不等式组统一形式成 a &lt;= b + c1, <code>b</code>向<code>a</code>连上一条权值为c1的边</li>
<li>转化不等式组：a &gt; b 可以等价于 a &gt;= b + 1</li>
<li>最小值（最长路） 正环无解， 最大值（最短路） 负环无解</li>
</ul>
<h3 id="例题-AcWing-1169-糖果"><a href="#例题-AcWing-1169-糖果" class="headerlink" title="例题 AcWing 1169. 糖果"></a>例题 <a href="https://www.acwing.com/problem/content/1171/">AcWing 1169. 糖果</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>幼儿园里有 N 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。</p>
<p>但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候， 老师需要满足小朋友们的 K 个要求。</p>
<p>幼儿园的糖果总是有限的，老师想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。</p>
<p>输入格式<br>输入的第一行是两个整数 N,K。</p>
<p>接下来 K 行，表示分配糖果时需要满足的关系，每行 3 个数字 X,A,B。</p>
<p>如果 X=1．表示第 A 个小朋友分到的糖果必须和第 B 个小朋友分到的糖果一样多。<br>如果 X=2，表示第 A 个小朋友分到的糖果必须少于第 B 个小朋友分到的糖果。<br>如果 X=3，表示第 A 个小朋友分到的糖果必须不少于第 B 个小朋友分到的糖果。<br>如果 X=4，表示第 A 个小朋友分到的糖果必须多于第 B 个小朋友分到的糖果。<br>如果 X=5，表示第 A 个小朋友分到的糖果必须不多于第 B 个小朋友分到的糖果。<br>小朋友编号从 1 到 N。</p>
<p>输出格式<br>输出一行，表示老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出 −1。</p>
<p>数据范围<br>1≤N&lt;105,<br>1≤K≤105,<br>1≤X≤5,<br>1≤A,B≤N</p>
<p>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">1 1 2</span><br><span class="line">2 3 2</span><br><span class="line">4 4 1</span><br><span class="line">3 4 5</span><br><span class="line">5 4 5</span><br><span class="line">2 3 5</span><br><span class="line">4 5 1</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure></p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>题目要求求最小值，先化简不等式组，判断是否有正环，没有正环，求解最长路</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; <span class="built_in">assert</span>(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line">ll dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用stack判断正环</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> q[N];</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    st[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[--tt];</span><br><span class="line">        st[t] =<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &lt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt ++] = j;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">// 因为要求的是最小值，所以我们需要找最长路径，并构造&gt;=的形式</span></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="built_in">add</span>(a,b,<span class="number">0</span>),<span class="built_in">add</span>(b,a,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">2</span>) <span class="built_in">add</span>(a,b,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">3</span>) <span class="built_in">add</span>(a,b,<span class="number">0</span>); <span class="comment">// 边权为0就无所谓方向了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">4</span>) <span class="built_in">add</span>(b,a,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">5</span>) <span class="built_in">add</span>(a,b,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造超级源点</span></span><br><span class="line">    <span class="comment">// 由于上面的不等式为相对值，没有绝对值得情况下是无法求的最值问题的</span></span><br><span class="line">    <span class="comment">// 我们由题意知所有小朋友都会得到糖果所以，每个朋友至少为一，所以构造虚拟源点时候，初始化为1就可以表示为绝对参考系</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) res += dist[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模版</category>
        <category>图论</category>
        <category>差分约束</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>笔记</tag>
        <tag>图论模版</tag>
      </tags>
  </entry>
  <entry>
    <title>数位dp</title>
    <url>/2022/08/03/%E6%95%B0%E4%BD%8Ddp/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://oi.wiki/dp/number/">引用OI.WIKI</a></p>
<p>数位：把一个数字按照个、十、百、千等等一位一位地拆开，关注它每一位上的数字。如果拆的是十进制数，那么每一位数字都是 0~9，其他进制可类比十进制。</p>
<p>数位 DP：用来解决一类特定问题，这种问题比较好辨认，一般具有这几个特征：</p>
<ol>
<li><p>要求统计满足一定条件的数的数量（即，最终目的为计数）；</p>
</li>
<li><p>这些条件经过转化后可以使用「数位」的思想去理解和判断；</p>
</li>
<li><p>输入会提供一个数字区间（有时也只提供上界）来作为统计的限制；</p>
</li>
<li><p>上界很大（比如 $10^{18}$），暴力枚举验证会超时。</p>
</li>
</ol>
<p>数位 DP 的基本原理：</p>
<p>考虑人类计数的方式，最朴素的计数就是从小到大开始依次加一。但我们发现对于位数比较多的数，这样的过程中有许多重复的部分。例如，从 7000 数到 7999、从 8000 数到 8999、和从 9000 数到 9999 的过程非常相似，它们都是后三位从 000 变到 999，不一样的地方只有千位这一位，所以我们可以把这些过程归并起来，将这些过程中产生的计数答案也都存在一个通用的数组里。此数组根据题目具体要求设置状态，用递推或 DP 的方式进行状态转移。</p>
<p>数位 DP 中通常会利用常规计数问题技巧，比如把一个区间内的答案拆成两部分相减（即 $\mathit{ans}<em>{[l, r]} = \mathit{ans}</em>{[0, r]}-\mathit{ans}_{[0, l - 1]}$</p>
<p>那么有了通用答案数组，接下来就是统计答案。统计答案可以选择记忆化搜索，也可以选择循环迭代递推。为了不重不漏地统计所有不超过上限的答案，要从高到低枚举每一位，再考虑每一位都可以填哪些数字，最后利用通用答案数组统计答案。</p>
<h3 id="例题AcWing-1081-度的数量"><a href="#例题AcWing-1081-度的数量" class="headerlink" title="例题AcWing 1081. 度的数量"></a>例题<a href="https://www.acwing.com/problem/content/1083/">AcWing 1081. 度的数量</a></h3><p>求给定区间 [X,Y] 中满足下列条件的整数个数：这个数恰好等于 K 个互不相等的 B 的整数次幂之和。</p>
<p>例如，设 X=15,Y=20,K=2,B=2，则有且仅有下列三个数满足题意：</p>
<p>17=24+20<br>18=24+21<br>20=24+22<br>输入格式<br>第一行包含两个整数 X 和 Y，接下来两行包含整数 K 和 B。</p>
<p>输出格式<br>只包含一个整数，表示满足条件的数的个数。</p>
<p>数据范围<br>1≤X≤Y≤231−1,<br>1≤K≤20,<br>2≤B≤10<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15 20</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p> 题目要求我们每个位置上的系数只能为一,因为进制数都是可以看作带权展开的，如十进制数：921， 9<em>10^2 + 2</em>10^1 + 1*10^0，这里的921就是按权展开的系数<br> 数位dp甚至是所有dp问题主要问题都是的在于分类讨论或者划分<br> 数位dp问题的划分（看成一颗树状会更好的划分问题)左分支位0~an-1, 右分支是an,所以一般是要结合当前位置的限位数来的填树的，然后把左右分支的所有的情况加起来就是我们所求的方案总数。<br>对于本题的填数<br>当前位置如果为0的情况：那么这位置上只能有右分支且为0（为了方便统一形式把填0的情况都统一在左分支上）<br>当前位置如果为1的情况，左分支只能填0，右分支填1<br>当前位置如果&gt;1的情况，同上。</p>
<p>实在不理解可以看<a href="https://lishizheng.blog.csdn.net/article/details/113665599">这位同学的博客</a></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l,r,K,B;</span><br><span class="line"><span class="type">int</span> C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理C(i,j) = C(i-1, j) + C(i-1, j-1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!j) C[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> C[i][j] = C[i<span class="number">-1</span>][j<span class="number">-1</span>] + C[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="comment">// 把x数值转换成B进制，倒着存放进数组内部</span></span><br><span class="line">    <span class="keyword">while</span>(x) nums.<span class="built_in">pb</span>(x%B), x /= B;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;    <span class="comment">// 表示[0,r]上有多少个合法的数</span></span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>;   <span class="comment">// 在本题记录的是从当前位置之前出现1的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = nums[i];</span><br><span class="line">        <span class="comment">// 题目要求我们每个位置上的系数只能为一（因为进制数都是可以看作带权展开的，如十进制数：921， 9*10^2 + 2*10^1 + 1*10^0，这里的921就是按权展开的系数)</span></span><br><span class="line">        <span class="comment">// 数位dp甚至是所有dp问题主要问题都是的在于分类讨论或者划分</span></span><br><span class="line">        <span class="comment">// 数位dp问题的划分（看成一颗树状会更好的划分问题)左分支位0~an-1, 右分支是an</span></span><br><span class="line">        <span class="comment">// 因为每位上只能填0/1,我们要需要结合限位数来讨论</span></span><br><span class="line">        <span class="comment">// 当这一位上的数是0（&lt;1)，那我们这一位就只能填0，如果这一位上的数&gt;=1,那么这一位如果填0，后面的数随便填，如果这一位数上填一，后面的数还需要重新再讨论（重复上面的讨论）</span></span><br><span class="line">        <span class="keyword">if</span>(x)   <span class="comment">// 左边分支</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 首先这一位上一定是可以放上的是0，所以应该是后面这么多位上可以选这K-last个1</span></span><br><span class="line">            res += C[i][K - last];</span><br><span class="line">            <span class="keyword">if</span>(x &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="comment">// 当前位填1，从剩下的所有位（共有i位）中选K-last-1个数 </span></span><br><span class="line">                <span class="keyword">if</span>(K - last - <span class="number">1</span> &gt;= <span class="number">0</span>) res += C[i][K - last - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 表示如果x&gt;1的话就应该是分类讨论右分支(右分支是要等于an的，但是an大于一，又因为本题的要求系数只能为0/1，所以x&gt;1是不存在右分支的状况所以要剪枝break掉)</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">// x == 1</span></span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="comment">// 表示当前位填一</span></span><br><span class="line">                last ++;</span><br><span class="line">                <span class="keyword">if</span>(last &gt; K) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!i &amp;&amp; last == K) res ++; <span class="comment">// 最右侧分支上的方案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r &gt;&gt; K &gt;&gt; B;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp(r)表示的前r个数里有多少个满足条件的</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">dp</span>(r) - <span class="built_in">dp</span>(l<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模版</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>模版</tag>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2022/07/27/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>树状数组是一个简化版的线段树，其利用二进制数的特性，解决区间查询（主要是区间和查询），以及单点修改操作问题。</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p> <img src="../../themes/butterfly/source/img/树状数组概念.png" alt="树状数组概念"></p>
<ol>
<li>树状数组的下标可以表示出其区间长度是多少。<br>如 4 = 0100 lowbit是最低有效位表示的值, lowbit(4) = 4也就是说其表示的区间为[1,4]<br>再比如 5 = 0101 lowbit(5) = 1也就是其表示的区间为[5,5]<br>所以要求其的前缀和就要涉及到其前驱节点，那么修改某个点必然会影响到其他区间所以就要设计的后继节点的概念</li>
<li>直接前驱 c[i] -&gt; c[i - lowbit(i)]</li>
<li>直接后继 c[i] -&gt; c[i + lowbit(i)]</li>
<li>查询前i个位置的前缀和，那么就要将所有的c[i]前驱节点都加起来</li>
<li>要想修改第i个位置的数值，那么就需要讲所有c[i]后继节点都修改</li>
</ol>
<h3 id="AcWing-241-楼兰图腾"><a href="#AcWing-241-楼兰图腾" class="headerlink" title="AcWing 241. 楼兰图腾"></a><a href="https://www.acwing.com/problem/content/243/">AcWing 241. 楼兰图腾</a></h3><p>在完成了分配任务之后，西部 314 来到了楼兰古城的西部。<br>相传很久以前这片土地上(比楼兰古城还早)生活着两个部落，一个部落崇拜尖刀(V)，一个部落崇拜铁锹(∧)，他们分别用 V 和 ∧ 的形状来代表各自部落的图腾。<br>西部 314 在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了 n 个点，经测量发现这 n 个点的水平位置和竖直位置是两两不同的。<br>西部 314 认为这幅壁画所包含的信息与这 n 个点的相对位置有关，因此不妨设坐标分别为 (1,y1),(2,y2),…,(n,yn)，其中 y1∼yn 是 1 到 n 的一个排列。<br>西部 314 打算研究这幅壁画中包含着多少个图腾。<br>如果三个点 (i,yi),(j,yj),(k,yk) 满足 1≤i<j<k≤n 且 yi>yj,yj<yk，则称这三个点构成`V`图腾;
如果三个点 (i,yi),(j,yj),(k,yk) 满足 1≤i<j<k≤n 且 yi<yj,yj>yk，则称这三个点构成 <code>∧</code> 图腾;<br>西部 314 想知道，这 n 个点中两个部落图腾的数目。<br>因此，你需要编写一个程序来求出 V 的个数和 ∧ 的个数。</p>
<p>输入格式<br>第一行一个数 n。<br>第二行是 n 个数，分别代表 y1，y2,…,yn。</p>
<p>输出格式<br>两个数，中间用空格隔开，依次为 V 的个数和 ∧ 的个数。</p>
<p>数据范围<br>对于所有数据，n≤200000，且输出答案不会超过 int64。<br>y1∼yn 是 1 到 n 的一个排列。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 5 3 2 4</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我们可以讲几何问题转换成代数问题，比如<code>V</code> 也就是我们需要找到一组<code>(i,j,k)</code>, <code>i&gt;=j</code>, <code>k &gt;=j</code>这样的三元组,所以我们需要设置Greater[i],表示第i个位置前面和后面的有多少个数比我们当前第i个位置数值为a[i]的数要大，最后根据乘法原理来匹配（左边任何一个比j要大的树都可以的与右边任何一个比j要大的数匹配）左右两边的数相乘就好。</p>
<p>建立树状数组，我们树状数组内部记录的是某个数值在原数组出现的次数<br>比如add（y,1)表示数值为<code>y</code>在我们坐标轴为<code>y</code>的上面出现次数加一，边建树，边查询我们就可以知道在某个位置之前出现数值的次数的</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> Greater[N], lower[N];</span><br><span class="line"><span class="type">int</span> tr[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取最低有效位置（表示其区间能表示的长度）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在x位置上加上c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x;i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前1～x的前缀和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Greater[i]表示的i的左右比a[i]要大的数的个数</span></span><br><span class="line">    <span class="comment">// 同理lower</span></span><br><span class="line">    <span class="comment">// 现在先计算数值为y的左边比他大（小）的数的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = a[i];</span><br><span class="line">        <span class="comment">// sum(n) - sum(y) 表示数值在[y,n],我们原数组内出现的个数</span></span><br><span class="line">        Greater[i] = <span class="built_in">sum</span>(n) - <span class="built_in">sum</span>(y); </span><br><span class="line">        lower[i] = <span class="built_in">sum</span>(y<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">add</span>(y,<span class="number">1</span>);   <span class="comment">// 将y这个数值加入的树状数组当中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="keyword">sizeof</span> tr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i; i --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = a[i];</span><br><span class="line">        res1 += Greater[i] * ((ll)(<span class="built_in">sum</span>(n) - <span class="built_in">sum</span>(y)));</span><br><span class="line">        res2 += lower[i] * (ll)<span class="built_in">sum</span>(y<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">add</span>(y,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,res1, res2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模版</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>树的直径</title>
    <url>/2022/07/15/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><h3 id="算法一-两次dfs"><a href="#算法一-两次dfs" class="headerlink" title="算法一 两次dfs"></a>算法一 两次dfs</h3><p>一次dfs求该点的最长距离，第二次从上一个最长路径的另一个端点再一次求解最长路径</p>
<h3 id="算法二-树形dp"><a href="#算法二-树形dp" class="headerlink" title="算法二 树形dp"></a>算法二 树形dp</h3><p>任意选择一个点u，以u为根节点找其的最长路径和最短路径。这两条路径就构造出我们的树的直径。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],w[N],idx;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father)</span>  <span class="comment">// 返回的是以u为根节点的的树的最长路</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 我们每次枚举都是以u这个节点为最高点(根节点）找其作为根的树的直径</span></span><br><span class="line">    <span class="type">int</span> dist = <span class="number">0</span>; <span class="comment">//从这个点开始往下找的最长路径</span></span><br><span class="line">    <span class="type">int</span> d1 = <span class="number">0</span>, d2 = <span class="number">0</span>; <span class="comment">// d1为最长路径 d2为次长路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == father) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">dfs</span>(j,u) + w[i];</span><br><span class="line">        dist = <span class="built_in">max</span>(dist,d);</span><br><span class="line">        <span class="comment">// 用其子节点的子树的树的直径更新 父节点作为根节点的树的直径</span></span><br><span class="line">        <span class="keyword">if</span>(d &gt;= d1) d2 = d1, d1 = d;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d &gt; d2) d2 = d;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, d1 + d2);</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    m = n<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span> ,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>树的直径</tag>
        <tag>知识点笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>次小生成树</title>
    <url>/2022/07/14/%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h2 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h2><h3 id="定义：给定一个带权的图，把图的所有生成树按权值从小到大排序，第二小的称为次小生成树"><a href="#定义：给定一个带权的图，把图的所有生成树按权值从小到大排序，第二小的称为次小生成树" class="headerlink" title="定义：给定一个带权的图，把图的所有生成树按权值从小到大排序，第二小的称为次小生成树"></a>定义：给定一个带权的图，把图的所有生成树按权值从小到大排序，第二小的称为次小生成树</h3><p><strong>非严格次小生成树的权值 &gt;= 最小生成树</strong><br><strong>严格次小生成树的权值 &gt; 最小生成树</strong>   </p>
<h3 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h3><p><strong>方法一</strong>：先求最小生成树，再枚举删去最小生成树中的边求解。<em>要注意</em>本方法不能求解严格次小生成树。 时间复杂度为O(mlogm + nm)<br><strong>方法二</strong>：先求最小生成树，然后依次枚举非树边，然后将改变加入树中，同时从树中去掉一条边，使得最终的图仍是一颗树。则最后一定会得到一颗次小生成树。</p>
<p>方法二的证明。我们在最小生成树上加入一条非树边一定会形成一个环，由于我们的kruskal算法选择策略是按不连通块之间最小边来选，所以当前加入的这一条非树边一定是&gt;=环上的任意一条边的。如果加入的这一条非树边严格&gt;环上的任意一条边，那么最后我们可以得到一颗严格次小生成树，否则为非严格次小生成树。</p>
<p>定理：次小生成树一定在最小生成树的邻集中。// 也就是说一定有一颗次小生成树（无论严格次小还是非严格）仅与最小生成树差一条边</p>
<h3 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h3><p><strong>这里主要是对方法二</strong>  </p>
<ol>
<li>求最小生成树，统计标记每条边是树边还是非树边；同时把最小生成树建立出来</li>
<li>预处理人任意两点间的边权最大值</li>
<li>一次枚举所有非树边，求min(sum + w - dist[a][b])，满足w &gt; dist[a][b] </li>
</ol>
<h3 id="例题-秘密的牛奶运输"><a href="#例题-秘密的牛奶运输" class="headerlink" title="例题  秘密的牛奶运输"></a>例题  <a href="https://www.acwing.com/problem/content/1150/">秘密的牛奶运输</a></h3><p>农夫约翰要把他的牛奶运输到各个销售点。</p>
<p>运输过程中，可以先把牛奶运输到一些销售点，再由这些销售点分别运输到其他销售点。</p>
<p>运输的总距离越小，运输的成本也就越低。</p>
<p>低成本的运输是农夫约翰所希望的。</p>
<p>不过，他并不想让他的竞争对手知道他具体的运输方案，所以他希望采用费用第二小的运输方案而不是最小的。</p>
<p>现在请你帮忙找到该运输方案。</p>
<p>注意：：</p>
<p>如果两个方案至少有一条边不同，则我们认为是不同方案；<br>费用第二小的方案在数值上一定要严格大于费用最小的方案；<br>答案保证一定有解；<br>输入格式<br>第一行是两个整数 N,M，表示销售点数和交通线路数；</p>
<p>接下来 M 行每行 3 个整数 x,y,z，表示销售点 x 和销售点 y 之间存在线路，长度为 z。</p>
<p>输出格式<br>输出费用第二小的运输方案的运输总距离。</p>
<p>数据范围<br>1≤N≤500,<br>1≤M≤104,<br>1≤z≤109,<br>数据中可能包含重边。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 2 100</span><br><span class="line">2 4 200</span><br><span class="line">2 3 250</span><br><span class="line">3 4 100</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">450</span><br></pre></td></tr></table></figure></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><h4 id="朴素版本（可以在求-a-b-上的最大边作优化，这里是朴素版本所以使用的是dfs）"><a href="#朴素版本（可以在求-a-b-上的最大边作优化，这里是朴素版本所以使用的是dfs）" class="headerlink" title="朴素版本（可以在求(a,b)上的最大边作优化，这里是朴素版本所以使用的是dfs）"></a>朴素版本（可以在求(a,b)上的最大边作优化，这里是朴素版本所以使用的是dfs）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span>x</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> h[N], e[N * <span class="number">2</span>], ne[N * <span class="number">2</span>], w[N * <span class="number">2</span>], idx;</span><br><span class="line"><span class="type">int</span> d1[N][N], d2[N][N]; <span class="comment">//d1表示a到b上的这个最长树边，d2表示次长树边</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> f; <span class="comment">// 标记这条边是否在树边</span></span><br><span class="line">    <span class="type">bool</span> operator &lt;(<span class="type">const</span> edge &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;eg[M];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] != x) f[x] = find(f[x]);</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maxd1到u节点最长树边，同理maxd2， 这里的d1[]是对d1[i][]的二维操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father, <span class="type">int</span> maxd1, <span class="type">int</span> maxd2, <span class="type">int</span> d1[], <span class="type">int</span> d2[])</span></span><br><span class="line">&#123;</span><br><span class="line">    d1[u] = maxd1, d2[u] = maxd2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="type">int</span> v = w[i];</span><br><span class="line">        <span class="keyword">if</span>(j != father)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nd1 = maxd1, nd2 = maxd2;</span><br><span class="line">            <span class="comment">// v等于最大值的时候不要更新，最大值和次大值相等的情况是没有意义的</span></span><br><span class="line">            <span class="keyword">if</span>(v &gt; nd1) nd2 = nd1, nd1 = v;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v &gt; nd2 &amp;&amp; v &lt; nd1) nd2 = v;</span><br><span class="line">            dfs(j,u,nd1,nd2,d1,d2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// build</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        eg[i] = &#123;a,b,c, <span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) f[i] = i;</span><br><span class="line">    sort(eg, eg + m);</span><br><span class="line">    <span class="comment">// kruskal</span></span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = eg[i].a, b = eg[i].b, w = eg[i].w;</span><br><span class="line">        <span class="comment">//因为我们需要在构造最小生成树的情况下同时建图，所以切记使用a=find(a)</span></span><br><span class="line">        <span class="type">int</span> pa = find(a), pb = find(b);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb)</span><br><span class="line">        &#123;</span><br><span class="line">            f[pa] = pb;</span><br><span class="line">            sum += w;</span><br><span class="line">            eg[i].f = <span class="literal">true</span>;</span><br><span class="line">            add(a,b,w);</span><br><span class="line">            add(b,a,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// init d1[],d2[]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) dfs(i,<span class="number">-1</span>,<span class="number">-1e9</span>,<span class="number">-1e9</span>,d1[i],d2[i]);</span><br><span class="line"></span><br><span class="line">    LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!eg[i].f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = eg[i].a, b = eg[i].b, v = eg[i].w;</span><br><span class="line">            <span class="comment">// 这里是严格次小生成树</span></span><br><span class="line">            <span class="comment">// 非严格在这里变化</span></span><br><span class="line">            LL t;</span><br><span class="line">            <span class="keyword">if</span>(v &gt; d1[a][b]) t = sum + v - d1[a][b];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v &gt; d2[a][b]) t = sum + v - d2[a][b];</span><br><span class="line">            res = min(res, t);  <span class="comment">//最好使得两边都是相同的类型</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化版本（待续）"><a href="#优化版本（待续）" class="headerlink" title="优化版本（待续）"></a>优化版本（待续）</h4>]]></content>
      <categories>
        <category>模版</category>
        <category>图论</category>
        <category>次小生成树</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>图论模版</tag>
        <tag>次小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 - P4147 玉蟾宫</title>
    <url>/2022/07/16/%E6%B4%9B%E8%B0%B7-P4147-%E7%8E%89%E8%9F%BE%E5%AE%AB/</url>
    <content><![CDATA[<h2 id="玉蟾宫"><a href="#玉蟾宫" class="headerlink" title="玉蟾宫"></a><a href="https://vjudge.net/problem/%E6%B4%9B%E8%B0%B7-P4147">玉蟾宫</a></h2><p>有一天，小猫 rainbow 和 freda 来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。</p>
<p>Description<br>这片土地被分成 N\times MN×M 个格子，每个格子里写着 ‘R’ 或者 ‘F’，R 代表这块土地被赐予了 rainbow，F 代表这块土地被赐予了 freda。</p>
<p>现在 freda 要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着 ‘F’ 并且面积最大。</p>
<p>但是 rainbow 和 freda 的 OI 水平都弱爆了，找不出这块土地，而蓝兔也想看 freda 卖萌（她显然是不会编程的……），所以它们决定，如果你找到的土地面积为 SS，它们每人给你 SS 两银子。</p>
<p>Input<br>第一行两个整数 NN，MM，表示矩形土地有 NN 行 MM 列。</p>
<p>接下来 NN 行，每行 MM 个用空格隔开的字符 <code>F</code> 或 <code>R</code>，描述了矩形土地。</p>
<p>Output<br>输出一个整数，表示你能得到多少银子，即 （3×最大 <code>F</code> 矩形土地面积) 的值。</p>
<p>Sample<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 6 </span><br><span class="line">R F F F F F </span><br><span class="line">F F F F F F </span><br><span class="line">R R R F F F </span><br><span class="line">F F F F F F </span><br><span class="line">F F F F F F</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">45</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>枚举每一行，每一个的每一个位置连续F的最高高度，在每一行都做一次直方图最大面积<br>用dp[i][j] 记录（i,j)这个点往上的最高高度，如果（i，j）这个点存放的字符是<code>F</code>的话，那么dp[i][j] = dp[i-1][j] + 1,如果这个点存放的数据不是<code>F</code>的话那么dp[i][j] = 0</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> mp[N][N];</span><br><span class="line"><span class="type">int</span> st[N],l[N],r[N];  <span class="comment">// 每一行往上都可以构造成一个直方图最大矩阵问题，所以在这记录的是单调增</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dp[N][N];   <span class="comment">// 枚举每一行的每一个位置看这个位置往上有多少个连续的F</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> c;<span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">            mp[i][j] = c;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;F&#x27;</span>) dp[i][j] = dp[i<span class="number">-1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 单调栈处理当前这行往上的矩形最大面积问题</span></span><br><span class="line">        <span class="type">int</span> hh = <span class="number">0</span>; st[hh] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(hh &amp;&amp; dp[i][st[hh]] &gt;= dp[i][j]) hh --;</span><br><span class="line">            l[j] = st[hh] + <span class="number">1</span>;</span><br><span class="line">            st[++hh] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hh = <span class="number">0</span>, st[hh] = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">1</span>; j --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(hh &amp;&amp; dp[i][st[hh]] &gt;= dp[i][j]) hh --;</span><br><span class="line">            r[j] = st[hh] - <span class="number">1</span>;</span><br><span class="line">            st[++hh] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = (r[j] - l[j] + <span class="number">1</span>) * dp[i][j];</span><br><span class="line">            res = max(res, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res * <span class="number">3</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>移掉K位数字</title>
    <url>/2022/07/15/%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="移掉K位数字"><a href="#移掉K位数字" class="headerlink" title="移掉K位数字"></a><a href="https://www.acwing.com/problem/content/1455/">移掉K位数字</a></h2><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p>
<p>注意：</p>
<p>空字符串被视为0。<br>如果结果中包含前导零，则需要将前导零删除，最后删除的前导零不用包含在移除的 k 个数字中。<br>输入格式<br>第一行输入一个字符串，用来表示非负整数 num。</p>
<p>第二行输入一个整数，表示 k。</p>
<p>输出格式<br>输出一个字符串，表示移除 k 位数字后所能得到的最小数字。</p>
<p>数据范围<br>0≤k≤ 字符串长度 ≤100000，<br>num 中不包含任何前导 0。</p>
<p>输入样例1：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1432219</span><br><span class="line">3</span><br></pre></td></tr></table></figure><br>输出样例1：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1219</span><br></pre></td></tr></table></figure><br>样例1解释<br>移除掉三个数字 4,3,2 可形成一个新的最小的数字 1219。</p>
<p>输入样例2：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10200</span><br><span class="line">1</span><br></pre></td></tr></table></figure><br>输出样例2：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200</span><br></pre></td></tr></table></figure><br>样例2解释：<br>移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</p>
<p>输入样例3：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">2</span><br></pre></td></tr></table></figure><br>输出样例3：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><br>样例3解释<br>从原数字移除所有的数字，剩余为空就是 0。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为输出数的数的为数是确定的 == n-k 位，所以最高位越小对于整个的数值就越小，这里可以结合带权展开<br>所以我们需要使用一个单调栈来构造一个递增序列<br>还要注意的一些细节<br>全部删除输出 0<br>单调栈里面全部为0是保留一位0<br>如果这个数不是全为0，前面的0就是前导0，所以要全部去掉，这里可以使用i &lt; n来判断</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ;i ++) <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>; st[hh] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> ck = k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(hh &amp;&amp; st[hh] &gt; s[i] &amp;&amp; ck)</span><br><span class="line">        &#123;</span><br><span class="line">            hh--,ck --;</span><br><span class="line">        &#125;</span><br><span class="line">        st[++hh] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有删完的情况ck&gt;0,因为没有删完的元素全部入栈了，所以我们需要从栈顶开始退栈</span></span><br><span class="line">    <span class="keyword">while</span>(ck --) hh--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n-k == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(st[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; i &lt; hh) i ++;  <span class="comment">// 删去前导0，全是0的情况但是至少要保留一个0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= hh; j ++) <span class="built_in">cout</span> &lt;&lt; st[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2022/07/25/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>线段树主要是用来动态维护并且对区间进行操作的，因为题目可能要求边操作边进行查询。<br>对于线段树题目主要考验的是代码能力以及使用变量去维护我们需要查询的信息。所以应当多写多练代码。</p>
<p>下面三道题目有且仅涉及到了单点操作，区间查询<br>pushup子节点更新父亲节点<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用子节点来更新父节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].v = <span class="built_in">max</span>(tr[u &lt;&lt; <span class="number">1</span>].v, tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>modify单点操作<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x表示要在x之后加入一个数据v</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 根节点的就返回(根节点的就是我们要修改的那个单点)</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == x &amp;&amp; tr[u].r == x)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].v = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不是根节点，那么这个节点就是父节点，那么继续递归找到根节点，然后用子节点来更新我们的父节点。</span></span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);  <span class="comment">// 操作完了区间就需要对区间维护的属性进行更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>query区间查询<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 查询区间主要包含的了两种情况</span></span><br><span class="line">    <span class="comment">// 1. 当前区间完全包含在了我们要查询的区间当中也就是ql &lt;= l &lt;= r &lt;= qr</span></span><br><span class="line">    <span class="comment">// 2. 当前区间与查询区间有交集 ql &lt;= l &lt;= qr &lt;= r （不等式的等号不同事成立）</span></span><br><span class="line">    <span class="comment">// 因为递归是二叉树形式递归所以我们要讨论端点和中值之间的关系</span></span><br><span class="line">    <span class="comment">// 2.1 l &lt;= mid, 那么就需要的查找当前区间的左孩子区间和当前区间的右孩子区间，反之只需要查找当前区间右孩子区间</span></span><br><span class="line">    <span class="comment">// 2.2 r &gt;= mid + 1 那么就需要的查找当前区间的左孩子区间和当前区间的右孩子区间，反之只需要查找当前区间左孩子区间</span></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;   <span class="comment">// mid是当前我们要查询的节点u的中值</span></span><br><span class="line">    <span class="comment">// 当前区间被完全包含在我们要查询的区间当中</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].v;</span><br><span class="line">    <span class="comment">// 有交集</span></span><br><span class="line">    <span class="type">int</span> v = <span class="number">-1</span>; <span class="comment">// 保存是孩子节点的最大值</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) v = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);    <span class="comment">// 要注意这里接口是[l,r]而不是[l,mid],因为我们始终要查询的是[l,r]区间,而不是孩子节点的区间端点</span></span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) v = <span class="built_in">max</span>(v,<span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="AcWing-1275-最大数"><a href="#AcWing-1275-最大数" class="headerlink" title="AcWing 1275. 最大数"></a><a href="https://www.acwing.com/problem/content/1277/">AcWing 1275. 最大数</a></h3><p>给定一个正整数数列 a1,a2,…,an，每一个数都在 0∼p−1 之间。</p>
<p>可以对这列数进行两种操作：</p>
<p>添加操作：向序列后添加一个数，序列长度变成 n+1；<br>询问操作：询问这个序列中最后 L 个数中最大的数是多少。<br>程序运行的最开始，整数序列为空。</p>
<p>一共要对整数序列进行 m 次操作。</p>
<p>写一个程序，读入操作的序列，并输出询问操作的答案。</p>
<p>输入格式<br>第一行有两个正整数 m,p，意义如题目描述；</p>
<p>接下来 m 行，每一行表示一个操作。</p>
<p>如果该行的内容是 Q L，则表示这个操作是询问序列中最后 L 个数的最大数是多少；</p>
<p>如果是 A t，则表示向序列后面加一个数，加入的数是 (t+a) mod p。其中，t 是输入的参数，a 是在这个添加操作之前最后一个询问操作的答案（如果之前没有询问操作，则 a=0）。</p>
<p>第一个操作一定是添加操作。对于询问操作，L&gt;0 且不超过当前序列的长度。</p>
<p>输出格式<br>对于每一个询问操作，输出一行。该行只有一个数，即序列中最后 L 个数的最大数。</p>
<p>数据范围<br>1≤m≤2×105,<br>1≤p≤2×109,<br>0≤t<p
输入样例：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 100</span><br><span class="line">A 97</span><br><span class="line">Q 1</span><br><span class="line">Q 1</span><br><span class="line">A 17</span><br><span class="line">Q 2</span><br><span class="line">A 63</span><br><span class="line">Q 1</span><br><span class="line">Q 1</span><br><span class="line">Q 3</span><br><span class="line">A 99</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">97</span><br><span class="line">97</span><br><span class="line">97</span><br><span class="line">60</span><br><span class="line">60</span><br><span class="line">97</span><br></pre></td></tr></table></figure><br>样例解释<br>最后的序列是 97,14,60,96。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>板题</strong><br>用一个变量维护我们需要查询的属性</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r; <span class="comment">// 表示区间的左端点和右端点</span></span><br><span class="line">    <span class="type">int</span> v;  <span class="comment">// 基本属性（本题是求的是最大值那我们就需要使用v表示区间的最大值来维护区间属性，有的属性并不能有单一的变量来维护则要多添加几个变脸来维护</span></span><br><span class="line">    <span class="comment">// node()&#123;&#125;</span></span><br><span class="line">    <span class="comment">// node(int l, int r):l(l),r(r),v(-1)&#123;&#125;</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>]; <span class="comment">// 线段树的节点个数开4倍</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u] = &#123;l,r&#125;;  <span class="comment">// 一定要把值先存起来，切忌不能放在return后面再保存值</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;   <span class="comment">// 线段树是一颗完全二叉树，其区间也划分的十分的均匀（正因为这种划分才使得所有的父节点一定有两个子节点）</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;  <span class="comment">// 根节点就要返回</span></span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);   <span class="comment">// 完全二叉树的属性 根节点从一开始编号，左孩子编号就是父节点编号的两倍，右孩子就是父节点的编号两倍加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 查询区间主要包含的了两种情况</span></span><br><span class="line">    <span class="comment">// 1. 当前区间完全包含在了我们要查询的区间当中也就是ql &lt;= l &lt;= r &lt;= qr</span></span><br><span class="line">    <span class="comment">// 2. 当前区间与查询区间有交集 ql &lt;= l &lt;= qr &lt;= r （不等式的等号不同事成立）</span></span><br><span class="line">    <span class="comment">// 因为递归是二叉树形式递归所以我们要讨论端点和中值之间的关系</span></span><br><span class="line">    <span class="comment">// 2.1 l &lt;= mid, 那么就需要的查找当前区间的左孩子区间和当前区间的右孩子区间，反之只需要查找当前区间右孩子区间</span></span><br><span class="line">    <span class="comment">// 2.2 r &gt;= mid + 1 那么就需要的查找当前区间的左孩子区间和当前区间的右孩子区间，反之只需要查找当前区间左孩子区间</span></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;   <span class="comment">// mid是当前我们要查询的节点u的中值</span></span><br><span class="line">    <span class="comment">// 当前区间被完全包含在我们要查询的区间当中</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].v;</span><br><span class="line">    <span class="comment">// 有交集</span></span><br><span class="line">    <span class="type">int</span> v = <span class="number">-1</span>; <span class="comment">// 保存是孩子节点的最大值</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) v = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);    <span class="comment">// 要注意这里接口是[l,r]而不是[l,mid],因为我们始终要查询的是[l,r]区间,而不是孩子节点的区间端点</span></span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) v = <span class="built_in">max</span>(v,<span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用子节点来更新父节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].v = <span class="built_in">max</span>(tr[u &lt;&lt; <span class="number">1</span>].v, tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本题是修改（增加）某个区间中的一个值来影响区间max属性，当根究还是单点操作，所以单点操作也就是把其包含这个点的所有区间都做一遍操作是logn的</span></span><br><span class="line"><span class="comment">// x表示要在x之后加入一个数据v</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 根节点的就返回(根节点的就是我们要修改的那个单点)</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == x &amp;&amp; tr[u].r == x)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].v = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不是根节点，那么这个节点就是父节点，那么继续递归找到根节点，然后用子节点来更新我们的父节点。</span></span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);  <span class="comment">// 操作完了区间就需要对区间维护的属性进行更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, last = <span class="number">0</span>;    <span class="comment">// n表示数据量/当前序列尾部的位置（因为每次都需要在序列尾部加入数据）, last记录的上个数据每次加上的数据 == (t + a) % p</span></span><br><span class="line">    <span class="type">int</span> m, p;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,m);   <span class="comment">// 由于有m个操作，最极限的情况下每个操作都是加一个数，那么我们的区间右端点的最大为m</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            last = <span class="built_in">query</span>(<span class="number">1</span>,n-x+<span class="number">1</span>, n);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,last);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = ((ll)last + x ) % p;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, n + <span class="number">1</span>, v);</span><br><span class="line">            n ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AcWing-245-你能回答这些问题吗"><a href="#AcWing-245-你能回答这些问题吗" class="headerlink" title="AcWing 245. 你能回答这些问题吗"></a><a href="https://www.acwing.com/problem/content/246/">AcWing 245. 你能回答这些问题吗</a></h3><p>给定长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：</p>
<p>1 x y，查询区间 [x,y] 中的最大连续子段和，即 maxx≤l≤r≤y{∑i=lrA[i]}。<br>2 x y，把 A[x] 改成 y。<br>对于每个查询指令，输出一个整数表示答案。</p>
<p>输入格式<br>第一行两个整数 N,M。</p>
<p>第二行 N 个整数 A[i]。</p>
<p>接下来 M 行每行 3 个整数 k,x,y，k=1 表示查询（此时如果 x&gt;y，请交换 x,y），k=2 表示修改。</p>
<p>输出格式<br>对于每个查询指令输出一个整数表示答案。</p>
<p>每个答案占一行。</p>
<p>数据范围<br>N≤500000,M≤100000,<br>−1000≤A[i]≤1000<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">1 2 -3 4 5</span><br><span class="line">1 2 3</span><br><span class="line">2 2 -1</span><br><span class="line">1 3 2</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure></p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><ol>
<li>题目操作二告诉本题是单点操作是不需要懒标记的</li>
<li>如果使用子节点来更新父节点，也就是用什么变量来维护最大子段和</li>
</ol>
<p>首先一定需要的保存区间的最大连续子段和tmax，但是单使用两个子区间的tmax来更新父区间tmax是远远不过的。因为父区间的tmax不单单是可能等于左孩子的tmax或者右孩子tmax，还有可能子段和是横跨左右两个区间的。所以还需要最大前缀和与最大的后缀和。但是问题又来了仅靠当前的变量足够更新我们所有的属性吗？？比如前缀和的更新问题。区间的前缀和 == max(left.lmax, right.lmax) ?? 显然不是，区间的前缀和是可以延伸到有区间上去的，所以 lmax = max(left.lmax, left.sum + right.lmax)，所以还需要增加一个变量区间的总和。<br>所以我们一个区间节点要保存 <code>sum</code> <code>lmax</code> <code>rmax</code> <code>tmax</code>四个变量来更新我们需要查询的<code>最大子段和</code></p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="comment">// 维护区间子段和最大</span></span><br><span class="line">    <span class="type">int</span> sum, lmax, rmax, tmax;  <span class="comment">// sum区间和 lmax前缀和最大 rmax后缀和最大 tmax区间和最大</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N];   <span class="comment">// 记录每个点的数值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(node &amp;u, node &amp;l, node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;</span><br><span class="line">    u.lmax = <span class="built_in">max</span>(l.lmax, l.sum + r.lmax);</span><br><span class="line">    u.rmax = <span class="built_in">max</span>(r.rmax, r.sum + l.rmax);</span><br><span class="line">    u.tmax = <span class="built_in">max</span>(<span class="built_in">max</span>(l.tmax,r.tmax), l.rmax + r.lmax); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l == r) </span><br><span class="line">        tr[u] = &#123;l, r, w[r], w[r], w[r], w[r]&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l,r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        node res;</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="built_in">pushup</span>(res, left, right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == x &amp;&amp; tr[u].r == x)</span><br><span class="line">        tr[u] = &#123;x,x,v,v,v,v&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) </span><br><span class="line">            <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">if</span>(x &gt; mid)</span><br><span class="line">            <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="type">int</span> op , a, b;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a &gt; b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">            node res = <span class="built_in">query</span>(<span class="number">1</span>,a,b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res.tmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AcWing-246-区间最大公约数"><a href="#AcWing-246-区间最大公约数" class="headerlink" title="AcWing 246. 区间最大公约数"></a><a href="https://www.acwing.com/problem/content/247/">AcWing 246. 区间最大公约数</a></h3><p>给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：</p>
<p>C l r d，表示把 A[l],A[l+1],…,A[r] 都加上 d。<br>Q l r，表示询问 A[l],A[l+1],…,A[r] 的最大公约数(GCD)。<br>对于每个询问，输出一个整数表示答案。</p>
<p>输入格式<br>第一行两个整数 N,M。</p>
<p>第二行 N 个整数 A[i]。</p>
<p>接下来 M 行表示 M 条指令，每条指令的格式如题目描述所示。</p>
<p>输出格式<br>对于每个询问，输出一个整数表示答案。</p>
<p>每个答案占一行。</p>
<p>数据范围<br>N≤500000,M≤100000,<br>1≤A[i]≤1018,<br>|d|≤1018<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 3 5 7 9</span><br><span class="line">Q 1 5</span><br><span class="line">C 1 5 1</span><br><span class="line">Q 1 5</span><br><span class="line">C 3 3 6</span><br><span class="line">Q 2 4</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>操作一看似是一个区间操作问题但是如果使用差分数组的话，我们可以将其转化为单点操作</p>
<h4 id="一、将区间操作转换成了单点操作"><a href="#一、将区间操作转换成了单点操作" class="headerlink" title="一、将区间操作转换成了单点操作"></a>一、将区间操作转换成了单点操作</h4><p>原数组为 a1 a2 a3 a4 … an<br>前缀和数组 为 s1 s2 s3 s4 … sn<br>差分数组为 d1 d2 d3 d4 … dn = s1， s2 - s1, s3 - s2, … , sn - sn-1<br>sum[l,r] = dr + dr<br>假如要想在[l,r]区间加上一个d = dl + d, dr+1 - d</p>
<h4 id="二、gcd更相减损法"><a href="#二、gcd更相减损法" class="headerlink" title="二、gcd更相减损法"></a>二、gcd更相减损法</h4><p> gcd(a, b) = gcd(a, b - a)<br> 推广成为gcd(a1, a2, a3, … , an) = gcd(a1, a2 - a1, a3 - a2, …, an - an-1)<br> 这样就可以与差分数组结合在一起</p>
<p> 证明更相减损法的正确性<br> 首先证明<code>gcd(a1, a2, a3, ... , an)</code> &lt;= <code>gcd(a1, a2 - a1, a3 - a2, ..., an - an-1)</code><br> <code>gcd(a1, a2, a3, ... , an)</code> == <code>d</code>, <code>d</code>是这个序列的最大公约数所以一定也是<code>a1</code> <code>a2</code> <code>a3</code>…的公约数，那么<code>d</code>同理也是<code>a2-a1</code> <code>a3 - a2</code> …的公约数，所以知道左边序列的最大公约数是右边序列的任意一个公约数，所以证得<code>gcd(a1, a2, a3, ... , an)</code> &lt;= <code>gcd(a1, a2 - a1, a3 - a2, ..., an - an-1)</code></p>
<p> 同理 <code>gcd(a1, a2, a3, ... , an)</code> &gt;= <code>gcd(a1, a2 - a1, a3 - a2, ..., an - an-1)</code></p>
<p>差分数组<br>a数组是b数组的前缀和数组，b是a的差分数组<br>通过gcd更相减损法维护差分数组最后可以转换为<br>gcd[l,r] = gcd(a[l], a[l+1] - a[l], … , a[r] - a[r-1]) = gcd(a[l], b[l+1], b[l+2], … , b[r]) = gcd(a[l],gcd(b[l+1], … , b[r])) = 由于线段树维护的是差分数组,a是前缀和数组，所以a[l]是我们1～l的sum = gcd(l.sum, gcd(b[l+1], … , b[r]));<br>所以pushup操作是维护的<code>gcd(b[l+1], ... , b[r])</code><br>最后我们要查询的区间最大gcd是通过<code>sum</code> + <code>gcd(b[l+1], ... , b[r])</code> 来维护</p>
<h4 id="三、维护区间属性"><a href="#三、维护区间属性" class="headerlink" title="三、维护区间属性"></a>三、维护区间属性</h4><ol>
<li>区间和sum</li>
<li>区间的最大公约数</li>
</ol>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll sum, d;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般如果使用多变量维护区间属性重载两个pushup比较方便</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(node &amp;u, node &amp;l, node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;</span><br><span class="line">    u.d = <span class="built_in">gcd</span>(l.d, r.d); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll b = a[r] - a[r<span class="number">-1</span>];</span><br><span class="line">        tr[u] = &#123;l,r,b,b&#125;;  <span class="comment">// 差分数组内部点值 a数组是b数组的前缀和数组，b是a的差分数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r;   </span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l , r);</span><br><span class="line">        node res;</span><br><span class="line">        <span class="built_in">pushup</span>(res, left, right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 修改当点 a[l] + v, a[r + 1] - v</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == x &amp;&amp; tr[u].r == x)</span><br><span class="line">    &#123;</span><br><span class="line">        ll b = tr[u].sum + v;</span><br><span class="line">        tr[u] = &#123;x,x,b,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">if</span>(x &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,l);</span><br><span class="line">            node right = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span>(l + <span class="number">1</span> &lt;= r)</span><br><span class="line">                right = <span class="built_in">query</span>(<span class="number">1</span>,l + <span class="number">1</span>, r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">abs</span>(<span class="built_in">gcd</span>(left.sum,right.d)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ll v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;v);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,v);</span><br><span class="line">            <span class="keyword">if</span>(r + <span class="number">1</span> &lt;= n) <span class="built_in">modify</span>(<span class="number">1</span>,r + <span class="number">1</span>, -v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带有区间修改的（懒标记的线段树）"><a href="#带有区间修改的（懒标记的线段树）" class="headerlink" title="带有区间修改的（懒标记的线段树）"></a>带有区间修改的（懒标记的线段树）</h3><p>区间修改当然是可以依照我们前面的单点修改去操作，也就是一遍遍的遍历到根节点，然后用根节点去更新父亲节点。时间复杂度是O（nlogn）的<br>这样子时间复杂度甚至还比O（n）要大（比暴力更大），这显然是我们不能接受的。所以才会引入懒标记（延迟标记）来应付我们的查询。懒标记的思想可以类比到我们的区间查询。<br> <img src="../../themes/butterfly/source/img/懒标记的解释.png" alt="懒标记的解释"></p>
<h3 id="AcWing-243-一个简单的整数问题2"><a href="#AcWing-243-一个简单的整数问题2" class="headerlink" title="AcWing 243.一个简单的整数问题2"></a><a href="https://www.acwing.com/problem/content/description/244/">AcWing 243.一个简单的整数问题2</a></h3><p>给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：</p>
<p>C l r d，表示把 A[l],A[l+1],…,A[r] 都加上 d。<br>Q l r，表示询问数列中第 l∼r 个数的和。<br>对于每个询问，输出一个整数表示答案。</p>
<p>输入格式<br>第一行两个整数 N,M。</p>
<p>第二行 N 个整数 A[i]。</p>
<p>接下来 M 行表示 M 条指令，每条指令的格式如题目描述所示。</p>
<p>输出格式<br>对于每个询问，输出一个整数表示答案。</p>
<p>每个答案占一行。</p>
<p>数据范围<br>1≤N,M≤105,<br>|d|≤10000,<br>|A[i]|≤109<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 5</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">Q 4 4</span><br><span class="line">Q 1 10</span><br><span class="line">Q 2 4</span><br><span class="line">C 3 6 3</span><br><span class="line">Q 2 4</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">55</span><br><span class="line">9</span><br><span class="line">15</span><br></pre></td></tr></table></figure></p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>虽然说区间加和问题可以用差分思想转换成单点操作但是我们也可以很暴力使用pushdown对区间进行操作</p>
<h3 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll w[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll sum, add;    <span class="comment">// add是区间的懒标记，表示以u为根的树给其子节点都加上一个数值add（注意不给根节点加）</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用父节点更新子节点信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].add)</span><br><span class="line">    &#123;</span><br><span class="line">        node &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">        left.sum += (left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        left.add += root.add;</span><br><span class="line">        right.sum += (right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;   <span class="comment">// 下放之后一定要清空否则会重复累加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r, tr[u].sum = w[r], tr[u].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r;  </span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 我们的懒标记是延迟标记是为了避免做无用功，所以在我们查询的操作的使用才会对其子节点的区间的懒标记进行更新</span></span><br><span class="line">    <span class="comment">// 每次从父节点到子节点的时候懒标记都下放，因为只要树要继续往下遍历的话那么说明子区间就需要被查询，所以我们懒标记下放</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line"></span><br><span class="line">        ll res = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r) + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l , r);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum += (tr[u].r - tr[u].l + <span class="number">1</span>) * d;</span><br><span class="line">        tr[u].add += d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r,d);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l , r,d);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;w[i]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> l, r ,d;</span><br><span class="line">        <span class="keyword">while</span>(m --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op, &amp;l, &amp;r);</span><br><span class="line">            <span class="keyword">if</span>(*op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,l,r));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d);</span><br><span class="line">                <span class="built_in">modify</span>(<span class="number">1</span>,l,r,d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AcWing-1277-维护序列"><a href="#AcWing-1277-维护序列" class="headerlink" title="AcWing 1277. 维护序列"></a><a href="https://www.acwing.com/problem/content/description/1279/">AcWing 1277. 维护序列</a></h3><p>老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。</p>
<p>有长为 N 的数列，不妨设为 a1,a2,…,aN。</p>
<p>有如下三种操作形式：</p>
<p>把数列中的一段数全部乘一个值；<br>把数列中的一段数全部加一个值；<br>询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模 P 的值。<br>输入格式<br>第一行两个整数 N 和 P；</p>
<p>第二行含有 N 个非负整数，从左到右依次为 a1,a2,…,aN；</p>
<p>第三行有一个整数 M，表示操作总数；</p>
<p>从第四行开始每行描述一个操作，输入的操作有以下三种形式：</p>
<p>操作 1：1 t g c，表示把所有满足 t≤i≤g 的 ai 改为 ai×c；<br>操作 2：2 t g c，表示把所有满足 t≤i≤g 的 ai 改为 ai+c；<br>操作 3：3 t g，询问所有满足 t≤i≤g 的 ai 的和模 P 的值。<br>同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。</p>
<p>输出格式<br>对每个操作 3，按照它在输入中出现的顺序，依次输出一行一个整数表示询问结果。</p>
<p>数据范围<br>1≤N,M≤105,<br>1≤t≤g≤N,<br>0≤c,ai≤109,<br>1≤P≤109<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 43</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">5</span><br><span class="line">1 2 5 5</span><br><span class="line">3 2 4</span><br><span class="line">2 3 7 9</span><br><span class="line">3 1 3</span><br><span class="line">3 4 7</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">35</span><br><span class="line">8</span><br></pre></td></tr></table></figure><br>样例解释<br>初始时数列为 {1,2,3,4,5,6,7}；<br>经过第 1 次操作后，数列为 {1,10,15,20,25,6,7}；<br>对第 2 次操作，和为 10+15+20=45，模 43 的结果是 2；<br>经过第 3 次操作后，数列为 {1,10,24,29,34,15,16}；<br>对第 4 次操作，和为 1+10+24=35，模 43 的结果是 35；<br>对第 5 次操作，和为 29+34+15+16=94，模 43 的结果是 8。</p>
<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p><strong>多懒标记问题</strong><br>本题对区间修改有两个操作，一个是乘法操作，另外一个是加法操作。所以需要维护两个懒标记。<code>add</code> <code>mul</code></p>
<p>多懒标记更新，尽量要使得公式能统一一个形式<br>本题虽然是每次操作都是乘法或者加法，但是为了统一形式我们操作是无论加法和乘法都转换成<code>x * a + b</code> 的形式，<code>a = 1</code>时候为加法操作, <code>b = 0</code>为乘法操作，<br>如果多次对一个区间进行操作的话我们可以简化公式为<br>第一次对区间操作 <code>x * a + b</code><br>第二次对区间操作<code>sum * c + d</code> &lt;=&gt; <code>(x * a + b) * c + d</code> &lt;=&gt; <code>x * a * c + b * c + d</code> &lt;=&gt;<code>x * (a * c) + (b * c + d)</code><br>所以知道原<code>add(b)</code>= <code>b * c + d</code>, 原<code>mul(a)</code> = <code>a * c</code></p>
<p>如果是先加后乘的形式<br><code>(x + a) * b</code><br>第一次操作为<code>(x + a) * b</code><br>第二次操作为<code>(sum + c) * d</code> &lt;=&gt; <code>((x + a) * b + c) * d</code> &lt;=&gt; <code>(x * b + a * b + c) * d</code> &lt;=&gt;<code>x * b * d + a * b * d + c * d</code> 这样子我们原数值sum都有一系列的系数了，很难更新我们当前的节点值</p>
<h3 id="CODE-4"><a href="#CODE-4" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum, add, mul;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m, p;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// x * a + b + c = x * a + (b + c)</span></span><br><span class="line"><span class="comment">// (x * a + b) * c = x * a * c + b * c;</span></span><br><span class="line"><span class="comment">// 统一形式</span></span><br><span class="line"><span class="comment">// sum * c + d = (x * a + b) * c + d = x * (a * c) + (c*b + d)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eval</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = ((ll)tr[u].sum * a + b * (ll)(tr[u].r - tr[u].l + <span class="number">1</span>)) % p;</span><br><span class="line">    tr[u].add = ((ll)a *  tr[u].add + b) % p;</span><br><span class="line">    tr[u].mul = ((ll)tr[u].mul * a) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = ((ll)tr[u &lt;&lt; <span class="number">1</span>]. sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(u &lt;&lt; <span class="number">1</span>, tr[u].mul, tr[u].add);</span><br><span class="line">    <span class="built_in">eval</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tr[u].mul, tr[u].add);</span><br><span class="line">    tr[u].add = <span class="number">0</span>;</span><br><span class="line">    tr[u].mul = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u ,<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r;</span><br><span class="line">        tr[u].add = <span class="number">0</span>, tr[u].mul = <span class="number">1</span>;</span><br><span class="line">        tr[u].sum = w[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r;</span><br><span class="line">        tr[u].add = <span class="number">0</span>, tr[u].mul = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid =  l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span> , r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l ,<span class="type">int</span> r, <span class="type">int</span> a, <span class="type">int</span> b)</span>  <span class="comment">// x * a + b</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">eval</span>(u, a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].r + tr[u].l &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, a, b);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, a, b);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) res = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) res = ((ll)res + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l , r)) % p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,l,r,a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;a);</span><br><span class="line">            b = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,r,a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;b);</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,r,a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,l,r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模版</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>负环</title>
    <url>/2022/07/20/%E8%B4%9F%E7%8E%AF/</url>
    <content><![CDATA[<h2 id="负环"><a href="#负环" class="headerlink" title="负环"></a>负环</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>权值之和为负的环称为负环（与之相对应的就是正环）</p>
<h3 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h3><ol>
<li>方法一：统计每个点入队的次数，如果某个点入队n次，则说明存在负环（bellman-ford)</li>
<li>统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于n，则说明存在环.</li>
</ol>
<p>方法一的最坏情况比较糟糕，因为假如一个环1-2-3-4-n-1,一共有n个顶点，第一次这个圈所有点都进入队列当中仅当这个圈遍历到<code>n-1</code>圈才会出现某个点入队n次的情况 O（n*(n-1) + 1) = O(n^2)<br>方法二则是O（n）的，因为如果1-n上路径超过了n-1条边必然会有环</p>
<h3 id="例题spfa判断负环"><a href="#例题spfa判断负环" class="headerlink" title="例题spfa判断负环"></a>例题<a href="https://www.acwing.com/problem/content/854/">spfa判断负环</a></h3><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。</p>
<p>请你判断图中是否存在负权回路。</p>
<p>输入格式<br>第一行包含整数 n 和 m。</p>
<p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p>
<p>输出格式<br>如果图中存在负权回路，则输出 Yes，否则输出 No。</p>
<p>数据范围<br>1≤n≤2000,<br>1≤m≤10000,<br>图中涉及边长绝对值均不超过 10000。</p>
<p>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 -1</span><br><span class="line">2 3 4</span><br><span class="line">3 1 -4</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>由于从某个起点开始的最短路径上不一定是含有负环的，但是我们需要判断图上的是否有负环怎么办？？<br><strong>构造虚拟源点</strong>， 虚拟源点向每个点都连一条边权为0的边<code>初始化dist[i] = 0</code>，要是有负环这个虚拟源点必然包含在其中。这里的dist数组就是维护到虚拟源点的最短距离</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="comment">//把所有点放进队列里面</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="玄学优化"><a href="#玄学优化" class="headerlink" title="玄学优化"></a>玄学优化</h3><p>由于很多题目都出现了卡队列形式的spfa，当前呈现了spfa已死的情况，所以spfa还需要一些玄学优化，将时间复杂度降到O（nm）以下</p>
<h3 id="节点更新超过了n次直接判定有负环"><a href="#节点更新超过了n次直接判定有负环" class="headerlink" title="节点更新超过了n次直接判定有负环"></a>节点更新超过了n次直接判定有负环</h3>]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>负环</tag>
      </tags>
  </entry>
</search>
