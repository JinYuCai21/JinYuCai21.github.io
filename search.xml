<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AT-Tree Restoring</title>
    <url>/2022/07/17/AT-Tree-Restoring/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>AcWing 904. 虫洞(spfa求负环)</title>
    <url>/2022/11/07/AcWing%20904.%20%E8%99%AB%E6%B4%9E(spfa%E6%B1%82%E8%B4%9F%E7%8E%AF)%20/</url>
    <content><![CDATA[<h1 id="AcWing-904-虫洞-spfa求负环"><a href="#AcWing-904-虫洞-spfa求负环" class="headerlink" title="AcWing 904. 虫洞(spfa求负环)"></a><a href="https://www.acwing.com/problem/content/906/">AcWing 904. 虫洞(spfa求负环)</a></h1><p>农夫约翰在巡视他的众多农场时，发现了很多令人惊叹的虫洞。</p>
<p>虫洞非常奇特，它可以看作是一条 单向 路径，通过它可以使你回到过去的某个时刻（相对于你进入虫洞之前）。</p>
<p>农夫约翰的每个农场中包含 N 片田地，M 条路径（双向）以及 W 个虫洞。</p>
<p>现在农夫约翰希望能够从农场中的某片田地出发，经过一些路径和虫洞回到过去，并在他的出发时刻之前赶到他的出发地。</p>
<p>他希望能够看到出发之前的自己。</p>
<p>请你判断一下约翰能否做到这一点。</p>
<p>下面我们将给你提供约翰拥有的农场数量 F，以及每个农场的完整信息。</p>
<p>已知走过任何一条路径所花费的时间都不超过 10000 秒，任何虫洞将他带回的时间都不会超过 10000 秒。</p>
<p>输入格式<br>第一行包含整数 F，表示约翰共有 F 个农场。</p>
<p>对于每个农场，第一行包含三个整数 N,M,W。</p>
<p>接下来 M 行，每行包含三个整数 S,E,T，表示田地 S 和 E 之间存在一条路径，经过这条路径所花的时间为 T。</p>
<p>再接下来 W 行，每行包含三个整数 S,E,T，表示存在一条从田地 S 走到田地 E 的虫洞，走过这条虫洞，可以回到 T 秒之前。</p>
<p>输出格式<br>输出共 F 行，每行输出一个结果。</p>
<p>如果约翰能够在出发时刻之前回到出发地，则输出 YES，否则输出 NO。</p>
<p>数据范围<br>1≤F≤5<br>1≤N≤500,<br>1≤M≤2500,<br>1≤W≤200,<br>1≤T≤10000,<br>1≤S,E≤N<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 3 1</span><br><span class="line">1 2 2</span><br><span class="line">1 3 4</span><br><span class="line">2 3 1</span><br><span class="line">3 1 3</span><br><span class="line">3 2 1</span><br><span class="line">1 2 3</span><br><span class="line">2 3 4</span><br><span class="line">3 1 8</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题是需要判断是图上是否有负环而不是找出所有的负环中的最小</p>
<p>构造一个虚拟源点与当前图上的每一个点相连，统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于n，则说明存在环</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">5300</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, wh;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 判断这个点是否在队列当中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// dist 距离源点最短距离， cnt从源点到这个点有多少条路径</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        q[tt ++] = i, st[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt ++] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; wh;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            <span class="built_in">add</span>(a,b,c);</span><br><span class="line">            <span class="built_in">add</span>(b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; wh; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            c = -c;</span><br><span class="line">            <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>图论</category>
        <category>负环</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>负环</tag>
      </tags>
  </entry>
  <entry>
    <title>51Nod-1126 求递推序列的第N项</title>
    <url>/2022/07/15/51Nod-1126/</url>
    <content><![CDATA[<h2 id="51Nod-1126-求递推序列的第N项"><a href="#51Nod-1126-求递推序列的第N项" class="headerlink" title="51Nod-1126-求递推序列的第N项"></a><a href="https://vjudge.net/problem/51Nod-1126">51Nod-1126-求递推序列的第N项</a></h2><p>有一个序列是这样定义的：f(1) = 1, f(2) = 1, f(n) = (A <em> f(n - 1) + B </em> f(n - 2)) mod 7.<br>给出A，B和N，求f(n)的值。<br>Input<br>输入3个数：A,B,N。数字之间用空格分割。(-10000 &lt;= A, B &lt;= 10000, 1 &lt;= N &lt;= 10^9)<br>Output<br>输出f(n)的值。</p>
<p>Sample<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 -1 5</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>构造矩阵 F1 = [f1,f2], X = {0,B,1,A} 的矩阵 F1 <em> X = [f2,f3],可以推出来 F1</em>X^N = [fn+1,fn]<br>然后利用二进制数的特性将幂n化为二进制数进行矩阵快速幂计算<br><strong>要注意这里需要对数进行取模运算，并且这个数可能为负数</strong></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>,N=<span class="number">2</span>, mod = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A,B,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul1</span><span class="params">(<span class="type">int</span> c[],<span class="type">int</span> a[], <span class="type">int</span> b[][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++)</span><br><span class="line">            tmp[i] =( ( (tmp[i] + (LL)a[j] * b[j][i]) % mod) + mod ) % mod; <span class="comment">// 可能出现负数的情况</span></span><br><span class="line">    <span class="built_in">memcpy</span>(c,tmp,<span class="keyword">sizeof</span> c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul2</span><span class="params">(<span class="type">int</span> c[][N],<span class="type">int</span> a[][N], <span class="type">int</span> b[][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; N; k ++)</span><br><span class="line">                tmp[i][j] =( (tmp[i][j] + (LL)a[i][k] * b[k][j]) % mod + mod ) % mod;</span><br><span class="line">    <span class="built_in">memcpy</span>(c,tmp, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> f1[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">2</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>,B&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,A&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) <span class="built_in">mul1</span>(f1,f1,x);</span><br><span class="line">        <span class="built_in">mul2</span>(x,x,x);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f1[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>矩阵快速幂</tag>
        <tag>负数取模</tag>
        <tag>模版</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1058. 股票买卖 V</title>
    <url>/2022/09/17/AcWing-1058-%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96-V/</url>
    <content><![CDATA[<h2 id="AcWing-1058-股票买卖-V"><a href="#AcWing-1058-股票买卖-V" class="headerlink" title="AcWing 1058. 股票买卖 V"></a><a href="https://www.acwing.com/problem/content/1060/">AcWing 1058. 股票买卖 V</a></h2><p>给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i 天的价格。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>输入格式<br>第一行包含整数 N，表示数组长度。</p>
<p>第二行包含 N 个不超过 10000 的正整数，表示完整的数组。</p>
<p>输出格式<br>输出一个整数，表示最大利润。</p>
<p>数据范围<br>1≤N≤105<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 0 2</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><br>样例解释<br>对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]，第一笔交易可得利润 2-1 = 1，第二笔交易可得利润 2-0 = 2，共得利润 1+2 = 3。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>设置一个dp[N][3]数组表示的意思<br> dp[i][0] 表示在i天手上有股票 dp[i][1] 表示在i天手上没有股票一天 dp[i][2] 表示在i天手上没有股票的第二天以后<br>状态转移模型<br><img src ="/images /懒标记的解释.png"></p>
<p>根据状态机模型的转换图我们可以看出来状态转移图有环，且有可能存在负环。但是实际上是这样吗？？如果下一个状态会被上一个状态影响的话这样的是无法使用dp正常做法做的，当时要知道这个图很明确的表现出第i层状态是通过第i-1层状态转移过来的所以是可以使用dp求解而不需要使用图论的最短路算法求解.</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在i天dp[i][0] 表示的当前手上有股票 dp[i][1] 表示在i天手上没有股票一天 dp[i][2] 表示在i天手上没有股票的第二天以后</span></span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">3</span>]; </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">1</span>] = -INF; <span class="comment">// 表示初始状态不能是这个状态</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>] - w[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + w[i];</span><br><span class="line">        dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(dp[n][<span class="number">1</span>], dp[n][<span class="number">2</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AcWing</category>
        <category>动态规划</category>
        <category>状态机模型</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态机</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1074. 二叉苹果树</title>
    <url>/2022/08/07/AcWing-1074-%E4%BA%8C%E5%8F%89%E8%8B%B9%E6%9E%9C%E6%A0%91/</url>
    <content><![CDATA[<h2 id="AcWing-1074-二叉苹果树"><a href="#AcWing-1074-二叉苹果树" class="headerlink" title="AcWing 1074. 二叉苹果树"></a><a href="https://www.acwing.com/problem/content/1076/">AcWing 1074. 二叉苹果树</a></h2><p>有一棵二叉苹果树，如果树枝有分叉，一定是分两叉，即没有只有一个儿子的节点。</p>
<p>这棵树共 N 个节点，编号为 1 至 N，树根编号一定为 1。</p>
<p>我们用一根树枝两端连接的节点编号描述一根树枝的位置。</p>
<p>一棵苹果树的树枝太多了，需要剪枝。但是一些树枝上长有苹果，给定需要保留的树枝数量，求最多能留住多少苹果。</p>
<p>这里的保留是指最终与1号点连通。</p>
<p>输入格式<br>第一行包含两个整数 N 和 Q，分别表示树的节点数以及要保留的树枝数量。</p>
<p>接下来 N−1 行描述树枝信息，每行三个整数，前两个是它连接的节点的编号，第三个数是这根树枝上苹果数量。</p>
<p>输出格式<br>输出仅一行，表示最多能留住的苹果的数量。</p>
<p>数据范围<br>1≤Q&lt;N≤100.<br>N≠1,<br>每根树枝上苹果不超过 30000 个。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 2</span><br><span class="line">1 3 1</span><br><span class="line">1 4 10</span><br><span class="line">2 3 20</span><br><span class="line">3 5 20</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>根据题意我们要知道的是对于本题来说选了子节点，其子节点的父亲节点也一定要选，但是选了父节点不一定选子节点，所以知道了从下到上更新困难，从上到下更新简单。</p>
<p>有依赖关系的背包问题划分：<br>dp[i][j]表示以i为根的子树，包含i的这个节点保留边数不大于j的权值之和最大方案</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> dp[N][N];   <span class="comment">// dp[u][m]表示以u为根节点的树保留m条边最多可以留的苹果数目</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; j; k ++)</span><br><span class="line">                dp[u][j] = <span class="built_in">max</span>(dp[u][j], dp[v][k] + dp[u][j-k<span class="number">-1</span>] + w[i]);   <span class="comment">// 要保留u-&gt;v之间的那条边</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="comment">// 不能建立单向边</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1 2 0</span></span><br><span class="line"><span class="comment">            1 5 1</span></span><br><span class="line"><span class="comment">            3 5 100</span></span><br><span class="line"><span class="comment">            4 5 1</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,c),<span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>动态规划</category>
        <category>树形dp</category>
        <category>树上背包</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1077. 皇宫看守</title>
    <url>/2022/08/07/AcWing-1077-%E7%9A%87%E5%AE%AB%E7%9C%8B%E5%AE%88/</url>
    <content><![CDATA[<h3 id="AcWing-1077-皇宫看守"><a href="#AcWing-1077-皇宫看守" class="headerlink" title="AcWing 1077. 皇宫看守"></a><a href="https://www.acwing.com/problem/content/1079/">AcWing 1077. 皇宫看守</a></h3><p>本题要区别于<a href="https://www.acwing.com/problem/content/325/">战略游戏</a><br>战略游戏是要求我们的用最少节点数覆盖到所有点上<br>本题是要求我们用最少的节点数覆盖到所有的边上</p>
<p>比如一个图是<br>1-&gt;2-&gt;3-&gt;4<br>最少点覆盖是用1号点和4号点这样就可以覆盖全图上的所有点（方案不唯一)<br>最少边覆盖是用1，2，3号点才可以实现所有的边覆盖</p>
<p>树形dp<br>状态划分dp[i][3]<br>要注意的是是以i为根的子树也就是只能当前节点的往下去划分集合<br>集合划分：dp[i][0] 表示以i为根的子树父节点被选自己观察的情况， dp[i][1] 表示以i为根的子树父节点被子节点观察的情况,dp[i][2] 表示以i为根的子树父节点被其父节点观察<br>状态转移：<br>当父节点被自己观察的情况下，子节点要么被自己观察要么被被自己的儿子观察<br>dp[u][0] = min(dp[v][0], dp[v][1], dp[v][2]) + w[u];<br>当父亲节点被子节点观察的情况，至少一个子节点是被自己观察，其余的节点可以被自己观察也可以被子节点观察<br>dp[u][1] = min(dp[v][0] + ∑ min(dp[vi][0],dp[vi][1]))<br>当父亲节点被父节点观察的情况，那么其子节点是可以被自己观察也可以被子节点观察的<br>dp[u][2] = min(dp[v][0],dp[v][1])</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1510</span>, M = <span class="number">2</span> * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[N], idx;</span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> n,res = INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    dp[u][<span class="number">0</span>] = w[u];    <span class="comment">// 被自己观察那么至少是选择当前的节点的</span></span><br><span class="line">    dp[u][<span class="number">1</span>] = INF;     <span class="comment">// 被儿子观察，因为要遍历所子节点方案取min所以要初始化为INF</span></span><br><span class="line">    dp[u][<span class="number">2</span>] = <span class="number">0</span>;       <span class="comment">// 被父节点观察的情况下，当下这个节点一定不用选</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(j,u);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;A&quot; &lt;&lt; endl;</span></span><br><span class="line">        dp[u][<span class="number">0</span>] += <span class="built_in">min</span>(dp[j][<span class="number">0</span>], <span class="built_in">min</span>(dp[j][<span class="number">1</span>], dp[j][<span class="number">2</span>]));</span><br><span class="line">        dp[u][<span class="number">2</span>] += <span class="built_in">min</span>(dp[j][<span class="number">0</span>],dp[j][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;B&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// dp[u][2] = sum&#123;min(dp[v][0],dp[v][1])&#125;</span></span><br><span class="line">        <span class="comment">// dp[u][2] - j的贡献就等于其他子节点的贡献总和</span></span><br><span class="line">        dp[u][<span class="number">1</span>] = <span class="built_in">min</span>(dp[u][<span class="number">1</span>], dp[v][<span class="number">0</span>] + dp[u][<span class="number">2</span>] - <span class="built_in">min</span>(dp[v][<span class="number">0</span>],dp[v][<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id,v,cnt;</span><br><span class="line">        cin &gt;&gt; id &gt;&gt; v &gt;&gt; cnt;</span><br><span class="line">        w[id] = v;</span><br><span class="line">        <span class="keyword">while</span>(cnt --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            <span class="built_in">add</span>(id,a), <span class="built_in">add</span>(a,id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(dp[<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1082. 数字游戏</title>
    <url>/2022/10/08/AcWing-1082-%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="AcWing-1082-数字游戏"><a href="#AcWing-1082-数字游戏" class="headerlink" title="AcWing 1082. 数字游戏"></a>AcWing 1082. 数字游戏</h2><p>科协里最近很流行数字游戏。</p>
<p>某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 123，446。</p>
<p>现在大家决定玩一个游戏，指定一个整数闭区间 [a,b]，问这个区间内有多少个不降数。</p>
<p>输入格式<br>输入包含多组测试数据。</p>
<p>每组数据占一行，包含两个整数 a 和 b。</p>
<p>输出格式<br>每行给出一组测试数据的答案，即 [a,b] 之间有多少不降数。</p>
<p>数据范围<br>$1≤a≤b≤2^{31}−1$<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 9</span><br><span class="line">1 19</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">18</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我们根据数值知道这是一个32位数的组合型问题，正常的寻找如果按数值大小的寻找枚举一遍至少是$2^{32} = 4 * 10^9$ 级别。所以现在考虑是否将这个n改变成按位查询，即使用数位dp的方式。</p>
<p>数组F[i][j]: 表示一共有i位且最高位为j的所有不降数的方案数。</p>
<p>初始化数组F[i][j]，一般有两种办法。<br>    (1) 使用组合数形式<br>    (2) 使用递归形式</p>
<p>对于本题来说的F[i][j] = 所有满足第i-1位上k&gt;=j的所有方案，即</p>
<script type="math/tex; mode=display">F[i][j] = \sum_{k=j}^9 F[i-1][k]</script><p>数位dp的考虑形式<br>因为数位dp一般都是从0<br>对于每一位都考虑两种情况（1）0～lim - 1 （2） lim。这个lim是我们讨论的(0,n),n在这一位上的数。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">10</span>]; <span class="comment">// (f[i][j],i为最高位填的是j)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i ++) f[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = j; k &lt;= <span class="number">9</span>; k ++)</span><br><span class="line">                f[i][j] += f[i<span class="number">-1</span>][k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">while</span>(n) nums.<span class="built_in">pb</span>(n % <span class="number">10</span>), n /= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = nums[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = last; j &lt; x; j ++)</span><br><span class="line">            res += f[i + <span class="number">1</span>][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x &lt; last) <span class="keyword">break</span>;</span><br><span class="line">        last = x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!i) res ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; l &gt;&gt; r)</span><br><span class="line">    &#123;   </span><br><span class="line">        cout &lt;&lt; <span class="built_in">dp</span>(r) - <span class="built_in">dp</span>(l<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1097. 池塘计数(模版)</title>
    <url>/2022/10/11/AcWing-1097-%E6%B1%A0%E5%A1%98%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="AcWing-1097-池塘计数-模版"><a href="#AcWing-1097-池塘计数-模版" class="headerlink" title="AcWing 1097. 池塘计数(模版)"></a><a href="https://www.acwing.com/problem/content/1099/">AcWing 1097. 池塘计数(模版)</a></h2><p>农夫约翰有一片 N∗M 的矩形土地。</p>
<p>最近，由于降雨的原因，部分土地被水淹没了。</p>
<p>现在用一个字符矩阵来表示他的土地。</p>
<p>每个单元格内，如果包含雨水，则用”W”表示，如果不含雨水，则用”.”表示。</p>
<p>现在，约翰想知道他的土地中形成了多少片池塘。</p>
<p>每组相连的积水单元格集合可以看作是一片池塘。</p>
<p>每个单元格视为与其上、下、左、右、左上、右上、左下、右下八个邻近单元格相连。</p>
<p>请你输出共有多少片池塘，即矩阵中共有多少片相连的”W”块。</p>
<p>输入格式<br>第一行包含两个整数 N 和 M。</p>
<p>接下来 N 行，每行包含 M 个字符，字符为”W”或”.”，用以表示矩形土地的积水状况，字符之间没有空格。</p>
<p>输出格式<br>输出一个整数，表示池塘数目。</p>
<p>数据范围<br>$1≤N,M≤1000$<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 12</span><br><span class="line">W........WW.</span><br><span class="line">.WWW.....WWW</span><br><span class="line">....WW...WW.</span><br><span class="line">.........WW.</span><br><span class="line">.........W..</span><br><span class="line">..W......W..</span><br><span class="line">.W.W.....WW.</span><br><span class="line">W.W.W.....W.</span><br><span class="line">.W.W......W.</span><br><span class="line">..W.......W.</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>本题有几个点</p>
<ul>
<li>PII q[M] 这个队列不能在局部变量下声请，最坏的情况下会进行$1e^6$声请，实测会T。</li>
</ul>
<p><strong>对st[]数组的总结</strong><br><strong>BFS算法</strong>，理论上bfs是不会走回头路的，所以如果只做一次bfs是不用st数组的。但是这里需要多次bfs所以还需要记录每个坐标的状态。</p>
<p><strong>Dijkstra algorithm（堆优化）</strong>， 理论上Dijkstra是bfs的一种优化。所以该算法的写法是一种类bfs写法。st数组表示的是这个点是否被更新（因为和bfs的原理相似，所以每一个点只会被且有且只能被更新一次，所以不能重新更新）</p>
<p><strong>SPFA Algorithm</strong>, st数组记录的是当前的这个节点是否在队列内部。<br>每次的bfs都是走不出当前所在的连通块的，所以需要多次的bfs</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">PII q[M];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    q[++ tt] = &#123;x,y&#125;;</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh ++];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为这里是八联通问题所以最好还是使用枚举点的方式，虽然也可以使用dx/dy数组但是要写八个点对比较麻烦</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = t.fi - <span class="number">1</span>; i &lt;= t.fi + <span class="number">1</span>; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = t.se - <span class="number">1</span>; j &lt;= t.se + <span class="number">1</span>; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 特判中心点</span></span><br><span class="line">                <span class="keyword">if</span>(i == t.fi &amp;&amp; j == t.se) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 特判出界的变量</span></span><br><span class="line">                <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;W&#x27;</span> &amp;&amp; !st[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[++ tt] = &#123;i,j&#125;;</span><br><span class="line">                    st[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,g[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;W&#x27;</span> &amp;&amp; !st[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">bfs</span>(i,j);</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AcWing</category>
        <category>搜索</category>
        <category>Flood fill</category>
      </categories>
      <tags>
        <tag>模版</tag>
        <tag>搜索</tag>
        <tag>Flood fill</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1106. 山峰和山谷</title>
    <url>/2022/11/01/AcWing-1106-%E5%B1%B1%E5%B3%B0%E5%92%8C%E5%B1%B1%E8%B0%B7/</url>
    <content><![CDATA[<h2 id="AcWing-1106-山峰和山谷"><a href="#AcWing-1106-山峰和山谷" class="headerlink" title="AcWing 1106. 山峰和山谷"></a><a href="https://www.acwing.com/problem/content/1108/">AcWing 1106. 山峰和山谷</a></h2><p>FGD小朋友特别喜欢爬山，在爬山的时候他就在研究山峰和山谷。</p>
<p>为了能够对旅程有一个安排，他想知道山峰和山谷的数量。</p>
<p>给定一个地图，为FGD想要旅行的区域，地图被分为 n×n 的网格，每个格子 (i,j) 的高度 w(i,j) 是给定的。</p>
<p>若两个格子有公共顶点，那么它们就是相邻的格子，如与 (i,j) 相邻的格子有(i−1,j−1),(i−1,j),(i−1,j+1),(i,j−1),(i,j+1),(i+1,j−1),(i+1,j),(i+1,j+1)。</p>
<p>我们定义一个格子的集合 S 为山峰（山谷）当且仅当：</p>
<p>S 的所有格子都有相同的高度。<br>S 的所有格子都连通。<br>对于 s 属于 S，与 s 相邻的 s′ 不属于 S，都有 ws&gt;ws′（山峰），或者 ws&lt;ws′（山谷）。<br>如果周围不存在相邻区域，则同时将其视为山峰和山谷。<br>你的任务是，对于给定的地图，求出山峰和山谷的数量，如果所有格子都有相同的高度，那么整个地图即是山峰，又是山谷。</p>
<p>输入格式<br>第一行包含一个正整数 n，表示地图的大小。</p>
<p>接下来一个 n×n 的矩阵，表示地图上每个格子的高度 w。</p>
<p>输出格式<br>共一行，包含两个整数，表示山峰和山谷的数量。</p>
<p>数据范围<br>1≤n≤1000,<br>0≤w≤109<br>输入样例1：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">8 8 8 7 7</span><br><span class="line">7 7 8 8 7</span><br><span class="line">7 7 7 7 7</span><br><span class="line">7 8 8 7 8</span><br><span class="line">7 8 8 8 8</span><br></pre></td></tr></table></figure><br>输出样例1：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></table></figure><br>输入样例2：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5 7 8 3 1</span><br><span class="line">5 5 7 6 6</span><br><span class="line">6 6 6 2 8</span><br><span class="line">5 7 2 5 8</span><br><span class="line">7 1 0 1 7</span><br></pre></td></tr></table></figure><br>输出样例2：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br></pre></td></tr></table></figure></p>
<p><strong>样例解释</strong><br>样例1：<br><img src="https://cdn.acwing.com/media/article/image/2019/10/16/19_0250799aef-1.png" alt="样例1"><br>样例2：<br><img src="https://cdn.acwing.com/media/article/image/2019/10/16/19_08db5e60ef-2.png" alt="样例2"></p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line">PII q[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy, <span class="type">int</span> &amp;higher, <span class="type">int</span> &amp;lower)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = &#123;sx, sy&#125;;</span><br><span class="line">    st[sx][sy] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh ++];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x = t.fi, y = t.se;</span><br><span class="line">        <span class="comment">// 八连通问题</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x - <span class="number">1</span>; i &lt;= x + <span class="number">1</span>; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = y - <span class="number">1</span>; j &lt;= y + <span class="number">1</span>; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == x &amp;&amp; j == y) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 如果不是同一个山脉就要查看这个位置的海拔与我们当前枚举位置海拔对比</span></span><br><span class="line">                <span class="keyword">if</span>(g[i][j] != g[x][y])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(g[i][j] &gt; g[x][y]) higher ++;</span><br><span class="line">                    <span class="keyword">if</span>(g[i][j] &lt; g[x][y]) lower ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!st[i][j]) </span><br><span class="line">                &#123;</span><br><span class="line">                    q[++ tt] = &#123;i,j&#125;;</span><br><span class="line">                    st[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一个山脉表示的就是的同一个连通块</span></span><br><span class="line">    <span class="comment">// 用Flood Fill算法的进行BFS搜索</span></span><br><span class="line">    <span class="type">int</span> peak = <span class="number">0</span>, villey = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(!st[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> higher = <span class="number">0</span>, lower = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">bfs</span>(i,j,higher, lower);</span><br><span class="line">                <span class="comment">// 如果这个连通块（山脉）附近没有比他还要高的就说明这个是山峰</span></span><br><span class="line">                <span class="keyword">if</span>(!higher) peak ++;</span><br><span class="line">                <span class="keyword">if</span>(!lower) villey ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; peak &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; villey &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>搜索</category>
        <category>Flood Fill</category>
      </categories>
      <tags>
        <tag>Flood Fill</tag>
        <tag>连通块</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1126. 最小花费</title>
    <url>/2022/07/24/AcWing-1126-%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9/</url>
    <content><![CDATA[<h2 id="AcWing-1126-最小花费"><a href="#AcWing-1126-最小花费" class="headerlink" title="AcWing 1126. 最小花费"></a><a href="https://www.acwing.com/problem/content/1128/">AcWing 1126. 最小花费</a></h2><p>在 n 个人中，某些人的银行账号之间可以互相转账。<br>这些人之间转账的手续费各不相同。<br>给定这些人之间转账时需要从转账金额里扣除百分之几的手续费，请问 A 最少需要多少钱使得转账后 B 收到 100 元。</p>
<p>输入格式<br>第一行输入两个正整数 n,m，分别表示总人数和可以互相转账的人的对数。<br>以下 m 行每行输入三个正整数 x,y,z，表示标号为 x 的人和标号为 y 的人之间互相转账需要扣除 z% 的手续费 ( z&lt;100 )。<br>最后一行输入两个正整数 A,B。</p>
<p>数据保证 A 与 B 之间可以直接或间接地转账。</p>
<p>输出格式<br>输出 A 使得 B 到账 100 元最少需要的总费用。</p>
<p>精确到小数点后 8 位。</p>
<p>数据范围<br>1≤n≤2000,<br>m≤105<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 1</span><br><span class="line">2 3 2</span><br><span class="line">1 3 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">103.07153164</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目要求的到帐100元的最少费用<br>100 = x <em> (1-a1) </em> (1 - a2) … x为原来总费用，a1,a2…为手续费<br>可以简化公式为 100 = x <em> (p1 </em> p2 <em> … </em> pn)， 要想求x最小那么就需要（p1 <em> p2 </em> … <em> pn)最大。<br>p1 </em> p2 <em> … </em> pn &lt;=&gt; log(p1 <em> p2 </em> … <em> pn) &lt;=&gt; log p1 + log p2 + .. log pn<br>&lt;=&gt; 由于log函数单调递增，所以要想求`p1 </em> p2 <em> … </em> pn<code>，那么等于求</code>p1 + p2 + … + pn`最大<br><strong>但是要注意的是logx 在 (0,1)logx &lt; 0 只会出现负数， 所以有两种做法，要么求最长（边权为负求最长路），要么边权取反求最短路（边权为正求最短路）， 但是一旦x的限制为 x &gt; 0的话，边权就可正可负了，这个情况下就尽量使用spfa</strong></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">double</span>, <span class="type">int</span>&gt; PDI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; <span class="built_in">assert</span>(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, M = <span class="number">100010</span> * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M],idx;</span><br><span class="line"><span class="type">double</span> w[M];</span><br><span class="line"><span class="type">int</span> n, m, start, ed;</span><br><span class="line"><span class="type">double</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">double</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dist);   <span class="comment">// 求最长路，初始化为负无穷</span></span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;PDI&gt; q;  <span class="comment">// 第一维要保存的是double类型的，且要求最短路这里是大根堆</span></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>,start&#125;);</span><br><span class="line">    dist[start] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver = t.se;</span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>; <span class="comment">// 堆优化的dijkstra</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &lt; dist[ver] * w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] * w[i];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="type">double</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a,&amp;b,&amp;c);</span><br><span class="line">        p = (<span class="number">100.0</span>-c) / <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">add</span>(a,b,p);</span><br><span class="line">        <span class="built_in">add</span>(b,a,p);  </span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; start &gt;&gt; ed;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.8lf\n&quot;</span>, <span class="number">100</span> / dist[ed]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1131. 拯救大兵瑞恩</title>
    <url>/2022/09/05/AcWing-1131-%E6%8B%AF%E6%95%91%E5%A4%A7%E5%85%B5%E7%91%9E%E6%81%A9/</url>
    <content><![CDATA[<h2 id="AcWing-1131-拯救大兵瑞恩"><a href="#AcWing-1131-拯救大兵瑞恩" class="headerlink" title="AcWing 1131. 拯救大兵瑞恩"></a><a href="https://www.acwing.com/problem/content/1133/">AcWing 1131. 拯救大兵瑞恩</a></h2><p>1944 年，特种兵麦克接到国防部的命令，要求立即赶赴太平洋上的一个孤岛，营救被敌军俘虏的大兵瑞恩。</p>
<p>瑞恩被关押在一个迷宫里，迷宫地形复杂，但幸好麦克得到了迷宫的地形图。</p>
<p>迷宫的外形是一个长方形，其南北方向被划分为 N 行，东西方向被划分为 M 列， 于是整个迷宫被划分为 N×M 个单元。</p>
<p>每一个单元的位置可用一个有序数对 (单元的行号, 单元的列号) 来表示。</p>
<p>南北或东西方向相邻的 2 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。</p>
<p>注意： 门可以从两个方向穿过，即可以看成一条无向边。</p>
<p>迷宫中有一些单元存放着钥匙，同一个单元可能存放 多把钥匙，并且所有的门被分成 P 类，打开同一类的门的钥匙相同，不同类门的钥匙不同。</p>
<p>大兵瑞恩被关押在迷宫的东南角，即 (N,M) 单元里，并已经昏迷。</p>
<p>迷宫只有一个入口，在西北角。</p>
<p>也就是说，麦克可以直接进入 (1,1) 单元。</p>
<p>另外，麦克从一个单元移动到另一个相邻单元的时间为 1，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。</p>
<p>试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。</p>
<p>输入格式<br>第一行有三个整数,分别表示 N,M,P 的值。</p>
<p>第二行是一个整数 k，表示迷宫中门和墙的总数。</p>
<p>接下来 k 行，每行包含五个整数，Xi1,Yi1,Xi2,Yi2,Gi：当 Gi≥1 时，表示 (Xi1,Yi1) 单元与 (Xi2,Yi2) 单元之间有一扇第 Gi 类的门，当 Gi=0 时，表示 (Xi1,Yi1) 单元与 (Xi2,Yi2) 单元之间有一面不可逾越的墙。</p>
<p>接下来一行，包含一个整数 S，表示迷宫中存放的钥匙的总数。</p>
<p>接下来 S 行，每行包含三个整数 Xi1,Yi1,Qi，表示 (Xi1,Yi1) 单元里存在一个能开启第 Qi 类门的钥匙。</p>
<p>输出格式<br>输出麦克营救到大兵瑞恩的最短时间。</p>
<p>如果问题无解，则输出 -1。</p>
<p>数据范围<br>|Xi1−Xi2|+|Yi1−Yi2|=1,<br>0≤Gi≤P,<br>1≤Qi≤P,<br>1≤N,M,P≤10,<br>1≤k≤150<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 4 9</span><br><span class="line">9</span><br><span class="line">1 2 1 3 2</span><br><span class="line">1 2 2 2 0</span><br><span class="line">2 1 2 2 0</span><br><span class="line">2 1 3 1 0 </span><br><span class="line">2 3 3 3 0</span><br><span class="line">2 4 3 4 1</span><br><span class="line">3 2 3 3 0</span><br><span class="line">3 3 4 3 0</span><br><span class="line">4 3 4 4 0</span><br><span class="line">2</span><br><span class="line">2 1 2 </span><br><span class="line">4 2 1</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><br>样例解释：<br>迷宫如下所示： <img src="https://cdn.acwing.com/media/article/image/2019/11/06/1_17c87ee400-1131.png" alt="AcWing"></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要求从左上脚走到右下角。在途中可能会遇到门，相应的门就需要相应的钥匙，所以途中可能就需要去寻找钥匙，遇到墙就说面不能通过要绕行。<br>如果对于一个有且仅有墙的问题，我们只需要使用dp[x][y] = min(dp[x + dx][y + dy], dp[x][y])转移,但是的本题因为还需要有寻找钥匙的这个一过成，只有具有一定的状态还可以的通过某一个对应的门，所以在这里需要引入一个状态变量，因为只有十种类型的门，所以最多只需要十位的二进制来表示状态就行。</p>
<p>状态划分<br>dp[x][y][state] 表示到(x,y)这点状态为state的最小代价 </p>
<p>状态转移</p>
<ul>
<li>当前如果这个位置有钥匙key，因为取钥匙是不需要任何的代价的所以有钥匙就全部取得<br>dp[x][y][state | key] = min(dp[x][y][state], dp[x][y][state | key])</li>
<li>当前这个点向上下左右四个方向走，可以走的合法方案是（1）没有门和墙 （2）有门且有相应的钥匙<br>d[cx][cy][state] = min(d[cx][cy][state], d[x][y][state] + 1)</li>
</ul>
<p>根据状态转移方程来看我们只有有且仅有边权为0/1， 并没有负数，但有环。所以一定是没有的负环，一定是可以通过最短路来求解不能通过dp来求解.</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>, M = <span class="number">400</span>, STA = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> g[N][N], key[N * N];</span><br><span class="line"><span class="type">int</span> dist[N][STA], dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">bool</span> st[N][STA];</span><br><span class="line"><span class="type">int</span> n, m, P, K;</span><br><span class="line">set&lt;PII&gt; edges;</span><br><span class="line">deque&lt;PII&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 步骤为：枚举每一个点，然后看他的邻接点是否建立边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!i || i &gt; n || !j || j &gt; m) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x = i + dx[k], y = j + dy[k];</span><br><span class="line">                <span class="type">int</span> a = g[i][j], b = g[x][y];</span><br><span class="line">                <span class="keyword">if</span>(!edges.<span class="built_in">count</span>(&#123;a,b&#125;)) <span class="built_in">add</span>(a,b,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">pb</span>(&#123;<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.fi, sta = t.se;</span><br><span class="line">        <span class="keyword">if</span>(st[ver][sta]) <span class="keyword">continue</span>;   <span class="comment">//  每个点只会被更新一次</span></span><br><span class="line">        st[ver][sta] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剪枝</span></span><br><span class="line">        <span class="comment">// 每个点的每一种状态只会被更新一遍</span></span><br><span class="line">        <span class="keyword">if</span>(ver == n * m) <span class="keyword">return</span> dist[ver][sta];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断该点上是否有钥匙 </span></span><br><span class="line">        <span class="keyword">if</span>(key[ver])</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="type">int</span> state = sta | key[ver];</span><br><span class="line">           <span class="keyword">if</span>(dist[ver][state] &gt; dist[ver][sta])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[ver][state] = dist[ver][sta];</span><br><span class="line">                q.<span class="built_in">push_front</span>(&#123;ver,state&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个点放邻边走</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];   <span class="comment">// 邻边的编号（该情况一定没有墙，因为有墙的话就不会有边相连，所以这里只用简化到判断是否有门）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前没有门</span></span><br><span class="line">            <span class="keyword">if</span>((!w[i] || sta &gt;&gt; w[i] - <span class="number">1</span> &amp; <span class="number">1</span>) &amp;&amp; dist[j][sta] &gt; dist[ver][sta] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j][sta] = <span class="built_in">min</span>(dist[j][sta], dist[ver][sta] + <span class="number">1</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(&#123;j,sta&#125;);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; P &gt;&gt; K;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了将二维转换成一维的关系，将二维坐标转换成一维的编号方式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, t = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            g[i][j] = t ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立墙和门</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; K; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="type">int</span> a = g[x1][y1], b = g[x2][y2];</span><br><span class="line">        edges.<span class="built_in">insert</span>(&#123;a,b&#125;), edges.<span class="built_in">insert</span>(&#123;b,a&#125;);   <span class="comment">// 这里抱存进set的原因是因为方便后面的建图，判断当前的边是否已经被建立</span></span><br><span class="line">        <span class="comment">// 如果是墙的话就说明没有边（等价于无路可走）</span></span><br><span class="line">        <span class="keyword">if</span>(c) <span class="built_in">add</span>(a,b,c),<span class="built_in">add</span>(b,a,c); <span class="comment">// 在编号为a和b之间建立一条边，边权为c的边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立普通边</span></span><br><span class="line">    <span class="built_in">build</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录每个坐标上的key值</span></span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span><br><span class="line">        <span class="type">int</span> a = g[x][y];</span><br><span class="line">        key[a] |= <span class="number">1</span> &lt;&lt; c - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双端队列求解最短路 </span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>图论</category>
        <category>最短路</category>
        <category>与dp结合</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1134. 最短路计数</title>
    <url>/2022/09/06/AcWing-1134-%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="AcWing-1134-最短路计数"><a href="#AcWing-1134-最短路计数" class="headerlink" title="AcWing 1134. 最短路计数"></a><a href="https://www.acwing.com/problem/content/1136/">AcWing 1134. 最短路计数</a></h2><p>给出一个 N 个顶点 M 条边的无向无权图，顶点编号为 1 到 N。</p>
<p>问从顶点 1 开始，到其他每个点的最短路有几条。</p>
<p>输入格式<br>第一行包含 2 个正整数 N,M，为图的顶点数与边数。</p>
<p>接下来 M 行，每行两个正整数 x,y，表示有一条顶点 x 连向顶点 y 的边，请注意可能有自环与重边。</p>
<p>输出格式<br>输出 N 行，每行一个非负整数，第 i 行输出从顶点 1 到顶点 i 有多少条不同的最短路，由于答案有可能会很大，你只需要输出对 100003 取模后的结果即可。</p>
<p>如果无法到达顶点 i 则输出 0。</p>
<p>数据范围<br>1≤N≤105,<br>1≤M≤2×105<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据dp来划分状态并记录最小花费的所有方案</p>
<ol>
<li>先算出全局最小值</li>
<li>分别求出每个子集中等于全局最小值的元素个数</li>
</ol>
<p>这里说明为什么在dp问题我们可以使用循环的方式来更新，而最短路不行<br> 1.dp能使用循环的方式，是因为当前状态前面的状态已经计算完毕，所以可以利用前面状态来更新当前的状态。这也说明了只有当状态转移不具有依赖关系的时候而具有拓扑序的时候，才可以利用dp方式来求解</p>
<p>最短路算法中即使图中有环也可以将环图转化拓扑图(最短路树) -&gt; 转化为拓扑图之后就可以使用dp求解（图中有负环或零环的情况下求方案数）<br> 由于dist[j] = min(dist[j], dist[t] + w[i])所以每一个点都一定会被前驱节点更新，有可能会被一个节点更新有可能会被多个节点更新，我们只需要要保留一个/多个更新当前节点的前驱节点就可以转化成一个拓扑图</p>
<p> <strong>在这里要注意</strong>， 如果当边权为0的时候，说明当前两个状态之间其实等价的关系，本质上可以相互转化的，这时候就会存在一个权重为0的环，可以在这个环上绕无限圈，所以这个时候是不能使用最短路来求的（等价于图上有负环的时候是不能通过最短路来求）</p>
<p> 由于图上没有负权边，所以如果图上存在一个环，说明这个环一定是边权为0的环（可以通过dist[i] = dist[j] + w[u] == dist[j] = dist[k] + w[v] == dist[k] = dist[i] + w[p] 算出来)</p>
<p>总结：</p>
<ul>
<li>只要图中没有负权图的dp问题即使有正环都是可以使用最短路的方式来求解的。如有有负权边的情况，就需要判断是否有负环，或则能否转化成拓扑图的形式。</li>
<li>如果图中含有负环（或零环）的情况下，使用spfa求解。<ol>
<li>先用spfa跑出来最短距离</li>
<li>建立拓扑树</li>
<li>用dist[j] = dist[t] + w[i]判断是否成立，成立就更新，但必须满足t已经完全更新过。</li>
</ol>
</li>
</ul>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">100003</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">400010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    q[hh] = <span class="number">1</span>;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + <span class="number">1</span>;</span><br><span class="line">                cnt[j] = cnt[t];</span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dist[j] == dist[t] + <span class="number">1</span>) <span class="comment">// 最短路有多条</span></span><br><span class="line">            &#123;</span><br><span class="line">                cnt[j] = (cnt[j] + cnt[t]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">// 题意可能有点问题应该所有边都是无向边</span></span><br><span class="line">        <span class="comment">// 5 5</span></span><br><span class="line">        <span class="comment">// 1 2  </span></span><br><span class="line">        <span class="comment">// 2 3</span></span><br><span class="line">        <span class="comment">// 3 4</span></span><br><span class="line">        <span class="comment">// 4 1</span></span><br><span class="line">        <span class="comment">// 4 5</span></span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最短路计数</span></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        cout &lt;&lt; cnt[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>图论</category>
        <category>最短路</category>
        <category>与dp结合</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1135.新年好</title>
    <url>/2022/07/19/AcWing-1135-%E6%96%B0%E5%B9%B4%E5%A5%BD/</url>
    <content><![CDATA[<h2 id="AcWing-1135-新年好"><a href="#AcWing-1135-新年好" class="headerlink" title="AcWing 1135.新年好"></a><a href="https://www.acwing.com/problem/content/1137/">AcWing 1135.新年好</a></h2><p>重庆城里有 n 个车站，m 条 双向 公路连接其中的某些车站。<br>每两个车站最多用一条公路连接，从任何一个车站出发都可以经过一条或者多条公路到达其他车站，但不同的路径需要花费的时间可能不同。<br>在一条路径上花费的时间等于路径上所有公路需要的时间之和。<br>佳佳的家在车站 1，他有五个亲戚，分别住在车站 a,b,c,d,e。<br>过年了，他需要从自己的家出发，拜访每个亲戚（顺序任意），给他们送去节日的祝福。<br>怎样走，才需要最少的时间？</p>
<p>输入格式<br>第一行：包含两个整数 n,m，分别表示车站数目和公路数目。<br>第二行：包含五个整数 a,b,c,d,e，分别表示五个亲戚所在车站编号。<br>以下 m 行，每行三个整数 x,y,t，表示公路连接的两个车站编号和时间。</p>
<p>输出格式<br>输出仅一行，包含一个整数 T，表示最少的总时间。</p>
<p>数据范围<br>1≤n≤50000,<br>1≤m≤105,<br>1<a,b,c,d,e≤n,
1≤x,y≤n,
1≤t≤100
输入样例：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 6</span><br><span class="line">2 3 4 5 6</span><br><span class="line">1 2 8</span><br><span class="line">2 3 3</span><br><span class="line">3 4 4</span><br><span class="line">4 5 5</span><br><span class="line">5 6 2</span><br><span class="line">1 6 7</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>由题目知道需要从源点到5个点经过路径的最短<br>一. 枚举拜访顺序，对每一种拜访顺序做最短路<br>假如我们的摆放顺序为 <code>a b c d e</code>,那么我们需要做五次最短路 1-&gt;a的最短路 2-&gt;b的最短路….<br>这中枚举方案的时间复杂度O（5！ * n^2)<br>二. 先做预处理，再枚举摆放顺序<br>因为很清楚知道其实不用每次都计算最短路。因为路都是固定的，变的是走的策略，所以可以一开始就预处理最短路，在枚举。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; <span class="built_in">assert</span>(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>, M = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, ans = INF;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M],w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[<span class="number">6</span>][N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> sourse[<span class="number">6</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> dist[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, N * <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,start&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j],j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> start, <span class="type">int</span> distance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u &gt; <span class="number">5</span>) </span><br><span class="line">        ans = <span class="built_in">min</span>(ans,distance);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> next = sourse[i];</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>, i, distance + dist[start][next]);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 本题由于所有边是正权边，且nm大概是5e9的级别的所以spfa是不敢使用的</span></span><br><span class="line">    <span class="comment">// 堆优化的dijkstrea是mlogn大概在1e6的级别，朴素版的在2.5e9所以应该使用的是堆优化</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i ++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;sourse[i]);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a,b,c),<span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i ++)</span><br><span class="line">        <span class="built_in">dijkstra</span>(sourse[i], dist[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>单源最短路</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 1137. 选择最佳线路</title>
    <url>/2022/09/04/AcWing-1137-%E9%80%89%E6%8B%A9%E6%9C%80%E4%BD%B3%E7%BA%BF%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="AcWing-1137-选择最佳线路"><a href="#AcWing-1137-选择最佳线路" class="headerlink" title="AcWing 1137. 选择最佳线路"></a><a href="https://www.acwing.com/problem/content/1139/">AcWing 1137. 选择最佳线路</a></h2><p>有一天，琪琪想乘坐公交车去拜访她的一位朋友。</p>
<p>由于琪琪非常容易晕车，所以她想尽快到达朋友家。</p>
<p>现在给定你一张城市交通路线图，上面包含城市的公交站台以及公交线路的具体分布。</p>
<p>已知城市中共包含 n 个车站（编号1~n）以及 m 条公交线路。</p>
<p>每条公交线路都是 单向的，从一个车站出发直接到达另一个车站，两个车站之间可能存在多条公交线路。</p>
<p>琪琪的朋友住在 s 号车站附近。</p>
<p>琪琪可以在任何车站选择换乘其它公共汽车。</p>
<p>请找出琪琪到达她的朋友家（附近的公交车站）需要花费的最少时间。</p>
<p>输入格式<br>输入包含多组测试数据。</p>
<p>每组测试数据第一行包含三个整数 n,m,s，分别表示车站数量，公交线路数量以及朋友家附近车站的编号。</p>
<p>接下来 m 行，每行包含三个整数 p,q,t，表示存在一条线路从车站 p 到达车站 q，用时为 t。</p>
<p>接下来一行，包含一个整数 w，表示琪琪家附近共有 w 个车站，她可以在这 w 个车站中选择一个车站作为始发站。</p>
<p>再一行，包含 w 个整数，表示琪琪家附近的 w 个车站的编号。</p>
<p>输出格式<br>每个测试数据输出一个整数作为结果，表示所需花费的最少时间。</p>
<p>如果无法达到朋友家的车站，则输出 -1。</p>
<p>每个结果占一行。</p>
<p>数据范围<br>n≤1000,m≤20000,<br>1≤s≤n,<br>0&lt; w &lt; n<br>0&lt; t ≤ 1000<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 8 5</span><br><span class="line">1 2 2</span><br><span class="line">1 5 3</span><br><span class="line">1 3 4</span><br><span class="line">2 4 7</span><br><span class="line">2 5 6</span><br><span class="line">2 3 5</span><br><span class="line">3 5 1</span><br><span class="line">4 5 1</span><br><span class="line">2</span><br><span class="line">2 3</span><br><span class="line">4 3 4</span><br><span class="line">1 2 3</span><br><span class="line">1 3 4</span><br><span class="line">2 3 2</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">-1</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于有多个起点但是有且仅有一个终点，我们可以反向建图，从多源点转化成单源点问题</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>, M = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M] ,ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> ed[N], dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, en, m, S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[S] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;dist[S], S&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>(); </span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j],j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m &gt;&gt; S)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            <span class="built_in">add</span>(b,a,c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; en;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; en; i ++)</span><br><span class="line">            cin &gt;&gt; ed[i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; en; i ++)</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, dist[ed[i]]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ans == INF) cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>AcWing 1293. 夏洛克和他的女朋友</title>
    <url>/2022/09/25/AcWing-1293-%E5%A4%8F%E6%B4%9B%E5%85%8B%E5%92%8C%E4%BB%96%E7%9A%84%E5%A5%B3%E6%9C%8B%E5%8F%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>AcWing 165. 小猫爬山(模版)</title>
    <url>/2022/11/02/AcWing-165-%E5%B0%8F%E7%8C%AB%E7%88%AC%E5%B1%B1-%E6%A8%A1%E7%89%88/</url>
    <content><![CDATA[<h2 id="AcWing-165-小猫爬山-模版"><a href="#AcWing-165-小猫爬山-模版" class="headerlink" title="AcWing 165. 小猫爬山(模版)"></a><a href="https://www.acwing.com/problem/content/description/167/">AcWing 165. 小猫爬山(模版)</a></h2><p>翰翰和达达饲养了 N 只小猫，这天，小猫们要去爬山。</p>
<p>经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕&gt;_&lt;）。</p>
<p>翰翰和达达只好花钱让它们坐索道下山。</p>
<p>索道上的缆车最大承重量为 W，而 N 只小猫的重量分别是 C1、C2……CN。</p>
<p>当然，每辆缆车上的小猫的重量之和不能超过 W。</p>
<p>每租用一辆缆车，翰翰和达达就要付 1 美元，所以他们想知道，最少需要付多少美元才能把这 N 只小猫都运送下山？</p>
<p>输入格式<br>第 1 行：包含两个用空格隔开的整数，N 和 W。</p>
<p>第 2..N+1 行：每行一个整数，其中第 i+1 行的整数表示第 i 只小猫的重量 Ci。</p>
<p>输出格式<br>输出一个整数，表示最少需要多少美元，也就是最少需要多少辆缆车。</p>
<p>数据范围<br>1≤N≤18,<br>1≤Ci≤W≤108<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 1996</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">1994</span><br><span class="line">12</span><br><span class="line">29</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>在这里的我们的枚举顺序是按猫进行枚举<br>在这里的举个列一共有10只猫，我们这里的枚举顺序是<br>假设从第二只猫开始枚举，应为第一只猫一定是新创一个缆车，让猫乘坐。那么对于第二只猫来说，这一只猫可以选择前面的猫做的缆车，也可以自己再开一辆车坐。随着枚举的猫越多，我们开辟的缆车就越多。剪枝的策略就是让当前节点的拓展分支越少越好，所以我们先按越重的越先上缆车。因为这样的话，当前缆车能上的猫的可能性就越小，所以对于后面的选择就会越小，所以分支数也就会越小。如果在前面的剪枝的话就能剪掉更多的分支数目。</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> sum[N]; <span class="comment">// 记录每辆缆车已经承重多少</span></span><br><span class="line"><span class="type">int</span> res = N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cost 既可以表示现在的花销也可以表示的意思是缆车的数目（因为一辆缆车一元）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> nu, <span class="type">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cost &gt;= res) <span class="keyword">return</span>; <span class="comment">// 最优解剪枝</span></span><br><span class="line">    <span class="keyword">if</span>(nu &gt;= n) <span class="comment">// 可行性剪枝</span></span><br><span class="line">    &#123;</span><br><span class="line">        res = cost;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上某一缆车</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cost; i ++)</span><br><span class="line">        <span class="comment">// 可行性剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(sum[i] + w[nu] &lt;= m) <span class="comment">// 这里的不用判断是否空车，如果换成不同价格的缆车还需要传递参数</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum[i] += w[nu];</span><br><span class="line">            <span class="built_in">dfs</span>(nu + <span class="number">1</span>, cost);</span><br><span class="line">            sum[i] -= w[nu];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自己一猫一车</span></span><br><span class="line">    sum[cost] = w[nu];</span><br><span class="line">    <span class="built_in">dfs</span>(nu + <span class="number">1</span>, cost + <span class="number">1</span>);</span><br><span class="line">    sum[cost] = <span class="number">0</span>; <span class="comment">// 无论哪一种递归方式都要</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w, w + n, cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>搜索</category>
        <category>dfs剪枝</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 166. 数独</title>
    <url>/2022/11/10/AcWing-166-%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h1 id="AcWing-166-数独"><a href="#AcWing-166-数独" class="headerlink" title="AcWing 166. 数独"></a><a href="https://www.acwing.com/problem/content/168/">AcWing 166. 数独</a></h1><p>数独 是一种传统益智游戏，你需要把一个 9×9 的数独补充完整，使得数独中每行、每列、每个 3×3 的九宫格内数字 1∼9 均恰好出现一次。</p>
<p>请编写一个程序填写数独。</p>
<p>输入格式<br>输入包含多组测试用例。</p>
<p>每个测试用例占一行，包含 81 个字符，代表数独的 81 个格内数据（顺序总体由上到下，同行由左到右）。</p>
<p>每个字符都是一个数字（1−9）或一个 .（表示尚未填充）。</p>
<p>您可以假设输入中的每个谜题都只有一个解决方案。</p>
<p>文件结尾处为包含单词 end 的单行，表示输入结束。</p>
<p>输出格式<br>每个测试用例，输出一行数据，代表填充完全后的数独。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>数独的规则</p>
<ol>
<li>每一行都包含了1～9</li>
<li>每一列都包含了1～9</li>
<li>每一个3x3都包含了1~9</li>
</ol>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的三个数组记录的是当前列/行/3x3内的所有合法方案</span></span><br><span class="line"><span class="type">int</span> col[N], row[N], cell[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> ones[<span class="number">1</span> &lt;&lt; N], mp[<span class="number">1</span> &lt;&lt; N];  <span class="comment">// ones数组记录的是某一个状态内有多少个1， mp记录的是1所在的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// init是对col, row, cell数组初始化操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里的初始化把col &amp; row 初始化为全1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++) col[i] = row[i] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++)</span><br><span class="line">            cell[i][j] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// is_set == true的时候表示修改现场</span></span><br><span class="line"><span class="comment">// is_set == fasle的时候表示恢复现场</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> t, <span class="type">bool</span> is_set)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(is_set) str[x * <span class="number">9</span> + y] = <span class="string">&#x27;1&#x27;</span> + t;</span><br><span class="line">    <span class="keyword">else</span> str[x * <span class="number">9</span> + y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v = <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">    <span class="keyword">if</span>(!is_set) v = -v;</span><br><span class="line"></span><br><span class="line">    row[x] -= v;</span><br><span class="line">    col[y] -= v;</span><br><span class="line">    cell[x/<span class="number">3</span>][y/<span class="number">3</span>] -= v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最低有效位</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前位置上的所有合法状态</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里类似使用了一个状压的技巧，把状态压缩成二进制</span></span><br><span class="line">    <span class="keyword">return</span> row[x] &amp; col[y] &amp; cell[x/<span class="number">3</span>][y/<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!cnt) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 可行性剪枝</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> minv = <span class="number">10</span>; <span class="comment">// 寻找最少的状态这一个点进行更新，原因是因为状态越少，分支数目越少</span></span><br><span class="line">    <span class="type">int</span> x ,y;   <span class="comment">// location</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++)</span><br><span class="line">            <span class="keyword">if</span>(str[i * <span class="number">9</span> + j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> state = <span class="built_in">get</span>(i,j);</span><br><span class="line">                <span class="keyword">if</span>(ones[state] &lt; minv)</span><br><span class="line">                &#123;</span><br><span class="line">                    minv = ones[state];</span><br><span class="line">                    x = i, y = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> state = <span class="built_in">get</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = state; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t= mp[<span class="built_in">lowbit</span>(i)]; <span class="comment">// 找出来最低位1对应的坐标</span></span><br><span class="line">        <span class="built_in">draw</span>(x,y,t,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(cnt<span class="number">-1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">draw</span>(x,y,t,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打表初始化ones数组和mp数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++) mp[<span class="number">1</span> &lt;&lt; i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; N; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++)</span><br><span class="line">            ones[i] += i &gt;&gt; j &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; str, str[<span class="number">0</span>] != <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 记录有多少个要填的数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j ++, k ++)</span><br><span class="line">                <span class="keyword">if</span>(str[k] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> t = str[k] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    <span class="built_in">draw</span>(i,j,t,<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(cnt);</span><br><span class="line">        <span class="built_in">puts</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>dfs</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 167. 木棒</title>
    <url>/2022/11/14/AcWing-167-%E6%9C%A8%E6%A3%92/</url>
    <content><![CDATA[<h1 id="AcWing-167-木棒"><a href="#AcWing-167-木棒" class="headerlink" title="AcWing 167. 木棒"></a><a href="https://www.acwing.com/problem/content/description/169/">AcWing 167. 木棒</a></h1><p>乔治拿来一组等长的木棒，将它们随机地砍断，使得每一节木棍的长度都不超过 50 个长度单位。</p>
<p>然后他又想把这些木棍恢复到为裁截前的状态，但忘记了初始时有多少木棒以及木棒的初始长度。</p>
<p>请你设计一个程序，帮助乔治计算木棒的可能最小长度。</p>
<p>每一节木棍的长度都用大于零的整数表示。</p>
<p>输入格式<br>输入包含多组数据，每组数据包括两行。</p>
<p>第一行是一个不超过 64 的整数，表示砍断之后共有多少节木棍。</p>
<p>第二行是截断以后，所得到的各节木棍的长度。</p>
<p>在最后一组数据之后，是一个零。</p>
<p>输出格式<br>为每组数据，分别输出原始木棒的可能最小长度，每组数据占一行。</p>
<p>数据范围<br>数据保证每一节木棍的长度均不大于 50。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">5 2 1 5 2 1 5 2 1</span><br><span class="line">4</span><br><span class="line">1 2 3 4</span><br><span class="line">0</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>在这里剪枝主要是有四种</p>
<ol>
<li>优化搜索顺序<br>从大到小进行枚举，具体原因可以看<a href="AcWing-165-小猫爬山-模版.md">小猫爬山</a></li>
<li>排除等效冗余<ol>
<li>按照组合数方式进行枚举，这里的组合数方式主要是通过的对每个木棒进行编号处理，每次枚举从编号小到大进行枚举</li>
<li>如果当前木棒加到当前棒中，失败了。则直接略过后面所有和其长度相等的木棒</li>
<li>如果木棒的第一个枚举到最后失败了则一定失败</li>
<li>如果木棒的最后一根枚举到最后失败了则一定失败</li>
</ol>
</li>
</ol>
<p><strong>证明</strong></p>
<p><em>2-2剪枝</em></p>
<p>假设a = 10，b = 10，a放在某一根木棒内部的时候失败了，意味这我这根木棒应该放在新的木棒里面。因为木棒是按大小排号序的（即使不排序也不会影响我们的结论），如果这个木棒放在同一个位置上搜索出来一个合法方案。这样就意味这一个位置上的木棒应该是能和其相同大小的木棒进行交换的。这样就和我们的木棒a放在同一个地方搜索不出来的合法方案的情况矛盾了。</p>
<p><em>2-3剪枝</em></p>
<p>如果木棒放在第一个失败了，那么就意味其是否应该放入木棒中间或最后。但是如果可以放在中间或者最后的话，就意味在同一根木板内部是可以相互交换顺序的，所以矛盾。</p>
<p>可能通过上面的证明大家可能感觉有些奇怪，如果我用相同论证方式也可以论证出来同一根中间失败了，其就失败了，但是很明显这个结论绝对是错误的。那为什么同一个论证方式却失败了？？</p>
<p>我们可以想的时候，2-3的论证是无论木棒在哪一根大木棒当中，只要方案成立都是可以在木棒内部的首部进行交换顺序的，这时候他处于哪一根木棒的首部都是没有任何影响的。但是对于中间某一根木棒，他是否对与处于哪一根木棒的某一个位置都不会影响呢？？很明显并不是，他是很木棒内部的组合息息相关的。</p>
<p><em>2-4剪枝</em></p>
<p>这个可以在木棒内部转换成木棒的首部，然后通过2-3剪枝的证得，如果木棒处于最后一根木棒的时候失败了就可以提前剪枝了</p>
<p><strong>这里的提前剪枝是不用再去枚举当前木棒的之后的所有可能的组合方案了，所以剪枝的思想也要考虑的是当前木棒所有方案的前提下</strong></p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">70</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> sum, length;    <span class="comment">// sum 表示总长度， length 表示木棒的长度（我们要找出所有木棒中的最小长度）</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> cur, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u * length == sum) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果木棒的数目*每根木棒的长度等于总长度的时候就表示我们已经排出来一种可行性方案</span></span><br><span class="line">    <span class="comment">// 这里的dfs从0开始的原因是因为前面可能有些数并没有用上，所以在这里需要重头开始枚举</span></span><br><span class="line">    <span class="keyword">if</span>(cur == length) <span class="keyword">return</span> <span class="built_in">dfs</span>(u + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 如果当前木棒已经达到我们要求的长度的话，就需要进行开辟一个新的木棒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前木棒在前面选择了就不选者，如果当前加上小木棒的值超出我们要求的木棒长度也进行剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(st[i] || cur + w[i] &gt; length) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择当前小木棒作为组合方案</span></span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(u,cur+w[i], i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        st[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前一根是不合法的状态</span></span><br><span class="line">        <span class="comment">// 如果前这一根处于首部和尾部的状态的话</span></span><br><span class="line">        <span class="keyword">if</span>(!cur || cur + w[i] == length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相同长度的如果不合法，那么其他的也不会合法</span></span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; w[j] == w[i]) j ++;</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; w[i];</span><br><span class="line">            sum += w[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(w,w + n);</span><br><span class="line">        <span class="built_in">reverse</span>(w,w+n);</span><br><span class="line">        <span class="keyword">for</span>(length = <span class="number">1</span>; length &lt;= sum; length ++)</span><br><span class="line">            <span class="keyword">if</span>(! (sum % length)  &amp;&amp; <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">            &#123;    </span><br><span class="line">                cout &lt;&lt; length &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>搜索</category>
        <category>dfs剪枝</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 168. 生日蛋糕</title>
    <url>/2022/11/15/AcWing-168-%E7%94%9F%E6%97%A5%E8%9B%8B%E7%B3%95/</url>
    <content><![CDATA[<h1 id="AcWing-168-生日蛋糕"><a href="#AcWing-168-生日蛋糕" class="headerlink" title="AcWing 168. 生日蛋糕"></a><a href="https://www.acwing.com/problem/content/170/">AcWing 168. 生日蛋糕</a></h1><p>7 月 17 日是 Mr.W 的生日，ACM-THU 为此要制作一个体积为 Nπ 的 M 层生日蛋糕，每层都是一个圆柱体。</p>
<p>设从下往上数第 i 层蛋糕是半径为 Ri，高度为 Hi 的圆柱。</p>
<p>当 i<M 时，要求 Ri>Ri+1 且 Hi&gt;Hi+1。</p>
<p>由于要在蛋糕上抹奶油，为尽可能节约经费，我们希望蛋糕外表面（最下一层的下底面除外）的面积 Q 最小。</p>
<p>令 Q=Sπ ，请编程对给出的 N 和 M，找出蛋糕的制作方案（适当的 Ri 和 Hi 的值），使 S 最小。</p>
<p>除 Q 外，以上所有数据皆为正整数。</p>
<p>输入格式<br>输入包含两行，第一行为整数 N，表示待制作的蛋糕的体积为 Nπ。</p>
<p>第二行为整数 M，表示蛋糕的层数为 M。</p>
<p>输出格式<br>输出仅一行，是一个正整数 S（若无解则 S=0）。</p>
<p>数据范围<br>1≤N≤10000,<br>1≤M≤20<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">2</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">68</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>表面积：</strong></p>
<p>上表面面积：从上往下投影，可以的发现最后的投影面积之和是最底面上表面面积</p>
<script type="math/tex; mode=display">S_底 = R_m^2</script><p>侧面的面积：</p>
<script type="math/tex; mode=display">\sum_{i=1}^m 2R_ih_i</script><p><strong>搜索顺序剪枝</strong></p>
<p>层间：自下往上</p>
<p>层内：由于R是带平方项的，所以先枚举R再枚举H。都是从大到小开始进行枚举。</p>
<p><strong>可行性剪枝</strong></p>
<p>首先做一步定义：</p>
<p>蛋糕的从上面往下层来说依次从<code>1</code>开始编号</p>
<p>预处理两个数组<code>minv(u)</code>, <code>maxs(u)</code></p>
<p><code>minv(u)</code>: 表示前u层最小体积是多少</p>
<ul>
<li>这里剪枝是 $V_{m \to u} + minv(u) \leq V$</li>
</ul>
<p>表示的意思是从最下层到当前第u层现在这个方案下的体积V之和，加上上面的u成最小体积之和比我们预定的体积要大的话，表示一定不可行，所以一定要进行剪枝</p>
<p><strong>同理对于表面积也有同样的剪枝</strong></p>
<p><code>mins(u)</code>：表示前u层最小表面积是多少</p>
<ul>
<li>这里剪枝是 $S_{m \to u} + mins(u) &lt; ans$</li>
</ul>
<p>对第u层的半径和高度进行剪枝</p>
<p><strong>题目上的要求</strong>，对于半径和高度来说，其的数值大小都是需要递增的</p>
<p><strong>半径</strong></p>
<ul>
<li>当前层最小值一定是<code>u</code>，第一层半径为1，然后依次加最小步长<code>1</code></li>
<li>第u层体积的最大值除第u层高度的最小值u</li>
</ul>
<p><strong>半径剪枝</strong></p>
<script type="math/tex; mode=display">u \leq R_u \leq min({ R_{u+1} - 1, \sqrt{ \frac{n - minv(u-1) - V_{m \to u + 1}}{u} } })</script><p><strong>高度</strong></p>
<ul>
<li>当前层最小值一定是<code>u</code>，第一层高度为1，然后依次加最小步长<code>1</code></li>
<li>第u层体积的最大值除第u层的底面积最小值</li>
</ul>
<p><strong>高度剪枝</strong></p>
<script type="math/tex; mode=display">u \leq H_u \leq min(H_{u+1} - 1, \frac{n - minv(u-1) - V_{m \to u + 1}}{R_u^2})</script><p><strong>表面积和体积公式之间的关系</strong></p>
<p>表面积公式：</p>
<script type="math/tex; mode=display">S_{1 \to u} = 2 \sum_{i=1}^u R_i H_i = \frac{2}{R_{u+1}} \sum_{i=1}^u R_{u+1} R_u H_i > \frac{2}{R_{u+1}} \sum_{i=1}^u R_i^2 H_i</script><p>体积公式：</p>
<script type="math/tex; mode=display">n - V_{m \to u-1} = \sum_{i=1}^u R_i^2 H_i</script><p>所以有最后的公式</p>
<script type="math/tex; mode=display">S_{1 \to u} > \frac{2 ( n - V_{m \to u-1}) } {R_{u+1}}</script><p><strong>$S<em>总 = S + S</em>{1 \to u} \geq S_{ans}$就可以剪枝了</strong></p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>; <span class="comment">// 最多只有20层</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> R[N], H[N];</span><br><span class="line"><span class="type">int</span> minv[N], mins[N]; <span class="comment">// minv[u] 表示从第一层到第u层（从上往下）的最小体积之和是多少</span></span><br><span class="line"><span class="type">int</span> n, m, ans = INF; <span class="comment">// n 表示体积 m 表示层数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// u表示当前是哪一层</span></span><br><span class="line"><span class="comment">// v表示从最下一层到本层的体积之和</span></span><br><span class="line"><span class="comment">// s表示从最下层到本层的表面积之和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v + minv[u] &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(s + mins[u] &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(s + <span class="number">2</span> * (n-v) / R[u + <span class="number">1</span>] &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">if</span>(!u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v == n) ans = s;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举本层合法方案</span></span><br><span class="line">    <span class="comment">// 第一层枚半径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r = <span class="built_in">min</span>( R[u+<span class="number">1</span>] - <span class="number">1</span>, (<span class="type">int</span>)<span class="built_in">sqrt</span>( (n - minv[u<span class="number">-1</span>] - v) / u ) ); r &gt;= u; r --) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> h = <span class="built_in">min</span>( H[u+<span class="number">1</span>] - <span class="number">1</span>, (n - minv[u<span class="number">-1</span>] - v) / r / r ); h &gt;= u; h --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(u == m) t = r * r; <span class="comment">// 最下层半径决定了整个蛋糕的投影面积</span></span><br><span class="line">            R[u] = r, H[u] = h;</span><br><span class="line">            <span class="built_in">dfs</span>(u - <span class="number">1</span>, v + r * r * h, s + <span class="number">2</span> * r * h + t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 预处理minv &amp; mins数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        minv[i] = minv[i<span class="number">-1</span>] + i * i * i;</span><br><span class="line">        mins[i] = mins[i<span class="number">-1</span>] + <span class="number">2</span> * i * i; <span class="comment">// 这一层高度和半径都最小都是i（步长为1）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    R[m + <span class="number">1</span>] = H[m + <span class="number">1</span>] = INF; <span class="comment">// 哨兵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化搜索顺序，从下往上层开始枚举</span></span><br><span class="line">    <span class="built_in">dfs</span>(m,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ans == INF) ans = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>搜索</category>
        <category>dfs剪枝</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>dfs剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 178. 第K短路</title>
    <url>/2022/09/16/AcWing-178-%E7%AC%ACK%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>AcWing</category>
        <category>搜索</category>
        <category>A-star</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>A-start</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 179. 八数码(A-star算法模版)</title>
    <url>/2022/09/15/AcWing-179-%E5%85%AB%E6%95%B0%E7%A0%81/</url>
    <content><![CDATA[<h2 id="AcWing-179-八数码-A-star算法模版"><a href="#AcWing-179-八数码-A-star算法模版" class="headerlink" title="AcWing 179. 八数码(A-star算法模版)"></a><a href="https://www.acwing.com/problem/content/181/">AcWing 179. 八数码(A-star算法模版)</a></h2><p>在一个 3×3 的网格中，1∼8 这 8 个数字和一个 X 恰好不重不漏地分布在这 3×3 的网格中。</p>
<p>例如：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">X 4 6</span><br><span class="line">7 5 8</span><br></pre></td></tr></table></figure><br>在游戏过程中，可以把 X 与其上、下、左、右四个方向之一的数字交换（如果存在）。</p>
<p>我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 X</span><br></pre></td></tr></table></figure><br>例如，示例中图形就可以通过让 X 先后与右、下、右三个方向的数字交换成功得到正确排列。</p>
<p>交换过程如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3   1 2 3   1 2 3   1 2 3</span><br><span class="line">X 4 6   4 X 6   4 5 6   4 5 6</span><br><span class="line">7 5 8   7 5 8   7 X 8   7 8 X</span><br></pre></td></tr></table></figure><br>把 X 与上下左右方向数字交换的行动记录为 u、d、l、r。</p>
<p>现在，给你一个初始网格，请你通过最少的移动次数，得到正确排列。</p>
<p>输入格式<br>输入占一行，将 3×3 的初始网格描绘出来。</p>
<p>例如，如果初始网格如下所示：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 </span><br><span class="line">x 4 6 </span><br><span class="line">7 5 8 </span><br></pre></td></tr></table></figure><br>则输入为：<code>1 2 3 x 4 6 7 5 8</code></p>
<p>输出格式<br>输出占一行，包含一个字符串，表示得到正确排列的完整行动记录。</p>
<p>如果答案不唯一，输出任意一种合法方案即可。</p>
<p>如果不存在解决方案，则输出 unsolvable。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2  3  4  1  5  x  7  6  8 </span><br></pre></td></tr></table></figure><br>输出样例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ullddrurdllurdruldr</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>A-Star 算法实际上就是基于dijkstra的演变</p>
<p>A<em>算法需要一个估价函数，这个估计函数估计的是当前状态节点到目标状态节点的之间的估计代价值。<br><em>*估计函数的要求</em></em>：<code>一定要比实际上该点数值到目标状态点的数值要小</code><br>小根堆内维护的是实际上当前的节点到初始节点的实际距离+当前节点到目标节点的估计距离</p>
<p><strong>Astart算法的重要结论</strong></p>
<ul>
<li>所有的节点可能会进队多次，出队多次。但目标节点只会出队一次，且出队得到的数值是最优解。</li>
<li>出队即为最优值是针对的是终点来说</li>
</ul>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,string&gt; PIS;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 估计函数， 使用曼哈顿距离进行估计</span></span><br><span class="line"><span class="comment">// 曼哈顿距离是在网格图上的最短距离，所以这个估计值一定是比实际值要小于等于的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">h</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; state.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        <span class="keyword">if</span>(state[i] != <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = state[i] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            <span class="comment">// 曼哈顿距离</span></span><br><span class="line">            res += <span class="built_in">abs</span>(i/<span class="number">3</span> - t/<span class="number">3</span>) + <span class="built_in">abs</span>(i%<span class="number">3</span> - t%<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">astar</span><span class="params">(string start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">4</span>] = &#123;<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;u&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    string end = <span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line">    <span class="comment">// dist[state] 表示state这个状态距离初始状态的最短路径</span></span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; dist;</span><br><span class="line">    unordered_map&lt;string, pair&lt;string,<span class="type">char</span>&gt;&gt; prev;</span><br><span class="line">    priority_queue&lt;PIS,vector&lt;PIS&gt;, greater&lt;PIS&gt;&gt; heap;</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="built_in">h</span>(start),start&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        string state = t.second;</span><br><span class="line">        <span class="type">int</span> cost = dist[state]; <span class="comment">// 当前点到源点的最短距离</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到目标状态直接剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(state == end) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出空格的位置，在空的坐标上下左右都可以向这个空格移动 </span></span><br><span class="line">        <span class="type">int</span> x,y; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; state.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            <span class="keyword">if</span>(state[i] == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x = i / <span class="number">3</span>;</span><br><span class="line">                y = i % <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对这个空格坐标上下左右进行更新</span></span><br><span class="line">        string source = state;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cx = x + dx[i], cy = y + dy[i];</span><br><span class="line">            <span class="comment">// 不合法状态</span></span><br><span class="line">            <span class="keyword">if</span>(cx &lt; <span class="number">0</span> || cx &gt;= <span class="number">3</span> || cy &lt; <span class="number">0</span> || cy &gt;= <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 拓展节点</span></span><br><span class="line">            state = source;</span><br><span class="line">            <span class="built_in">swap</span>(state[x * <span class="number">3</span> + y], state[cx * <span class="number">3</span> + cy]);</span><br><span class="line">            <span class="comment">// 如果当前的节点没有被更新或当前节点到源点的距离需要更新</span></span><br><span class="line">            <span class="keyword">if</span>(!dist.<span class="built_in">count</span>(state) || dist[state] &gt; cost + <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                dist[state] = cost + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// prev[state] 表示状态为state，前驱状态为source, 转移的操作为 op[i]</span></span><br><span class="line">                prev[state] =&#123;source,op[i]&#125;;</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[state] + <span class="built_in">h</span>(state),state&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">while</span>(end != start)</span><br><span class="line">    &#123;</span><br><span class="line">        res += prev[end].second;</span><br><span class="line">        end = prev[end].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将所有的状态表示从一维的形式，存放在g中</span></span><br><span class="line">    <span class="comment">// seq 是为了计算出来当前的初始状态-&gt;目标状态是否有解</span></span><br><span class="line">    <span class="comment">// 有解的情况:普通的情况是初始状态和目标状态之间的逆序对的奇偶性不发生变化</span></span><br><span class="line">    <span class="comment">// 在这里目标状态的逆序对为0，即当初始状态为逆序对偶数的时候有解，否则反之</span></span><br><span class="line">    string g, c, seq;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; c)</span><br><span class="line">    &#123;</span><br><span class="line">        g += c;</span><br><span class="line">        <span class="keyword">if</span>(c != <span class="string">&quot;x&quot;</span>) seq += c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断逆序对的奇偶性</span></span><br><span class="line">    <span class="comment">// 通用的解法</span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; seq.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; seq.<span class="built_in">size</span>(); j ++)</span><br><span class="line">            <span class="keyword">if</span>(seq[i] &gt; seq[j])</span><br><span class="line">                t ++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t % <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;unsolvable&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">astar</span>(g) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模版</category>
        <category>搜索</category>
        <category>A-star</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>A-start</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 190. 字串变换</title>
    <url>/2022/10/23/AcWing-190-%E5%AD%97%E4%B8%B2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="AcWing-190-字串变换"><a href="#AcWing-190-字串变换" class="headerlink" title="AcWing 190. 字串变换"></a><a href="https://www.acwing.com/problem/content/192/">AcWing 190. 字串变换</a></h2><p>已知有两个字串 A, B 及一组字串变换的规则（至多 6 个规则）:</p>
<p>A1→B1<br>A2→B2<br>…</p>
<p>规则的含义为：在 A 中的子串 A1 可以变换为 B1、A2 可以变换为 B2…。</p>
<p>例如：A＝abcd B＝xyz</p>
<p>变换规则为：</p>
<p>abc → xu ud → y y → yz</p>
<p>则此时，A 可以经过一系列的变换变为 B，其变换的过程为：</p>
<p>abcd → xud → xy → xyz</p>
<p>共进行了三次变换，使得 A 变换为 B。</p>
<p>输入格式<br>输入格式如下：</p>
<p>A B<br>A1 B1<br>A2 B2<br>… …</p>
<p>第一行是两个给定的字符串 A 和 B。</p>
<p>接下来若干行，每行描述一组字串变换的规则。</p>
<p>所有字符串长度的上限为 20。</p>
<p>输出格式<br>若在 10 步（包含 10 步）以内能将 A 变换为 B ，则输出最少的变换步数；否则输出 NO ANSWER!。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcd xyz</span><br><span class="line">abc xu</span><br><span class="line">ud y</span><br><span class="line">y yz</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>双向bfs是单向bfs的一种优化，所谓双向就是从源点和终点开始搜索，在中间状态会相遇这时搜索出来的最优状态的就是我们所搜的状态，在一般情下的搜索空间会少不少。<br>双向bfs主要用于的状态数目较大，单向bfs会T的情况。对于状态数目不大的情况，双向bfs优化空间比较小。</p>
<p>这里还涉及到双路bfs问题</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string A, B; <span class="comment">// 原始字符串和目标字符串</span></span><br><span class="line">string a[N], b[N]; <span class="comment">// 规则</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(queue&lt;string&gt; &amp;q, unordered_map&lt;string,<span class="type">int</span>&gt; &amp;da, unordered_map&lt;string,<span class="type">int</span>&gt; &amp;db, string a[N], string b[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 双向bfs需要一整层的进行拓展</span></span><br><span class="line">    <span class="comment">// 这里的拓展是拓展同当前队列队首元素同一层的元素，所以要用d进行判别</span></span><br><span class="line">    <span class="type">int</span> d = da[q.<span class="built_in">front</span>()];</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>() &amp;&amp; da[q.<span class="built_in">front</span>()] == d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 找当前元素有没有符合规矩的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; t.<span class="built_in">size</span>(); j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(t.<span class="built_in">substr</span>(j,a[i].<span class="built_in">size</span>()) == a[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 把中间a[i]串拿出来进行替换</span></span><br><span class="line">                    string r = t.<span class="built_in">substr</span>(<span class="number">0</span>,j) + b[i] + t.<span class="built_in">substr</span>(j + a[i].<span class="built_in">size</span>());</span><br><span class="line">                    <span class="keyword">if</span>(db.<span class="built_in">count</span>(r)) <span class="keyword">return</span> da[t] + db[r] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(da.<span class="built_in">count</span>(r)) <span class="keyword">continue</span>;</span><br><span class="line">                    da[r] = da[t] + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有相遇的情况，为了在bfs下再拓展所以这里返回值&gt;10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == B) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    queue&lt;string&gt; qa,qb; <span class="comment">// 两路bfs</span></span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; da, db; <span class="comment">// 记录的是a队列内部的数据步长</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别以两个端点作为起点</span></span><br><span class="line">    <span class="comment">// 两路bfs</span></span><br><span class="line">    qa.<span class="built_in">push</span>(A), qb.<span class="built_in">push</span>(B);</span><br><span class="line">    da[A] = db[B] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里记步数作为提前剪枝作用</span></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果有任何一个队列为空表示其搜索完所有的状态这时候如果都找不到我们的目标状态那么说明不存在</span></span><br><span class="line">    <span class="keyword">while</span>(qa.<span class="built_in">size</span>() &amp;&amp; qb.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="comment">// 这里比较随意，这里拓展我们就按那个队列比较短就谁先开始拓展</span></span><br><span class="line">        <span class="keyword">if</span>(qa.<span class="built_in">size</span>() &lt; qb.<span class="built_in">size</span>()) t = <span class="built_in">extend</span>(qa, da, db, a, b);</span><br><span class="line">        <span class="keyword">else</span> t = <span class="built_in">extend</span>(qb, db, da, b, a);  <span class="comment">// 反向拓展要记得b往a方向</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t &lt;= <span class="number">10</span>) <span class="keyword">return</span> t;</span><br><span class="line">        <span class="keyword">if</span>(++ step == <span class="number">10</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a[n] &gt;&gt; b[n]) n ++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;NO ANSWER!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>搜索</category>
        <category>双向广搜</category>
      </categories>
      <tags>
        <tag>双向bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 340. 通信线路</title>
    <url>/2022/09/01/AcWing-340-%E9%80%9A%E4%BF%A1%E7%BA%BF%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="AcWing-340-通信线路"><a href="#AcWing-340-通信线路" class="headerlink" title="AcWing 340. 通信线路"></a><a href="https://www.acwing.com/problem/content/342/">AcWing 340. 通信线路</a></h2><p>在郊区有 N 座通信基站，P 条 双向 电缆，第 i 条电缆连接基站 Ai 和 Bi。</p>
<p>特别地，1 号基站是通信公司的总站，N 号基站位于一座农场中。</p>
<p>现在，农场主希望对通信线路进行升级，其中升级第 i 条电缆需要花费 Li。</p>
<p>电话公司正在举行优惠活动。</p>
<p>农产主可以指定一条从 1 号基站到 N 号基站的路径，并指定路径上不超过 K 条电缆，由电话公司免费提供升级服务。</p>
<p>农场主只需要支付在该路径上剩余的电缆中，升级价格最贵的那条电缆的花费即可。</p>
<p>求至少用多少钱可以完成升级。</p>
<p>输入格式<br>第 1 行：三个整数 N，P，K。</p>
<p>第 2..P+1 行：第 i+1 行包含三个整数 Ai,Bi,Li。</p>
<p>输出格式<br>包含一个整数表示最少花费。</p>
<p>若 1 号基站与 N 号基站之间不存在路径，则输出 −1。</p>
<p>数据范围<br>0 ≤ K &lt; N ≤ 1000<br>1 ≤ P ≤ 10000,<br>1 ≤ Li ≤ 1000000<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 7 1</span><br><span class="line">1 2 5</span><br><span class="line">3 1 4</span><br><span class="line">2 4 8</span><br><span class="line">3 2 3</span><br><span class="line">5 2 9</span><br><span class="line">3 4 7</span><br><span class="line">4 5 6</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>根据题意：我们知道在这个图上的某两个点之间的所有路径去除K条最贵的路径，剩下的所有边权最大值最小。</p>
<ul>
<li>与最小生成树做对比：这里是路径，是没有必要经过所有的点，所以如果使用kruscal可能求出来的解不对</li>
<li>与最短路径做对比：在极端的情况下最短路径的次大值可能比更长的路径的最大值要大，所以要是求出最短路径然后再求出次大值这样求出来的答案也不一定是正确的</li>
</ul>
<p>不严谨来讲，本题也就是要求第<code>k+1</code>大的边最小(最大值最小 —&gt; 二分思想)<br>但路径上的边数小于<code>K</code>条,那么说明所有的边都被干掉，最优解为<code>0</code></p>
<p>要使用二分就一定要具有二段性的性质（也就是说答案的左边是一个性质，答案的右边是另外一个性质）<br>假设答案定义的在[0,1000001]区间上<br>对于区间中的某一个点<code>x</code>，求出从<code>1</code>走到<code>N</code>中，最少经过几条长度大于<code>x</code>的边，假设最少经过<code>y</code>条。<br>性质的结果就是<code>y &lt;= k</code>。</p>
<p>证明这个性质成立</p>
<ul>
<li>x右区间所有点满足性质<br>所有的路径中的最少经过的长度大于<code>x</code>的边为<code>y</code>条，并且在当前区间为<code>x</code>点下, <code>y &lt;= k</code>，也就是说答案在比x大的情况下一定成立，那么x的右边区域就满足性质。</li>
<li>x的左区间所有点都不满足性质<br>反证法：假设存在一个点满足性质，那么这个点一定是我们答案x’点（因为答案右区间一定满足性质，如果当前的点右区间满足性质，那么答案一定会被更新到这个点上），这样就和我们前提答案为x点矛盾。</li>
</ul>
<p>区间取到<code>0</code> 与 <code>1000001</code></p>
<ul>
<li>取到0时，路径上的边数小于<code>K</code>，这样子答案就为0</li>
<li>取到1000001时，由于本题是又可能<code>1-&gt;N</code>之间不存在路径的，所以是有可能存在无解的情况，如果区间的不取到<code>1000001</code>，而是取到的<code>1000000</code>时，有可能最大值和无解都重合在<code>1000000</code>这个点上具有二义性，所以为了区分情况，多设置了一个点表示无解的情况.</li>
</ul>
<p>求出从1到N最少经过几条长度大于x的边<br>可以将所有的边进行分类，当前边权大于x的边，边权重新设置为1；当前边权小于等于x的边设为0.<br>这样的话，一个图上只有两种边权不是0/1.我们就可以使用双端队列bfs来求出最短路（最短路也就是0越少越好，最短路边权等于大于x的边的数目）</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">20010</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;   <span class="comment">// save 0/1</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> bound)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// deque find the shortest path</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st); <span class="comment">// means all point not update</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// like dijstra</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(st[t]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update dist </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i], v = w[i] &gt; bound; <span class="comment">// value &gt; bound set &#x27;1&#x27; or set &#x27;0&#x27;</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + v) </span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + v;</span><br><span class="line">                <span class="keyword">if</span>(!v) q.<span class="built_in">push_front</span>(j);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的最短路边权值等于大于bound的边数，如果边数比k还要小的话，那么答案应该</span></span><br><span class="line">    <span class="keyword">return</span> dist[n] &lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binary_search</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1000001</span>; <span class="comment">// [0,1e6 + 1]</span></span><br><span class="line">    <span class="comment">// find the minimum of all maximums</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 检查当前的点是否满足性质 y &lt;= k</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid; <span class="comment">//  if statisfy find the lefe interval </span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">1e6</span> + <span class="number">1</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>图论</category>
        <category>最短路</category>
        <category>与二分结合</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 341 最优贸易</title>
    <url>/2022/09/03/AcWing-341-%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93/</url>
    <content><![CDATA[<h2 id="AcWing-341-最优贸易"><a href="#AcWing-341-最优贸易" class="headerlink" title="AcWing 341 最优贸易"></a><a href="https://www.acwing.com/problem/content/343/">AcWing 341 最优贸易</a></h2><p>C 国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。</p>
<p>任意两个城市之间最多只有一条道路直接相连。</p>
<p>这 m 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。</p>
<p>C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。</p>
<p>但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。</p>
<p>商人阿龙来到 C 国旅游。</p>
<p>当他得知“同一种商品在不同城市的价格可能会不同”这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚一点旅费。</p>
<p>设 C 国 n 个城市的标号从 1∼n，阿龙决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。</p>
<p>在旅游的过程中，任何城市可以被重复经过多次，但不要求经过所有 n 个城市。</p>
<p>阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。</p>
<p>因为阿龙主要是来 C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。</p>
<p>现在给出 n 个城市的水晶球价格，m 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。</p>
<p>请你告诉阿龙，他最多能赚取多少旅费。</p>
<p>注意：本题数据有加强。</p>
<p>输入格式<br>第一行包含 2 个正整数 n 和 m，中间用一个空格隔开，分别表示城市的数目和道路的数目。</p>
<p>第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 n 个城市的商品价格。</p>
<p>接下来 m 行，每行有 3 个正整数，x，y，z，每两个整数之间用一个空格隔开。</p>
<p>如果 z=1，表示这条道路是城市 x 到城市 y 之间的单向道路；如果 z=2，表示这条道路为城市 x 和城市 y 之间的双向道路。</p>
<p>输出格式<br>一个整数，表示答案。</p>
<p>数据范围<br>1≤n≤100000,<br>1≤m≤500000,<br>1≤各城市水晶球价格≤100<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">4 3 5 6 1</span><br><span class="line">1 2 1</span><br><span class="line">1 4 1</span><br><span class="line">2 3 2</span><br><span class="line">3 5 1</span><br><span class="line">4 5 2</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="要知道dp是如何和最短路结合的并且是可以结合条件是什么？？"><a href="#要知道dp是如何和最短路结合的并且是可以结合条件是什么？？" class="headerlink" title="要知道dp是如何和最短路结合的并且是可以结合条件是什么？？"></a>要知道dp是如何和最短路结合的并且是可以结合条件是什么？？</h3><p>对于一个具有依赖关系的dp问题<br> 比如<br> dp[2] = min(dp[1] + 1,dp[4] + 1)<br> dp[3] = dp[2] + 1<br> dp[4] = dp[3] + 1<br> dp[5] = dp[4] + 1<br>画出状态转移图，这样就知道了这是一个带环的但是知道每条边的边权都是为正，但是图上没有带负数环所以是可以用最短路来求的。</p>
<p><strong>总结：</strong> 能用最短路来求dp问题的前提条件是的状态转移图不存在负环，且在这个图上由于具有环结构所以是不能用dp的状态转移来求</p>
<p>本题的状态转移和状态划分</p>
<ul>
<li>对于求方案数类型的dp问题要求状态划分做到不重不漏</li>
<li>对于求最优解类型的dp问题最低要求状态划分做到不漏（可以重复）</li>
</ul>
<p>所以对于本题的状态划分为对每个节点的来说在这个节点之前购买的最低价格和在这个节点之后卖出最高价格<br>最后的答案就等于ans = dpmax[i] - dpmin[i]</p>
<p><strong>本题要注意的是，只有点权没有边权，并且点权是不能放在边权上面的。</strong><br>dijkstra实际上就是利用了贪心的思想具有局部最优解—&gt;全局最优解，并且每个点只会被更新一次<br> 如果当前<code>dmin[i]</code> 最小的点是<code>5，</code>那么有可能存在边 5-&gt; 6, 6-&gt; 7, 7-&gt; 5，假设当前<code>dmin[5] = 10</code>，则有可能存在<code>6</code>的价格是11， 但 <code>7</code> 的价格是3，那么<code>dmin[5]</code>的值就应该被更新成3，因此当前最小值也不一定是最终最小值，所以dijkstra算法并不适用，我们只能采用 spfa 算法。</p>
<p><code>SPFA</code>算法最坏的时间复杂度为nm = 100000 * 5000000 ,但是不卡数据的情况下时间复杂度大概在O(m)</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">500000</span> * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> zh[N], rh[N], w[N], e[M], ne[M], idx; </span><br><span class="line"><span class="type">int</span> dpmin[N],dpmax[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> h[],<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> dp[], <span class="type">int</span> S, <span class="type">int</span> h[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dpmin);<span class="comment">// 要求最短路</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dpmax);</span><br><span class="line"></span><br><span class="line">    st[S] = <span class="literal">true</span>;</span><br><span class="line">    dp[S] =  w[S];</span><br><span class="line">    q[hh] = S;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>; <span class="comment">// 循环队列 </span></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(S == <span class="number">1</span> &amp;&amp; dp[j] &gt; <span class="built_in">min</span>(dp[t], w[j]) || S == n &amp;&amp; dp[j] &lt; <span class="built_in">max</span>(dp[t], w[j]) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(S == <span class="number">1</span>) dp[j] = <span class="built_in">min</span>(dp[t], w[j]);</span><br><span class="line">                <span class="keyword">else</span> dp[j] = <span class="built_in">max</span>(dp[t],w[j]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt ++] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(zh, <span class="number">-1</span>, <span class="keyword">sizeof</span> zh);</span><br><span class="line">    <span class="built_in">memset</span>(rh, <span class="number">-1</span>, <span class="keyword">sizeof</span> rh);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(zh, a, b), <span class="built_in">add</span>(rh, b, a);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">add</span>(zh, b, a), <span class="built_in">add</span>(rh, a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spfa</span>(dpmin, <span class="number">1</span>, zh);</span><br><span class="line">    <span class="built_in">spfa</span>(dpmax, n, rh);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = -INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dpmax[i] - dpmin[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>图论</category>
        <category>最短路</category>
        <category>与dp结合</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 342 道路与航线</title>
    <url>/2022/09/02/AcWing-342-%E9%81%93%E8%B7%AF%E4%B8%8E%E8%88%AA%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="AcWing-342-道路与航线"><a href="#AcWing-342-道路与航线" class="headerlink" title="AcWing 342 道路与航线"></a><a href="https://www.acwing.com/problem/content/342/">AcWing 342 道路与航线</a></h2><p>在郊区有 N 座通信基站，P 条 双向 电缆，第 i 条电缆连接基站 Ai 和 Bi。</p>
<p>特别地，1 号基站是通信公司的总站，N 号基站位于一座农场中。</p>
<p>现在，农场主希望对通信线路进行升级，其中升级第 i 条电缆需要花费 Li。</p>
<p>电话公司正在举行优惠活动。</p>
<p>农产主可以指定一条从 1 号基站到 N 号基站的路径，并指定路径上不超过 K 条电缆，由电话公司免费提供升级服务。</p>
<p>农场主只需要支付在该路径上剩余的电缆中，升级价格最贵的那条电缆的花费即可。</p>
<p>求至少用多少钱可以完成升级。</p>
<p>输入格式<br>第 1 行：三个整数 N，P，K。</p>
<p>第 2..P+1 行：第 i+1 行包含三个整数 Ai,Bi,Li。</p>
<p>输出格式<br>包含一个整数表示最少花费。</p>
<p>若 1 号基站与 N 号基站之间不存在路径，则输出 −1。</p>
<p>数据范围<br>0 ≤ K &lt; N ≤ 1000,<br>1 ≤ P ≤ 10000,<br>1 ≤ Li ≤ 1000000<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 7 1</span><br><span class="line">1 2 5</span><br><span class="line">3 1 4</span><br><span class="line">2 4 8</span><br><span class="line">3 2 3</span><br><span class="line">5 2 9</span><br><span class="line">3 4 7</span><br><span class="line">4 5 6</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目告诉</p>
<ul>
<li>道路全为整数且为双向边</li>
<li>航线单向边且边权有正有负但是包含航线的路线是不具有环的（把道路团看成结点后就是是一个拓扑图）</li>
</ul>
<p>对于本题我们不难看出来的本题是一道单源最短路问题且带有边权为负数，<strong>但是sfpa会被卡成nm = 1e9的级别所以不可以用spfa算法</strong></p>
<p>细节处理</p>
<ol>
<li>证明道路可以看成一个团（团内没有航线）<br>反证法：如果团内有航线，由于道路是具有双向边的所以相邻的两点之间一定是相通的，这样就和航线两端是不存在环的，所以一定存在一个团内部的点都有且仅有道路连通</li>
<li>思路上我们把团缩成一个点，大体上做拓扑排序问题内部做dijksra算法问题</li>
<li>如何把全部点分成一个一个团<br>通过dfs/bfs/并查集，我们把通过道路连通的点分成一个团，最后就可以得到不同的团</li>
<li>如何将拓扑序和dijkstra结合起来<br>Step1.读入所有的道路，用dfs算法将所有的道路分成团并对团进行编号<br>Step2.读入所有的航线并记录所有点的入读<br>Step3.做topsort（）<br>Step4.把所有入度为0的团加入到堆当中，然后对团内部做dijkstra算法</li>
<li>dijkstra算法<br>当前的dijkstra算法要平时的不同，对点的邻点做更新。如果id[i] == id[j]说明这两个点在同一个团当中，如果可以更新就进行更新，然后加入到堆当中，如果id[i] != id[j]的话，说明不在同一个团当中通过航相连，并对bock[id[j]]的入度点做减一更新</li>
</ol>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25010</span>, M = <span class="number">50000</span> * <span class="number">3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,p,S;</span><br><span class="line"><span class="type">int</span> h[N],e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> bcnt;</span><br><span class="line"><span class="type">int</span> id[N], bin[N], dist[N]; <span class="comment">// id[x]表示x点在那个团当中 </span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; block[N];   <span class="comment">// 保存是每个团当中的结点编号</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> bid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对id和block数组进行初始化</span></span><br><span class="line">    id[u] = bid, block[bid].<span class="built_in">pb</span>(u);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!id[j])</span><br><span class="line">            <span class="built_in">dfs</span>(j,bid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> bid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 建立heap</span></span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u : block[bid])</span><br><span class="line">        heap.<span class="built_in">push</span>(&#123;dist[u], u&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;   <span class="comment">// 每个点只会被更新一次 </span></span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(id[ver] == id[j])</span><br><span class="line">                    heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(id[j] != id[ver] &amp;&amp; -- bin[id[j]] == <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(id[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[S] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bcnt; i ++)</span><br><span class="line">        <span class="keyword">if</span>(!bin[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">dijkstra</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; S;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过道路建图</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c),<span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立团</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; i ++)</span><br><span class="line">        <span class="keyword">if</span>(!id[i])</span><br><span class="line">            <span class="built_in">dfs</span>(i, ++ bcnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入航线 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; p; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        bin[id[b]] ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i  = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">if</span>(dist[i] &gt; INF / <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;NO PATH&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; dist[i] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AcWing</category>
        <category>图论</category>
        <category>最短路</category>
        <category>多种最短路算法结合</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 383. 观光</title>
    <url>/2022/09/11/AcWing-383-%E8%A7%82%E5%85%89/</url>
    <content><![CDATA[<h2 id="AcWing-383-观光"><a href="#AcWing-383-观光" class="headerlink" title="AcWing 383. 观光"></a><a href="https://www.acwing.com/problem/content/385/">AcWing 383. 观光</a></h2><p>“您的个人假期”旅行社组织了一次比荷卢经济联盟的巴士之旅。</p>
<p>比荷卢经济联盟有很多公交线路。</p>
<p>每天公共汽车都会从一座城市开往另一座城市。</p>
<p>沿途汽车可能会在一些城市（零或更多）停靠。</p>
<p>旅行社计划旅途从 S 城市出发，到 F 城市结束。</p>
<p>由于不同旅客的景点偏好不同，所以为了迎合更多旅客，旅行社将为客户提供多种不同线路。</p>
<p>游客可以选择的行进路线有所限制，要么满足所选路线总路程为 S 到 F 的最小路程，要么满足所选路线总路程仅比最小路程多一个单位长度。</p>
<p><img src="https://www.acwing.com/media/article/image/2019/02/26/19_75361c2839-3463_1.png" alt="来自AcWing"></p>
<p>如上图所示，如果 S=1，F=5，则这里有两条最短路线 1→2→5,1→3→5，长度为 6；有一条比最短路程多一个单位长度的路线 1→3→4→5，长度为 7。</p>
<p>现在给定比荷卢经济联盟的公交路线图以及两个城市 S 和 F，请你求出旅行社最多可以为旅客提供多少种不同的满足限制条件的线路。</p>
<p>输入格式<br>第一行包含整数 T，表示共有 T 组测试数据。</p>
<p>每组数据第一行包含两个整数 N 和 M，分别表示总城市数量和道路数量。</p>
<p>接下来 M 行，每行包含三个整数 A,B,L，表示有一条线路从城市 A 通往城市 B，长度为 L。</p>
<p>需注意，线路是 单向的，存在从 A 到 B 的线路不代表一定存在从 B 到 A 的线路，另外从城市 A 到城市 B 可能存在多个不同的线路。</p>
<p>接下来一行，包含两个整数 S 和 F，数据保证 S 和 F 不同，并且 S、F 之间至少存在一条线路。</p>
<p>输出格式<br>每组数据输出一个结果，每个结果占一行。</p>
<p>数据保证结果不超过 109。</p>
<p>数据范围<br>2≤N≤1000,<br>1≤M≤10000,<br>1≤L≤1000，<br>1≤A,B,S,F≤N<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5 8</span><br><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">1 4 5</span><br><span class="line">2 3 1</span><br><span class="line">2 5 3</span><br><span class="line">3 4 2</span><br><span class="line">3 5 4</span><br><span class="line">4 5 3</span><br><span class="line">1 5</span><br><span class="line">5 6</span><br><span class="line">2 3 1</span><br><span class="line">3 2 1</span><br><span class="line">3 1 10</span><br><span class="line">4 5 2</span><br><span class="line">5 2 7</span><br><span class="line">5 2 7</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2>]]></content>
      <categories>
        <category>AcWing</category>
        <category>图论</category>
        <category>最短路</category>
        <category>与dp结合</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 4223. 点火游戏</title>
    <url>/2022/10/25/AcWing-4223-%E7%82%B9%E7%81%AB%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="AcWing-4223-点火游戏"><a href="#AcWing-4223-点火游戏" class="headerlink" title="AcWing 4223. 点火游戏"></a><a href="https://www.acwing.com/problem/content/4226/">AcWing 4223. 点火游戏</a></h2><p>给定一个 N 行 M 列的方格矩阵。</p>
<p>其中一部分方格是草地，其余部分是空地。</p>
<p>草地能够被燃烧，空地不会。</p>
<p>当某个草地在 t 时刻被点燃时，其上下左右四个方向的相邻方格中的草地方格也会在 t+1 时刻被点燃。</p>
<p>注意，空地方格无论如何都不可能被点燃。</p>
<p>现在，你可以选择最多两个草地，将它们点燃。</p>
<p>请你计算，使得所有草地都被点燃所需花费的最少时间。</p>
<p>输入格式<br>第一行包含整数 T，表示共有 T 组测试数据。</p>
<p>每组数据第一行包含两个整数 N,M。</p>
<p>接下来 N 行，包含一个 N×M 的字符矩阵，# 表示草地，. 表示空地。</p>
<p>输出格式<br>每组数据输出一个结果，每个结果占一行。</p>
<p>结果表示为 Case x: y，其中 x 为组别编号（从 1 开始），y 点燃所有草地需要花费的最短时间。如果无法点燃所有草地或者所有方格都是空地则输出 −1。</p>
<p>数据范围<br>1≤T≤100,<br>1≤N,M≤10。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 3</span><br><span class="line">.#.</span><br><span class="line">###</span><br><span class="line">.#.</span><br><span class="line">3 3</span><br><span class="line">.#.</span><br><span class="line">#.#</span><br><span class="line">.#.</span><br><span class="line">3 3</span><br><span class="line">...</span><br><span class="line">#.#</span><br><span class="line">...</span><br><span class="line">3 3</span><br><span class="line">###</span><br><span class="line">..#</span><br><span class="line">#.#</span><br><span class="line">3 3</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Case 1: 1</span><br><span class="line">Case 2: -1</span><br><span class="line">Case 3: 0</span><br><span class="line">Case 4: 2</span><br><span class="line">Case 5: -1</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>本题是多起点问题的bfs，并且这两个起点是相互影响的。</p>
<p>最常见的错误是构造虚拟源点，实际上因为起点之间是具有依赖关系的，</p>
<p>第二个方法考虑，创建两个队列，进行双路bfs。这里的双路bfs是根据双向bfs来写的。<br>这里又错了，这是为什么了？？因为两个起点可能会遍历到同一个起点，又应为每个点只能被遍历一次所以这个当前两个起点都可以到达的点的这dist值要求两个前驱点的最小值。如果这里借一个map，两个队列都有自个的一个map，这样可以吗？？答案还是不行的，因为这个具有多个前驱点的这个点，有可能在两个队列相遇之前的就已经开始拓展了影响了其他点，所以这里使用两个队列依然不行。</p>
<p>是的以上办法我都试过了都错误了。。。还是太菜了。。。。</p>
<p>最后的办法，使用一个队列，把两个起点都放入到同一个队列当中，构造一个结构体node，记录的是当前的步长，具体看代码，和正常的bfs很像，就是一开始入队的时候进入了两个起始点。</p>
<p>本题还有一个很坑的地方，可能双起点会在同一个位置上。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> dist;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m,cnt, res;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line"><span class="type">bool</span> vis[N][N];</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(queue&lt;node&gt; &amp;q, <span class="type">int</span> &amp;block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; 2 &lt;&lt; endl; </span></span><br><span class="line">    <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> x = t.x, y = t.y, dist = t.dist;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; x  &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">    <span class="type">int</span> output = dist;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cx = x + dx[i], cy = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(cx &gt; <span class="number">0</span> &amp;&amp; cx &lt;= n &amp;&amp; cy &gt; <span class="number">0</span> &amp;&amp; cy &lt;= m &amp;&amp; !vis[cx][cy] &amp;&amp; g[cx][cy] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;cx,cy,dist + <span class="number">1</span>&#125;), block --, output = dist + <span class="number">1</span>, vis[cx][cy] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> block = cnt - <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; 1 &lt;&lt; endl;</span></span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="keyword">if</span>(!block) <span class="keyword">break</span>;</span><br><span class="line">        t = <span class="built_in">extend</span>(q, block);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(block) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 枚举起点</span></span><br><span class="line">    res = INF;</span><br><span class="line">    <span class="comment">// 枚举起点的时候要考虑两个起点可能是同一个起点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u ++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">1</span>; v &lt;= m; v ++)</span><br><span class="line">                    <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; g[u][v] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// bfs前初始化</span></span><br><span class="line">                        <span class="comment">// 清空队列</span></span><br><span class="line">                        <span class="comment">// 初始化状态数组</span></span><br><span class="line">                        queue&lt;node&gt; emp;</span><br><span class="line">                        <span class="built_in">swap</span>(emp,q);</span><br><span class="line">                        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">                        <span class="comment">// cout &lt;&lt; u &lt;&lt; &#x27; &#x27; &lt;&lt; v &lt;&lt; endl;</span></span><br><span class="line">                        <span class="comment">// 这里如果是同一个起点也无所谓，因为拓展了一个节点另外一个节点就不可能被拓展了</span></span><br><span class="line">                        q.<span class="built_in">push</span>(&#123;i,j,<span class="number">0</span>&#125;), q.<span class="built_in">push</span>(&#123;u,v,<span class="number">0</span>&#125;);</span><br><span class="line">                        vis[i][j] = <span class="number">1</span>, vis[u][v] = <span class="number">1</span>;</span><br><span class="line">                        <span class="type">int</span> t = <span class="built_in">bfs</span>();</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">                        <span class="keyword">if</span>(t != <span class="number">-1</span>) res = <span class="built_in">min</span>(res ,t);</span><br><span class="line">                    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>; t &lt;= T; t ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            &#123;    </span><br><span class="line">                cin &gt;&gt; g[i][j];</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;#&#x27;</span>) cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span>) res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt &lt;= <span class="number">2</span>) res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(res == INF) res = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>, t, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kuangbing</category>
        <category>简单搜索</category>
        <category>双路bfs</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>kuangbing</tag>
        <tag>双路bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 4241. 货物运输</title>
    <url>/2022/11/05/AcWing-4241-%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93/</url>
    <content><![CDATA[<h1 id="AcWing-4241-货物运输"><a href="#AcWing-4241-货物运输" class="headerlink" title="AcWing 4241. 货物运输"></a><a href="https://vjudge.net/problem/POJ-1797">AcWing 4241. 货物运输</a></h1><p>背景<br>Hugo Heavy 很高兴。在 Cargolifter 项目崩溃后，他现在可以扩展业务。但是他需要一个聪明的人来告诉他是否真的有一条路可以从他的客户建造他的巨型钢起重机的地方到所有街道都可以承受重量的地方。<br>幸运的是，他已经制定了城市规划，包括所有街道和桥梁以及所有允许的重量。不幸的是，他不知道如何找到最大承重能力，以便告诉客户起重机的重量。但你肯定知道。</p>
<p>问题<br>你会得到城市的平面图，由交叉口之间的街道（有重量限制）描述，从 1 到 n 编号。你的任务是找出从 1 号路口（雨果所在的地方）到 n 号路口（客户所在的地方）可以运输的最大重量。您可以假设至少有一条路径。所有街道都可以双向行驶。</p>
<p>输入<br>第一行包含场景的数量（城市规划）。对于每个城市，街道交叉口的数量 n (1 &lt;= n &lt;= 1000) 和街道数量 m 在第一行给出。以下 m 行包含整数的三倍，指定街道的起点和终点交叉口以及最大允许权重，为正且不大于 1000000。每对交叉口之间最多有一条街道。</p>
<p>输出<br>每个场景的输出都以包含“场景 #i:”的行开头，其中 i 是场景的编号，从 1 开始。然后打印一行，其中包含 Hugo 可以运输给客户的最大允许重量。用空行终止场景的输出。</p>
<p>Sample<br><strong>INPUT</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3 3</span><br><span class="line">1 2 3</span><br><span class="line">1 3 4</span><br><span class="line">2 3 5</span><br></pre></td></tr></table></figure></p>
<p><strong>OUTPUT</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scenario #1:</span><br><span class="line">4</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>方法一 最短路<br>改写dijkstra的dist数组，dist的属性从到最源点的最短距离改成<strong>代表1到i点的所有边中最小值最大的一个</strong></p>
<p>然后再用堆去求解即可</p>
<p>但是这个方法有一个问题是我一直没有解决的，堆优化的dijkstra算法是贪心做法，本题的改变dist属性的过程中不太了解本属性为何满足贪心解。如果读者有能进行贪心证明，请务必教教我！</p>
<p>方法二 Kruscal做法<br>从大到小枚举每一条边，第一次1和n连通的时候就是我们要找的最小值最大解。</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u, v, d;</span><br><span class="line">    <span class="built_in">Edge</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> d):<span class="built_in">u</span>(u),<span class="built_in">v</span>(v),<span class="built_in">d</span>(d)&#123;&#125;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> a.d &gt; b.d;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] != x) f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>; t &lt;= T; t ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">            f[i] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            edge[i] = <span class="built_in">Edge</span>(a,b,c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(edge,edge + m,cmp);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b, w;</span><br><span class="line">            a = edge[i].u, b = edge[i].v, w = edge[i].d;</span><br><span class="line"></span><br><span class="line">            a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(a != b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 把彼此的祖宗节点都给连上</span></span><br><span class="line">                f[a] = b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一次连通的时候就是最小值最大</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(<span class="number">1</span>) == <span class="built_in">find</span>(n))</span><br><span class="line">            &#123;</span><br><span class="line">                res = w;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Scenario #%d:\n&quot;</span>,t);</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Kuangbing</category>
        <category>专题4 最短路练习</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 4714.数对</title>
    <url>/2022/11/13/AcWing-4714-%E6%95%B0%E5%AF%B9/</url>
    <content><![CDATA[<h1 id="AcWing-4714-数对"><a href="#AcWing-4714-数对" class="headerlink" title="AcWing 4714.数对"></a><a href="https://www.acwing.com/problem/content/4717/">AcWing 4714.数对</a></h1><p>给定一个长度为 N 的字符串 S，字符串中的字符下标从左到右依次为 1∼N。</p>
<p>请你计算共有多少个数对 (i,j) 能够同时满足以下条件：</p>
<p>1≤i,j≤N（i 和 j 可以相等）<br>S[i]=S[j]<br>注意，(2,1) 和 (1,2) 视为两个不同的数对。</p>
<p>输入格式<br>共一行，一个字符串 S。</p>
<p>输出格式<br>一个整数，表示满足条件的数对数量。</p>
<p>数据范围<br>前三个测试点满足 1≤N≤10。<br>所有测试点满足 1≤N≤105，字符串中只包含小写字母和数字。</p>
<p>输入样例1：<br>great10<br>输出样例1：<br>7<br>输入样例2：<br>aaaaaaaaaa<br>输出样例2：<br>100</p>
]]></content>
  </entry>
  <entry>
    <title>AcWing 920. 最优乘车</title>
    <url>/2022/08/11/AcWing-920-%E6%9C%80%E4%BC%98%E4%B9%98%E8%BD%A6/</url>
    <content><![CDATA[<h2 id="AcWing-920-最优乘车"><a href="#AcWing-920-最优乘车" class="headerlink" title="AcWing 920. 最优乘车"></a><a href="https://www.acwing.com/problem/content/342/">AcWing 920. 最优乘车</a></h2><p>在郊区有 N 座通信基站，P 条 双向 电缆，第 i 条电缆连接基站 Ai 和 Bi。</p>
<p>特别地，1 号基站是通信公司的总站，N 号基站位于一座农场中。</p>
<p>现在，农场主希望对通信线路进行升级，其中升级第 i 条电缆需要花费 Li。</p>
<p>电话公司正在举行优惠活动。</p>
<p>农产主可以指定一条从 1 号基站到 N 号基站的路径，并指定路径上不超过 K 条电缆，由电话公司免费提供升级服务。</p>
<p>农场主只需要支付在该路径上剩余的电缆中，升级价格最贵的那条电缆的花费即可。</p>
<p>求至少用多少钱可以完成升级。</p>
<p>输入格式<br>第 1 行：三个整数 N，P，K。</p>
<p>第 2..P+1 行：第 i+1 行包含三个整数 Ai,Bi,Li。</p>
<p>输出格式<br>包含一个整数表示最少花费。</p>
<p>若 1 号基站与 N 号基站之间不存在路径，则输出 −1。</p>
<p>数据范围<br>0≤K<N≤1000,
1≤P≤10000,
1≤Li≤1000000
输入样例：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 7 1</span><br><span class="line">1 2 5</span><br><span class="line">3 1 4</span><br><span class="line">2 4 8</span><br><span class="line">3 2 3</span><br><span class="line">5 2 9</span><br><span class="line">3 4 7</span><br><span class="line">4 5 6</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>本题难题在于输入以及建图的层面</p>
<p>输入使用sstream(按行读入，甚至是能读入换行符号的)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string line;</span><br><span class="line"><span class="built_in">getline</span>(cin, line); <span class="comment">// 把第一行的换行符给清空</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);</span><br><span class="line">    <span class="function">stringstream <span class="title">ssin</span><span class="params">(line)</span></span>;</span><br><span class="line">    <span class="type">int</span> p, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 因为要求换乘次数最少所以应该同一条线路上的所有点都是相通的</span></span><br><span class="line">    <span class="keyword">while</span>(ssin &gt;&gt; p) stop[cnt ++ ] = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>建图<br>由于题目要求我们求出来换成次数最少所以在建图上一条线路上的所有站两两之间都是的相连通的</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边权为一，bfs可以求最小换成次数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], stop[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> q[N];</span><br><span class="line">    q[++ tt] = <span class="number">1</span>;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + <span class="number">1</span>;</span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line); <span class="comment">// 把第一行的换行符给清空</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin, line);</span><br><span class="line">        <span class="function">stringstream <span class="title">ssin</span><span class="params">(line)</span></span>;</span><br><span class="line">        <span class="type">int</span> p, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 因为要求换乘次数最少所以应该同一条线路上的所有点都是相通的</span></span><br><span class="line">        <span class="keyword">while</span>(ssin &gt;&gt; p) stop[cnt ++ ] = p;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; cnt; j ++)</span><br><span class="line">                <span class="built_in">add</span>(stop[i],stop[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dist[m] == INF) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">max</span>(dist[m] - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AcWing</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>输入问题</tag>
        <tag>建图</tag>
      </tags>
  </entry>
  <entry>
    <title>Acwing 1098. 城堡问题</title>
    <url>/2022/11/01/Acwing-1098-%E5%9F%8E%E5%A0%A1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="Acwing-1098-城堡问题"><a href="#Acwing-1098-城堡问题" class="headerlink" title="Acwing 1098. 城堡问题"></a><a href="https://www.acwing.com/problem/content/1100/">Acwing 1098. 城堡问题</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1   2   3   4   5   6   7  </span><br><span class="line">   #############################</span><br><span class="line"> 1 #   |   #   |   #   |   |   #</span><br><span class="line">   #####---#####---#---#####---#</span><br><span class="line"> 2 #   #   |   #   #   #   #   #</span><br><span class="line">   #---#####---#####---#####---#</span><br><span class="line"> 3 #   |   |   #   #   #   #   #</span><br><span class="line">   #---#########---#####---#---#</span><br><span class="line"> 4 #   #   |   |   |   |   #   #</span><br><span class="line">   #############################</span><br><span class="line">           (图 1)</span><br><span class="line"></span><br><span class="line">   #  = Wall   </span><br><span class="line">   |  = No wall</span><br><span class="line">   -  = No wall</span><br><span class="line"></span><br><span class="line">   方向：上北下南左西右东。</span><br></pre></td></tr></table></figure>
<p>图1是一个城堡的地形图。</p>
<p>请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。</p>
<p>城堡被分割成 m∗n个方格区域，每个方格区域可以有0~4面墙。</p>
<p>注意：墙体厚度忽略不计。</p>
<p>输入格式<br>第一行包含两个整数 m 和 n，分别表示城堡南北方向的长度和东西方向的长度。</p>
<p>接下来 m 行，每行包含 n 个整数，每个整数都表示平面图对应位置的方块的墙的特征。</p>
<p>每个方块中墙的特征由数字 P 来描述，我们用1表示西墙，2表示北墙，4表示东墙，8表示南墙，P 为该方块包含墙的数字之和。</p>
<p>例如，如果一个方块的 P 为3，则<code>3 = 1 + 2</code>，该方块包含西墙和北墙。</p>
<p>城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙。</p>
<p>输入的数据保证城堡至少有两个房间。</p>
<p>输出格式<br>共两行，第一行输出房间总数，第二行输出最大房间的面积（方块数）。</p>
<p>数据范围<br>1≤m,n≤50,<br>0≤P≤15<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 7 </span><br><span class="line">11 6 11 6 3 10 6 </span><br><span class="line">7 9 6 13 5 15 5 </span><br><span class="line">1 10 12 7 13 7 5 </span><br><span class="line">13 11 10 8 10 12 13 </span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cnt_block, area;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="comment">// int dist[N][N];</span></span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;, dy[] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    PII q[M];</span><br><span class="line">    q[<span class="number">0</span>] = &#123;x,y&#125;;</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">auto</span> t = q[hh ++];</span><br><span class="line">        res ++;</span><br><span class="line">        <span class="type">int</span> sx = t.fi, sy = t.se;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cx = sx + dx[i], cy = sy + dy[i];</span><br><span class="line">            <span class="comment">// 判断这个是否越界这是为了防止遍历数组的时候出现遍历到-1这些位置造成了SF错误</span></span><br><span class="line">            <span class="keyword">if</span>(cx &lt; <span class="number">0</span> || cx &gt;= n || cy &lt; <span class="number">0</span> || cy &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 如果当前没有门的情况下是可以更新状态的</span></span><br><span class="line">            <span class="keyword">if</span>(g[sx][sy] &gt;&gt; i &amp; <span class="number">1</span> || st[cx][cy]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            q[++ tt] = &#123;cx, cy&#125;;</span><br><span class="line">            st[cx][cy] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t = <span class="built_in">bfs</span>(i,j);</span><br><span class="line">                <span class="keyword">if</span>(t != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt_block ++;</span><br><span class="line">                    area = <span class="built_in">max</span>(area, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt_block &lt;&lt; endl &lt;&lt; area &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AcWing</category>
        <category>搜索</category>
        <category>Flood Fill</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>Flood Fill</tag>
        <tag>连通块问题</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 1699B Almost Ternary Matrix</title>
    <url>/2022/07/13/CF-1699B-Almost-Ternary-Matrix/</url>
    <content><![CDATA[<h2 id="CF-1699B"><a href="#CF-1699B" class="headerlink" title="CF-1699B"></a><a href="https://codeforces.com/problemset/problem/1699/B">CF-1699B</a></h2><p>You are given two even integers 𝑛 and 𝑚. Your task is to find any binary matrix 𝑎 with 𝑛 rows and 𝑚 columns where every cell (𝑖,𝑗) has exactly two neighbours with a different value than 𝑎𝑖,𝑗.</p>
<p>Two cells in the matrix are considered neighbours if and only if they share a side. More formally, the neighbours of cell (𝑥,𝑦) are: (𝑥−1,𝑦), (𝑥,𝑦+1), (𝑥+1,𝑦) and (𝑥,𝑦−1).</p>
<p>It can be proven that under the given constraints, an answer always exists.</p>
<p>Input<br>Each test contains multiple test cases. The first line of input contains a single integer 𝑡 (1≤𝑡≤100) — the number of test cases. The following lines contain the descriptions of the test cases.</p>
<p>The only line of each test case contains two even integers 𝑛 and 𝑚 (2≤𝑛,𝑚≤50) — the height and width of the binary matrix, respectively.</p>
<p>Output<br>For each test case, print 𝑛 lines, each of which contains 𝑚 numbers, equal to 0 or 1 — any binary matrix which satisfies the constraints described in the statement.</p>
<p>It can be proven that under the given constraints, an answer always exists.</p>
<p>Example<br>input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 4</span><br><span class="line">2 2</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><br>output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 0 0 1</span><br><span class="line">0 1 1 0</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">1 0 1 0</span><br><span class="line">0 0 1 1</span><br><span class="line">1 1 0 0</span><br><span class="line">0 1 0 1</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p> <img src="[https://](https://codeforces.com/predownloaded/75/c4/75c46e19cc3cf6f890139b0e74774c3a6fc387db.png" alt="">)<br>我们需要构造上图的2x2矩形，我们可以看出宏观上来看都是每个2个连续出现两次黑块/白块，左上角的坐标记作（1，1）我们可以得到一个公式 (i%4 &lt;=1 != j%4&lt;= 1) / (i%4 &lt;=1 == j%4&lt;= 1)时是黑块</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span>x</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; ((i % <span class="number">4</span> &lt;= <span class="number">1</span>) == (j % <span class="number">4</span> &lt;= <span class="number">1</span>)) &lt;&lt; <span class="string">&quot; \n&quot;</span>[j==m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CodeForces</category>
        <category>思维题</category>
      </categories>
      <tags>
        <tag>思维题</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 631C REPORT</title>
    <url>/2022/07/12/CF-631C-Report/</url>
    <content><![CDATA[<h2 id="CF-631C-REPORT"><a href="#CF-631C-REPORT" class="headerlink" title="CF 631C REPORT"></a><a href="https://codeforces.com/contest/631/problem/C">CF 631C REPORT</a></h2><p>Each month Blake gets the report containing main economic indicators of the company “Blake Technologies”. There are n commodities produced by the company. For each of them there is exactly one integer in the final report, that denotes corresponding revenue. Before the report gets to Blake, it passes through the hands of m managers. Each of them may reorder the elements in some order. Namely, the i-th manager either sorts first ri numbers in non-descending or non-ascending order and then passes the report to the manager i + 1, or directly to Blake (if this manager has number i = m).</p>
<p>Employees of the “Blake Technologies” are preparing the report right now. You know the initial sequence ai of length n and the description of each manager, that is value ri and his favourite order. You are asked to speed up the process and determine how the final report will look like.</p>
<p>Input<br>The first line of the input contains two integers n and m (1 ≤ n, m ≤ 200 000) — the number of commodities in the report and the number of managers, respectively.</p>
<p>The second line contains n integers ai (|ai| ≤ 109) — the initial report before it gets to the first manager.</p>
<p>Then follow m lines with the descriptions of the operations managers are going to perform. The i-th of these lines contains two integers ti and ri (, 1 ≤ ri ≤ n), meaning that the i-th manager sorts the first ri numbers either in the non-descending (if ti = 1) or non-ascending (if ti = 2) order.</p>
<p>Output<br>Print n integers — the final report, which will be passed to Blake by manager number m.</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在本题一共只有两种操作op1是非严格递减op2是非严格递增（也就是说里面可能有相同的数字）<br><strong>优化一</strong>  对于不同的操作，只要后一个操作操作的区间比上一个区间要更加的大的话那么上一个区间的操作就无效，因为会被覆盖掉。所以我们对操作区间做一个单调递减的记录（使用单调栈）<br><strong>优化二</strong>  经过第一步的优化我们可以的得到一个单调递减的操作区间。 对于[1,5],[1,3]区间操作op1，op2。在这个尝试探讨op看是否有特殊性质<br>op1 == op2（操作相同）<br>op2没有意义必然被大区间的操作覆盖<br>op1 != op2<br>假设大区间是非严格递减小区间是非严格递增，那么[4,5]这个区间是[1,5]这个区间是整个大区间里最小的两个数<br>假设大区间是非严格递增小区间是非严格递减，那么[4,5]这个区间是整个大区间里的最大的两个数</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> st[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> arr[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2是降序 1是升序</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>;st[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>,st[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// st[1]是栈底 st[1][0]为栈底第一元素，表示的是操作范围,st[1][1]为栈底第二元素表示是操作类型</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, op;<span class="built_in">cin</span> &gt;&gt; op &gt;&gt; a;</span><br><span class="line">        <span class="keyword">while</span>(hh &amp;&amp; st[hh][<span class="number">0</span>] &lt;= a) hh --;</span><br><span class="line">        st[++hh][<span class="number">0</span>] = a, st[hh][<span class="number">1</span>] = op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(arr,arr + st[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = st[<span class="number">1</span>][<span class="number">0</span>], k = hh + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p = r;</span><br><span class="line">    st[k][<span class="number">0</span>] = <span class="number">0</span>,st[k][<span class="number">1</span>] = <span class="number">1</span>;   <span class="comment">// 处理边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op = st[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(p &gt; st[i+<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            p --;</span><br><span class="line">            <span class="comment">// 升序取最大值 降序取最小值（这里使用双指针对其赋值）</span></span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">1</span>) ans[p] = arr[--r];</span><br><span class="line">            <span class="keyword">else</span> ans[p] = arr[l++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = st[<span class="number">1</span>][<span class="number">0</span>]; i &lt; n; i ++) ans[i] = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CodeForces</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 337D Book of Evil</title>
    <url>/2022/07/15/CF337D-Book-of-Evil/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>CodeForces - 1529C Parsa&#39;s Humongous Tree</title>
    <url>/2022/08/05/CodeForces-1529C-Parsa-s-Humongous-Tree/</url>
    <content><![CDATA[<h2 id="CodeForces-1529C-Parsa’s-Humongous-Tree"><a href="#CodeForces-1529C-Parsa’s-Humongous-Tree" class="headerlink" title="CodeForces - 1529C Parsa’s Humongous Tree"></a><a href="https://vjudge.net/problem/CodeForces-1529C">CodeForces - 1529C Parsa’s Humongous Tree</a></h2><p>Parsa has a humongous tree on 𝑛 vertices.</p>
<p>On each vertex 𝑣 he has written two integers 𝑙𝑣 and 𝑟𝑣.</p>
<p>To make Parsa’s tree look even more majestic, Nima wants to assign a number 𝑎𝑣 (𝑙𝑣≤𝑎𝑣≤𝑟𝑣) to each vertex 𝑣 such that the beauty of Parsa’s tree is maximized.</p>
<p>Nima’s sense of the beauty is rather bizarre. He defines the beauty of the tree as the sum of |𝑎𝑢−𝑎𝑣| over all edges (𝑢,𝑣) of the tree.</p>
<p>Since Parsa’s tree is too large, Nima can’t maximize its beauty on his own. Your task is to find the maximum possible beauty for Parsa’s tree.</p>
<p>Input<br>The first line contains an integer 𝑡 (1≤𝑡≤250) — the number of test cases. The description of the test cases follows.</p>
<p>The first line of each test case contains a single integer 𝑛 (2≤𝑛≤105) — the number of vertices in Parsa’s tree.</p>
<p>The 𝑖-th of the following 𝑛 lines contains two integers 𝑙𝑖 and 𝑟𝑖 (1≤𝑙𝑖≤𝑟𝑖≤109).</p>
<p>Each of the next 𝑛−1 lines contains two integers 𝑢 and 𝑣 (1≤𝑢,𝑣≤𝑛,𝑢≠𝑣) meaning that there is an edge between the vertices 𝑢 and 𝑣 in Parsa’s tree.</p>
<p>It is guaranteed that the given graph is a tree.</p>
<p>It is guaranteed that the sum of 𝑛 over all test cases doesn’t exceed 2⋅105.</p>
<p>Output<br>For each test case print the maximum possible beauty for Parsa’s tree.</p>
<p><strong>Example</strong><br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1 6</span><br><span class="line">3 8</span><br><span class="line">1 2</span><br><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">4 6</span><br><span class="line">7 9</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">6</span><br><span class="line">3 14</span><br><span class="line">12 20</span><br><span class="line">12 19</span><br><span class="line">2 12</span><br><span class="line">10 17</span><br><span class="line">3 17</span><br><span class="line">3 2</span><br><span class="line">6 5</span><br><span class="line">1 5</span><br><span class="line">2 6</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">8</span><br><span class="line">62</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目要求每个节点在区间[l,r]中选一个值，每一条边的边权 == 两点的之间的绝对值，求出一颗树中的边权的最大值</p>
<p><strong>贪心</strong><br>贪心决策： 实际上每个树的节点只取选取l/r</p>
<p>贪心证明<br>前提父节点为u，父节点有多个子节点，父节点的数值为au,子节点为数值为av，有p个比au大的子节点单av， 有q个比au小的子节点</p>
<ol>
<li>p &gt; q   ∑ |au - av| 那么au 应该越小求和越大(比如在[3,8]区间中选一个中值，x 假设有两个av ==  9， 一个 av = 2，当x取5的时候∑ = 3 + 4 + 4，但是当x取3的时候 ∑ = 1 + 6 + 6,因为比贡献等等于p的个数累加的)</li>
<li>p &lt; q </li>
<li>p = q</li>
</ol>
<p>所以我们就可以定义dp数组<br>dp[i][0]表示选的l,dp[i][1]选r</p>
<p>因为l、r&lt; 1e9 ，所以总和是可能爆int，记得用long long</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">2</span> * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">2</span>];   <span class="comment">// dp[i][0]表示选的l,dp[i][1]选r</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;    <span class="comment">// tree(无向边)</span></span><br><span class="line">PII node[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(j,u);</span><br><span class="line">        dp[u][<span class="number">0</span>] += <span class="built_in">max</span>(dp[j][<span class="number">0</span>] + <span class="built_in">abs</span>(node[u].fi - node[j].fi), dp[j][<span class="number">1</span>] + <span class="built_in">abs</span>(node[u].fi - node[j].se));</span><br><span class="line">        dp[u][<span class="number">1</span>] += <span class="built_in">max</span>(dp[j][<span class="number">0</span>] + <span class="built_in">abs</span>(node[u].se - node[j].fi), dp[j][<span class="number">1</span>] + <span class="built_in">abs</span>(node[u].se - node[j].se));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init()</span></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l, r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            node[i] = &#123;l,r&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;  n - <span class="number">1</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="built_in">add</span>(a,b);</span><br><span class="line">            <span class="built_in">add</span>(b,a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CodeForces</category>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树形dp</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces-295B Greg and Graph</title>
    <url>/2022/07/21/CodeForces-295B-Greg-and-Graph/</url>
    <content><![CDATA[<h2 id="CodeForces-295B-Greg-and-Graph"><a href="#CodeForces-295B-Greg-and-Graph" class="headerlink" title="CodeForces-295B Greg and Graph"></a><a href="https://vjudge.net/problem/CodeForces-295B">CodeForces-295B Greg and Graph</a></h2><p>Greg has a weighed directed graph, consisting of n vertices. In this graph any pair of distinct vertices has an edge between them in both directions. Greg loves playing with the graph and now he has invented a new game:</p>
<p>The game consists of n steps.<br>On the i-th step Greg removes vertex number xi from the graph. As Greg removes a vertex, he also removes all the edges that go in and out of this vertex.<br>Before executing each step, Greg wants to know the sum of lengths of the shortest paths between all pairs of the remaining vertices. The shortest path can go through any remaining vertex. In other words, if we assume that d(i, v, u) is the shortest path between vertices v and u in the graph that formed before deleting vertex xi, then Greg wants to know the value of the following sum: .<br>Help Greg, print the value of the required sum before each step.</p>
<p>Input<br>The first line contains integer n (1 ≤ n ≤ 500) — the number of vertices in the graph.</p>
<p>Next n lines contain n integers each — the graph adjacency matrix: the j-th number in the i-th line aij (1 ≤ aij ≤ 105, aii = 0) represents the weight of the edge that goes from vertex i to vertex j.</p>
<p>The next line contains n distinct integers: x1, x2, …, xn (1 ≤ xi ≤ n) — the vertices that Greg deletes.</p>
<p>Output<br>Print n integers — the i-th number equals the required sum before the i-th step.</p>
<p>Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams of the %I64d specifier.</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>本题需要深入理解floyd原理</strong><br>也就是说给我们每次要删去的点，每次都求一下两点之间的最短路。<br>要是我们每删一个点再去做一遍多源最短路的话，那么时间复杂度会变为O（n^4).<br>这里floyd算法要注意两点：</p>
<ol>
<li>floyd本质上就是一个dp问题，状态转移方程为∑d[i][j]= min(d[i][j],d[i][k] + d[k][j]);<br>这里的状态方程可以表示为从i-&gt;j的最短距离，i到j这个路径上可以被分成了两段，i-&gt;k, k-&gt;j，那我们就可以得到我们的最优子结构了(这里的内层循环k）。</li>
<li>实际上floyd也可以理解为选择一个顶点集作为顶点的中转站 S，假如第一次选了1号ver作为中转，那么我们的所有顶点都可以用1号顶点做为中转站更新距离。（这里是外层循环k）</li>
</ol>
<p>那么本题问题我们就可以转化为加点问题（每次选一个点作为中转，等用于我们加点加入了S集合当中），逆向floyd</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; <span class="built_in">assert</span>(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line">ll g[N][N];</span><br><span class="line"><span class="type">int</span> ver[N];</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) g[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;g[i][j]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ver[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = n; k &gt;= <span class="number">1</span>; k --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = ver[k];</span><br><span class="line">            <span class="comment">// 因为我们要逆序进行floyd，所以我们在计算两点之间的最短距离之前要知道这两个点是否在这个图当中</span></span><br><span class="line">            st[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">                    g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][u] + g[u][j]);</span><br><span class="line"></span><br><span class="line">            ll res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">                    <span class="keyword">if</span>(st[i] &amp;&amp; st[j])</span><br><span class="line">                        res += g[i][j];</span><br><span class="line">            <span class="comment">// 题目要求在我们删点之前计算最长路径，那么逆序就变为加点之后计算最长路径 </span></span><br><span class="line">            ans[k] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld%c&quot;</span>,ans[i],i==n?<span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 629D Babaei and Birthday Cake</title>
    <url>/2022/07/30/CodeForces-629D-Babaei-and-Birthday-Cake/</url>
    <content><![CDATA[<h2 id="CodeForces-629D-Babaei-and-Birthday-Cake-线段树优化dp"><a href="#CodeForces-629D-Babaei-and-Birthday-Cake-线段树优化dp" class="headerlink" title="CodeForces - 629D Babaei and Birthday Cake 线段树优化dp"></a><a href="https://vjudge.net/problem/CodeForces-629D">CodeForces - 629D Babaei and Birthday Cake 线段树优化dp</a></h2><p>As you know, every birthday party has a cake! This time, Babaei is going to prepare the very special birthday party’s cake.<br>Simple cake is a cylinder of some radius and height. The volume of the simple cake is equal to the volume of corresponding cylinder. Babaei has n simple cakes and he is going to make a special cake placing some cylinders on each other.<br>However, there are some additional culinary restrictions. The cakes are numbered in such a way that the cake number i can be placed only on the table or on some cake number j where j &lt; i. Moreover, in order to impress friends Babaei will put the cake i on top of the cake j only if the volume of the cake i is strictly greater than the volume of the cake j.<br>Babaei wants to prepare a birthday cake that has a maximum possible total volume. Help him find this value.</p>
<p>Input<br>The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of simple cakes Babaei has.<br>Each of the following n lines contains two integers ri and hi (1 ≤ ri, hi ≤ 10 000), giving the radius and height of the i-th cake.</p>
<p>Output<br>Print the maximum volume of the cake that Babaei can make. Your answer will be considered correct if its absolute or relative error does not exceed $10^-6$.</p>
<p>Sample 1<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">100 30</span><br><span class="line">40 10</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">942477.796077000</span><br></pre></td></tr></table></figure><br>Sample 2<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">9 7</span><br><span class="line">1 4</span><br><span class="line">10 7</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3983.539484752</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目要求在全部合法方案的中选择cake的体积最大<br>合法方案：当我们选择编号为j时候</p>
<ol>
<li>编号j一定要大于i的编号</li>
<li>j的体积一定要严格小于i</li>
</ol>
<p>普通的dp<br>dp[i]： 表示以i结尾的最大体积<br>所以这里就不能以从i-1转移过来一定是要遍历完全部的1～i-1才可以找到最优解<br>所以普通的dp是$O(n^2)$<br>n是1e5所以我们需要对dp做优化</p>
<p>线段树的优化dp<br>依然是dp[i]，但是我们在作1～i-1区间查询如果使用线段树那么就可以转化成$O(nlogn)$</p>
]]></content>
      <categories>
        <category>CodeForces</category>
        <category>动态规划</category>
        <category>线段树优化</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>线段树优化dp问题</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 777E Hanoi Factory</title>
    <url>/2022/07/31/CodeForces-777E-Hanoi-Factory/</url>
    <content><![CDATA[<h2 id="CodeForces-777E-Hanoi-Factory"><a href="#CodeForces-777E-Hanoi-Factory" class="headerlink" title="CodeForces - 777E Hanoi Factory"></a><a href="https://vjudge.net/problem/CodeForces-777E#author=0">CodeForces - 777E Hanoi Factory</a></h2><p>Of course you have heard the famous task about Hanoi Towers, but did you know that there is a special factory producing the rings for this wonderful game? Once upon a time, the ruler of the ancient Egypt ordered the workers of Hanoi Factory to create as high tower as possible. They were not ready to serve such a strange order so they had to create this new tower using already produced rings.</p>
<p>There are n rings in factory’s stock. The i-th ring has inner radius ai, outer radius bi and height hi. The goal is to select some subset of rings and arrange them such that the following conditions are satisfied:</p>
<p>Outer radiuses form a non-increasing sequence, i.e. one can put the j-th ring on the i-th ring only if bj ≤ bi.<br>Rings should not fall one into the the other. That means one can place ring j on the ring i only if bj &gt; ai.<br>The total height of all rings used should be maximum possible.<br>Input<br>The first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of rings in factory’s stock.</p>
<p>The i-th of the next n lines contains three integers ai, bi and hi (1 ≤ ai, bi, hi ≤ 109, bi &gt; ai) — inner radius, outer radius and the height of the i-th ring respectively.</p>
<p>Output<br>Print one integer — the maximum height of the tower that can be obtained.</p>
<p>Sample 1<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 5 1</span><br><span class="line">2 6 2</span><br><span class="line">3 7 3</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><br>Sample 2<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 1</span><br><span class="line">1 3 3</span><br><span class="line">4 6 2</span><br><span class="line">5 7 1</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><br>Note<br>In the first sample, the optimal solution is to take all the rings and put them on each other in order 3, 2, 1.</p>
<p>In the second sample, one can put the ring 3 on the ring 4 and get the tower of height 3, or put the ring 1 on the ring 2 and get the tower of height 4.</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>dp[i] ：以i结尾的所有合法方案的最大值<br>ans = max ∑ dp[i]</p>
<p>合法方案<br>$ai &lt; bj &lt;= bi$ </p>
<p>正常的dp<br>Step1 ：对bi进行从大到小进行排序<br>Step2 : 从前bi个区间中找出所有方案的中的最大价值<br>Step3 ：更新dp[bi]<br>时间复杂度：$O(n^2)$</p>
<p>树状数组优化：<br>主要对step2进行优化的对$O(n)$优化成$O(logn)$</p>
<p>合法方案是包括两个决策变量的</p>
<ol>
<li>ai &lt; bj</li>
<li>bj &lt;= bi<br>通过对bi从大到小排序再去枚举的话我们就可以减少一个决策，然后离散a数组，这样就可以构造出来一个单调的a数组，用线段树进行维护我们就可以的用$O(nlogn)$来解决问题</li>
</ol>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,h;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp; t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b == t.b) <span class="keyword">return</span> a &gt; t.a;</span><br><span class="line">        <span class="keyword">return</span> b &gt; t.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;ring[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll maxn;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll dp[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; va;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(va.<span class="built_in">begin</span>(), va.<span class="built_in">end</span>(), x) - va.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].maxn = <span class="built_in">max</span>(tr[u &lt;&lt; <span class="number">1</span>].maxn, tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].maxn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l,r,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l,r,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, ll d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == x &amp;&amp; tr[u].r == x)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].maxn = <span class="built_in">max</span>(tr[u].maxn, d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, d);</span><br><span class="line">        <span class="keyword">if</span>(x &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, d);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tr[u].maxn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) res = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,h;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; h;</span><br><span class="line">        ring[i] = &#123;a,b,h&#125;;</span><br><span class="line">        va.<span class="built_in">pb</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态规划的策略选择是ai &lt; bj &lt;= bi</span></span><br><span class="line">    <span class="comment">// 所以如果先对bi进行排序这样找到选择方案的时候我们不需要判断bj &lt;= bi，因为枚举时候的bj总是的比bi晚枚举</span></span><br><span class="line">    <span class="built_in">sort</span>(ring + <span class="number">1</span>, ring + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(va));</span><br><span class="line">    va.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(va)),va.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 因为已经按照b从大向小排序，所以需要二分找到的是ai &lt; bj</span></span><br><span class="line">        dp[i] = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="built_in">find</span>(ring[i].b) - <span class="number">1</span>) + ring[i].h;</span><br><span class="line">        <span class="comment">// 因为我们是离散构造出来va数组，并利用va数组的单调性二分查找ai &lt; bj所以要在ring[i].a上修改值</span></span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="built_in">find</span>(ring[i].a), dp[i]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CodeForces</category>
        <category>动态规划</category>
        <category>线段树优化</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 91B Queue</title>
    <url>/2022/07/31/CodeForces-91B-Queue/</url>
    <content><![CDATA[<h2 id="CodeForces-91B-Queue"><a href="#CodeForces-91B-Queue" class="headerlink" title="CodeForces - 91B Queue"></a><a href="https://vjudge.net/problem/CodeForces-91B">CodeForces - 91B Queue</a></h2><p>There are n walruses standing in a queue in an airport. They are numbered starting from the queue’s tail: the 1-st walrus stands at the end of the queue and the n-th walrus stands at the beginning of the queue. The i-th walrus has the age equal to ai.</p>
<p>The i-th walrus becomes displeased if there’s a younger walrus standing in front of him, that is, if exists such j (i &lt; j), that ai &gt; aj. The displeasure of the i-th walrus is equal to the number of walruses between him and the furthest walrus ahead of him, which is younger than the i-th one. That is, the further that young walrus stands from him, the stronger the displeasure is.</p>
<p>The airport manager asked you to count for each of n walruses in the queue his displeasure.</p>
<p>Input<br>The first line contains an integer n (2 ≤ n ≤ 105) — the number of walruses in the queue. The second line contains integers ai (1 ≤ ai ≤ 109).</p>
<p>Note that some walruses can have the same age but for the displeasure to emerge the walrus that is closer to the head of the queue needs to be strictly younger than the other one.</p>
<p>Output<br>Print n numbers: if the i-th walrus is pleased with everything, print “-1” (without the quotes). Otherwise, print the i-th walrus’s displeasure: the number of other walruses that stand between him and the furthest from him younger walrus.</p>
<p>Sample 1<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">10 8 5 3 50 45</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1 0 -1 0 -1 </span><br></pre></td></tr></table></figure><br>Sample 2<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">10 4 6 3 2 8 15</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 1 0 -1 -1 -1 </span><br></pre></td></tr></table></figure><br>Sample 3<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5	</span><br><span class="line">10 3 1 10 11</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 0 -1 -1 -1</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>本题要我们求每个数的右边最远的比自己小的数字<br>很明显本题可以通过二分找出右边第一个比当前数字要小的位置。但是二分必须要满足二段性，所以我们需要先预处理一遍数组，使得数字满足二义性。<br>本题预处理的数从数组末尾开始处理的当前位置右边最小的数值是什么。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一定要看清楚题意！！！</span></span><br><span class="line">    <span class="comment">// 我们应该要往右找到最后一个比当前的值要小的数值，并且答案 = r - l</span></span><br><span class="line">    <span class="comment">// 要想使用二分搜索就一定要求有二段性</span></span><br><span class="line">    <span class="built_in">memset</span>(s,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> s);</span><br><span class="line">    <span class="comment">// s[i]表示从n~i之间的最小值，从1～n顺序去看是非严格下降的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">        s[i] = <span class="built_in">min</span>(s[i+<span class="number">1</span>], a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = i, r = n;</span><br><span class="line">        <span class="comment">// 整数二分</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span>&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 要找从右边开始的第一个比a[i]小的数</span></span><br><span class="line">            <span class="keyword">if</span>(s[mid] &lt; a[i]) l = mid;  </span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, l - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CodeForces</category>
        <category>二分</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1026 Ignatius and the Princess I</title>
    <url>/2022/07/21/HDU-1026-Ignatius-and-the-Princess-I/</url>
    <content><![CDATA[<h2 id="HDU-1026-Ignatius-and-the-Princess-I"><a href="#HDU-1026-Ignatius-and-the-Princess-I" class="headerlink" title="HDU-1026 Ignatius and the Princess I"></a><a href="https://vjudge.net/problem/HDU-1026">HDU-1026 Ignatius and the Princess I</a></h2><p>The Princess has been abducted by the BEelzebub feng5166, our hero Ignatius has to rescue our pretty Princess. Now he gets into feng5166’s castle. The castle is a large labyrinth. To make the problem simply, we assume the labyrinth is a N*M two-dimensional array which left-top corner is (0,0) and right-bottom corner is (N-1,M-1). Ignatius enters at (0,0), and the door to feng5166’s room is at (N-1,M-1), that is our target. There are some monsters in the castle, if Ignatius meet them, he has to kill them. Here is some rules:</p>
<p>1.Ignatius can only move in four directions(up, down, left, right), one step per second. A step is defined as follow: if current position is (x,y), after a step, Ignatius can only stand on (x-1,y), (x+1,y), (x,y-1) or (x,y+1).<br>2.The array is marked with some characters and numbers. We define them like this:<br>. : The place where Ignatius can walk on.<br>X : The place is a trap, Ignatius should not walk on it.<br>n : Here is a monster with n HP(1&lt;=n&lt;=9), if Ignatius walk on it, it takes him n seconds to kill the monster.</p>
<p>Your task is to give out the path which costs minimum seconds for Ignatius to reach target position. You may assume that the start position and the target position will never be a trap, and there will never be a monster at the start position.<br><code>Input</code><br>The input contains several test cases. Each test case starts with a line contains two numbers N and M(2&lt;=N&lt;=100,2&lt;=M&lt;=100) which indicate the size of the labyrinth. Then a N*M two-dimensional array follows, which describe the whole labyrinth. The input is terminated by the end of file. More details in the Sample Input.<br><code>Output</code><br>For each test case, you should output “God please help our poor hero.” if Ignatius can’t reach the target position, or you should output “It takes n seconds to reach the target position, let me show you the way.”(n is the minimum seconds), and tell our hero the whole path. Output a line contains “FINISH” after each test case. If there are more than one path, any one is OK in this problem. More details in the Sample Output.</p>
<p>Sample<br><code>Input</code><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 6</span><br><span class="line">.XX.1.</span><br><span class="line">..X.2.</span><br><span class="line">2...X.</span><br><span class="line">...XX.</span><br><span class="line">XXXXX.</span><br><span class="line">5 6</span><br><span class="line">.XX.1.</span><br><span class="line">..X.2.</span><br><span class="line">2...X.</span><br><span class="line">...XX.</span><br><span class="line">XXXXX1</span><br><span class="line">5 6</span><br><span class="line">.XX...</span><br><span class="line">..XX1.</span><br><span class="line">2...X.</span><br><span class="line">...XX.</span><br><span class="line">XXXXX.</span><br></pre></td></tr></table></figure><br><code>Output</code><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">It takes 13 seconds to reach the target position, let me show you the way.</span><br><span class="line">1s:(0,0)-&gt;(1,0)</span><br><span class="line">2s:(1,0)-&gt;(1,1)</span><br><span class="line">3s:(1,1)-&gt;(2,1)</span><br><span class="line">4s:(2,1)-&gt;(2,2)</span><br><span class="line">5s:(2,2)-&gt;(2,3)</span><br><span class="line">6s:(2,3)-&gt;(1,3)</span><br><span class="line">7s:(1,3)-&gt;(1,4)</span><br><span class="line">8s:FIGHT AT (1,4)</span><br><span class="line">9s:FIGHT AT (1,4)</span><br><span class="line">10s:(1,4)-&gt;(1,5)</span><br><span class="line">11s:(1,5)-&gt;(2,5)</span><br><span class="line">12s:(2,5)-&gt;(3,5)</span><br><span class="line">13s:(3,5)-&gt;(4,5)</span><br><span class="line">FINISH</span><br><span class="line">It takes 14 seconds to reach the target position, let me show you the way.</span><br><span class="line">1s:(0,0)-&gt;(1,0)</span><br><span class="line">2s:(1,0)-&gt;(1,1)</span><br><span class="line">3s:(1,1)-&gt;(2,1)</span><br><span class="line">4s:(2,1)-&gt;(2,2)</span><br><span class="line">5s:(2,2)-&gt;(2,3)</span><br><span class="line">6s:(2,3)-&gt;(1,3)</span><br><span class="line">7s:(1,3)-&gt;(1,4)</span><br><span class="line">8s:FIGHT AT (1,4)</span><br><span class="line">9s:FIGHT AT (1,4)</span><br><span class="line">10s:(1,4)-&gt;(1,5)</span><br><span class="line">11s:(1,5)-&gt;(2,5)</span><br><span class="line">12s:(2,5)-&gt;(3,5)</span><br><span class="line">13s:(3,5)-&gt;(4,5)</span><br><span class="line">14s:FIGHT AT (4,5)</span><br><span class="line">FINISH</span><br><span class="line">God please help our poor hero.</span><br><span class="line">FINISH</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>迷宫问题，求解<code>最短路</code>并且要<code>记录路径</code>，可以使用<code>优先队列BFS</code>（等价于dijkstra）<br>要清楚无论是bfs还是dijkstra每一个点只会被更新一次说一到一个点的前面那个点一定是唯一的，换言之到某个点的路径也一定是唯一的。所以要想记录路径则使用path[][]数组记录当前点前面一个点，然后从后往前推导路径。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; <span class="built_in">assert</span>(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="type">int</span> cost[N][N];</span><br><span class="line">PII path[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">    <span class="built_in">node</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> time):<span class="built_in">x</span>(x), <span class="built_in">y</span>(y),<span class="built_in">time</span>(time)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node&amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> time &gt; t.time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                d[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">                d[i][j] = INF;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                d[i][j] = g[i][j] - <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; n; i ++)</span></span><br><span class="line">    <span class="comment">//     for(int j = 0; j &lt; m; j ++)</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; d[i][j] &lt;&lt; &quot; \n&quot;[j == m-1];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">            path[i][j] = &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(cost, <span class="number">-1</span>, <span class="keyword">sizeof</span> cost);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    cost[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t.x == n<span class="number">-1</span> &amp;&amp; t.y == m<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nx = t.x + dx[i], ny = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m || d[nx][ny] == INF || cost[nx][ny] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            cost[nx][ny] = cost[t.x][t.y] + d[nx][ny];</span><br><span class="line">            path[nx][ny] = &#123;t.x,t.y&#125;;</span><br><span class="line">            <span class="comment">// 入队是时间的花销，而不是d[nx][ny],如果入队的是当前节点的值，那么很显然不符合全局最优</span></span><br><span class="line">            <span class="comment">// 如果入队的是当前到这个节点的总时间花销，这样就可以一定是全局最优了</span></span><br><span class="line">            q.<span class="built_in">push</span>(&#123;nx,ny,cost[nx][ny]&#125;);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,g[i]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>();    <span class="comment">//先把图边权建立上</span></span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cost[n<span class="number">-1</span>][m<span class="number">-1</span>] != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;It takes &quot;</span> &lt;&lt; cost[n<span class="number">-1</span>][m<span class="number">-1</span>]&lt;&lt; <span class="string">&quot; seconds to reach the target position, let me show you the way.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            vector&lt;PII&gt; ans;</span><br><span class="line">            <span class="type">int</span> tx = n - <span class="number">1</span>, ty = m - <span class="number">1</span>;</span><br><span class="line">            ans.<span class="built_in">pb</span>(&#123;tx,ty&#125;);</span><br><span class="line">            <span class="keyword">while</span>(tx != <span class="number">-1</span> &amp;&amp; ty != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a = path[tx][ty].x, b = path[tx][ty].y;</span><br><span class="line">                tx = a, ty = b;</span><br><span class="line">                ans.<span class="built_in">pb</span>(&#123;tx,ty&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = ans.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt; <span class="number">0</span>; )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tx = ans[i].x, ty = ans[i].y;</span><br><span class="line">                <span class="keyword">if</span>(d[tx][ty] &gt; <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;s:FIGHT AT (&quot;</span> &lt;&lt; tx &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; ty &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; endl;</span><br><span class="line">                    d[tx][ty] --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;s:(&quot;</span> &lt;&lt; ans[i].x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; ans[i].y &lt;&lt; <span class="string">&quot;)-&gt;(&quot;</span> &lt;&lt;</span><br><span class="line">                    ans[i<span class="number">-1</span>].x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; ans[i<span class="number">-1</span>].y &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; endl;</span><br><span class="line">                    i --;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 特判终点</span></span><br><span class="line">            <span class="keyword">while</span>(d[n<span class="number">-1</span>][m<span class="number">-1</span>] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;s:FIGHT AT (&quot;</span> &lt;&lt; n<span class="number">-1</span> &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; m<span class="number">-1</span> &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; endl;</span><br><span class="line">                d[n<span class="number">-1</span>][m<span class="number">-1</span>] --;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;FINISH&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;God please help our poor hero.&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;FINISH&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>输出最优解问题</tag>
        <tag>优先队列bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>django Learning</title>
    <url>/2022/10/29/Django-Learning/</url>
    <content><![CDATA[<h1 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h1><h2 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h2><ol>
<li>创建一个项目<code>django-admin startproject acapp</code>，会创建一个文件夹acapp，树形结构如图</li>
<li>-acapp<pre><code> -__init__.py
 -asgi.py
 -settings.py
 -urls.py
 -wsgi.py
</code></pre> -anage.py</li>
<li>打开<code>settings.py</code>，找到<code>ALLOWED_HOSTS=[]</code>，修改成ALLOWED<em>HOSTS=[“自己的服务器的公网IP”]<br>开启项目，运行网站<code>python3 manage.py runserver 0.0.0.0:8000</code>，登上自己的网站自己的服务器公网IP:8000，看到Django的页面的小火箭即成功运行，下文的网站即自己服务器的公网IP:8000<br>上传到自己的Git上的时候，如果不想上传某些文件比如<code>__pycache__</code>，可以在自己的Git路径上创建一个.<code>gitignore</code>，按照格式填入不想上传的东西的名字即可，比如`<em>_pycache</em></em>/`*</li>
</ol>
<h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><ol>
<li>在一级acapp文件夹下，<code>python3 manage.py startapp xxx</code>，<code>xxx</code>是可以自定义的app名，这里用game示例，这时候会多一个文件夹game，树形结构如图</li>
<li>game<pre><code> -__init__.py
 -admin.py，存储管理员页面
 -apps.py，
 -migrations，存数据库的
 -__init__.py
 -models.py，用于定义网站的数据类
 -test.py
 -views.py，写函数的
</code></pre>进入网站/admin进入自己的管理员页面，不过在此之前要将所有修改更新进数据库<code>python3 manage.py migrate</code> ，再开启运行网站，之后如果需要更新，Django在即将开启运行网站的时候会提醒，所以不用刻意去记<br>创建管理员账号，在后台<code>python3 manage.py createsuperuser</code>，创建超级用户，之后根据提醒一步一步走即可，在管理页面登录即可</li>
</ol>
]]></content>
      <tags>
        <tag>django</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 2457 DNA repair</title>
    <url>/2022/08/08/HDU-2457-DNA-repair/</url>
    <content><![CDATA[<h2 id="HDU-2457-DNA-repair"><a href="#HDU-2457-DNA-repair" class="headerlink" title="HDU - 2457 DNA repair"></a><a href="https://vjudge.net/problem/HDU-2457#author=0">HDU - 2457 DNA repair</a></h2><p>生物学家终于发明了修复DNA的技术，能够将包含各种遗传疾病的DNA片段进行修复。</p>
<p>为了简单起见，DNA看作是一个由’A’, ‘G’ , ‘C’ , ‘T’构成的字符串。</p>
<p>修复技术就是通过改变字符串中的一些字符，从而消除字符串中包含的致病片段。</p>
<p>例如，我们可以通过改变两个字符，将DNA片段”AAGCAG”变为”AGGCAC”，从而使得DNA片段中不再包含致病片段”AAG”，”AGC”，”CAG”，以达到修复该DNA片段的目的。</p>
<p>需注意，被修复的DNA片段中，仍然只能包含字符’A’, ‘G’ , ‘C’ , ‘T’。</p>
<p>请你帮助生物学家修复给定的DNA片段，并且修复过程中改变的字符数量要尽可能的少。</p>
<p>输入格式<br>输入包含多组测试数据。</p>
<p>每组数据第一行包含整数N，表示致病DNA片段的数量。</p>
<p>接下来N行，每行包含一个长度不超过20的非空字符串，字符串中仅包含字符’A’, ‘G’ , ‘C’ , ‘T’，用以表示致病DNA片段。</p>
<p>再一行，包含一个长度不超过1000的非空字符串，字符串中仅包含字符’A’, ‘G’ , ‘C’ , ‘T’，用以表示待修复DNA片段。</p>
<p>最后一组测试数据后面跟一行，包含一个0，表示输入结束。</p>
<p>输出格式<br>每组数据输出一个结果，每个结果占一行。</p>
<p>输入形如”Case x: y”，其中x为测试数据编号（从1开始），y为修复过程中所需改变的字符数量的最小值，如果无法修复给定DNA片段，则y为”-1”。</p>
<p>数据范围<br>1≤N≤50<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">AAA</span><br><span class="line">AAG</span><br><span class="line">AAAG    </span><br><span class="line">2</span><br><span class="line">A</span><br><span class="line">TG</span><br><span class="line">TGAATG</span><br><span class="line">4</span><br><span class="line">A</span><br><span class="line">G</span><br><span class="line">C</span><br><span class="line">T</span><br><span class="line">AGT</span><br><span class="line">0</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Case 1: 1</span><br><span class="line">Case 2: 4</span><br><span class="line">Case 3: -1</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>根据题目我们知道本题要求我们一条DNA链上对非致癌链进行修改的最小值</p>
<p>对于最优解问题或者求方案数问题的都可以使用动态规划来解决，本题又涉及到多字符串的匹配，所以还需要的ac自动机来维护。</p>
<p>动态规划集合划分<br>集合：dp[i][j]表示的以字符串i结尾的对应的自动机状态事j<br>属性：操作数最小<br>状态转移： f[i+1,trans[j,c]] = min(f[i][j], f[i,trans[j][c]])</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> tr[N][<span class="number">4</span>], idx;</span><br><span class="line"><span class="type">int</span> fail[N], dar[N], q[N];</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="string">&#x27;A&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="string">&#x27;G&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="string">&#x27;C&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">get</span>(str[i]);</span><br><span class="line">        <span class="keyword">if</span>(!tr[p][t])</span><br><span class="line">            tr[p][t] = ++ idx;</span><br><span class="line">        p = tr[p][t];</span><br><span class="line">    &#125;</span><br><span class="line">    dar[p] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>][i])</span><br><span class="line">            q[++ tt] = tr[<span class="number">0</span>][i];    <span class="comment">// 把所有的非空状态先入队</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];   <span class="comment">// 当前层的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> p = tr[t][i];</span><br><span class="line">            <span class="keyword">if</span>(p)</span><br><span class="line">            &#123;</span><br><span class="line">                fail[p] = tr[fail[t]][i];</span><br><span class="line">                q[++ tt] = p;</span><br><span class="line">                <span class="comment">// 如果他的某一个前缀子串的最大相同前后缀（fail[p])出现了另一个模式串匹配成功的状态</span></span><br><span class="line">                <span class="comment">// 说明当前这个状态就是匹配成功的状态</span></span><br><span class="line">                dar[p] |= dar[fail[p]]; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> tr[t][i] = tr[fail[t]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init </span></span><br><span class="line">        <span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="keyword">sizeof</span> tr);</span><br><span class="line">        <span class="built_in">memset</span>(dar, <span class="number">0</span>, <span class="keyword">sizeof</span> dar);</span><br><span class="line">        <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span> fail);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build the trie tree</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">            <span class="built_in">insert</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build the ac automaton</span></span><br><span class="line">        <span class="built_in">build</span>(); </span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= idx; j ++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k ++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 表示当前节点的花费，因为不一定在以（i+1)结尾的字符能和模式串匹配</span></span><br><span class="line">                    <span class="comment">//如果是前缀匹配那么转移就不需要操作（因为前面一定已经加上了贡献）</span></span><br><span class="line">                    <span class="type">int</span> t = <span class="built_in">get</span>(str[i + <span class="number">1</span>]) != k;   </span><br><span class="line">                    <span class="type">int</span> p = tr[j][k];   <span class="comment">// tr[j][k]表示当前状态通过k转移过来</span></span><br><span class="line">                    <span class="comment">// 朴素的版本就是一遍遍检查是否有当前字符串的子串能与模式串匹配的，能匹配就更新，不能匹配就不更新</span></span><br><span class="line">                    <span class="keyword">if</span>(!dar[p]) </span><br><span class="line">                        dp[i + <span class="number">1</span>][p] = <span class="built_in">min</span>(dp[i+<span class="number">1</span>][p], dp[i][j] + t);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="type">int</span> res = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx; i ++)</span><br><span class="line">            res = <span class="built_in">min</span>(res, dp[m][i]);</span><br><span class="line">        <span class="keyword">if</span>(res == INF) res = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>, T ++, res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HDU</category>
        <category>动态规划</category>
        <category>状态机模型</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态机模型</tag>
        <tag>ac自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-4857 逃生</title>
    <url>/2022/07/20/HDU-4857-%E9%80%83%E7%94%9F/</url>
    <content><![CDATA[<h2 id="HDU-4857-逃生"><a href="#HDU-4857-逃生" class="headerlink" title="HDU-4857 逃生"></a><a href="https://vjudge.net/problem/HDU-4857">HDU-4857 逃生</a></h2><p>糟糕的事情发生啦，现在大家都忙着逃命。但是逃命的通道很窄，大家只能排成一行。</p>
<p>现在有n个人，从1标号到n。同时有一些奇怪的约束条件，每个都形如：a必须在b之前。<br>同时，社会是不平等的，这些人有的穷有的富。1号最富，2号第二富，以此类推。有钱人就贿赂负责人，所以他们有一些好处。</p>
<p>负责人现在可以安排大家排队的顺序，由于收了好处，所以他要让1号尽量靠前，如果此时还有多种情况，就再让2号尽量靠前，如果还有多种情况，就让3号尽量靠前，以此类推。</p>
<p>那么你就要安排大家的顺序。我们保证一定有解。<br>Input<br>第一行一个整数T(1 &lt;= T &lt;= 5),表示测试数据的个数。<br>然后对于每个测试数据，第一行有两个整数n(1 &lt;= n &lt;= 30000)和m(1 &lt;= m &lt;= 100000)，分别表示人数和约束的个数。</p>
<p>然后m行，每行两个整数a和b，表示有一个约束a号必须在b号之前。a和b必然不同。<br>Output<br>对每个测试数据，输出一行排队的顺序，用空格隔开。</p>
<p>Sample<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5 10</span><br><span class="line">3 5</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">1 4</span><br><span class="line">2 3</span><br><span class="line">1 5</span><br><span class="line">3 5</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>要注意的是本题不是字典序问题，而是要让小的编号尽量靠前</strong>，字典序问题我们很清楚一般都是可以利用贪心来做，因为字典序每一步都需要要最小，每一步都是局部最优，最后必然是全局最优的。但是编号小的尽可能靠前则不同，应为到编号为i的前面数可以能是很大的值，只要将i排列到所有合法方案的最前面，才是编号小靠前问题，是不能使用贪心来求解的。<br><strong>但是我们知道小的值不一定在前面，但是大的值一定在后面</strong>,于是我们对于编号问题就需要使用逆向建图，使用大根堆进行维护，然后答案保存在vector，倒序输出<br><strong>字典序问题就使用小根堆进行维护，每一步都是局部最优</strong></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; <span class="built_in">assert</span>(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30010</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">top</span>();</span><br><span class="line">        ans.<span class="built_in">pb</span>(t);</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>( -- d[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">        ans.<span class="built_in">clear</span>();</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="built_in">add</span>(b,a);</span><br><span class="line">            d[a] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">topsort</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i --) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; ans[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
        <category>HDU</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
        <tag>类字典序问题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1081. Smallest Subsequence of Distinct Characters</title>
    <url>/2022/07/16/LeetCode-1081-Smallest-Subsequence-of-Distinct-Characters/</url>
    <content><![CDATA[<h2 id="LeetCode-1081-Smallest-Subsequence-of-Distinct-Characters"><a href="#LeetCode-1081-Smallest-Subsequence-of-Distinct-Characters" class="headerlink" title="LeetCode 1081. Smallest Subsequence of Distinct Characters"></a><a href="https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/">LeetCode 1081. Smallest Subsequence of Distinct Characters</a></h2><p>题目描述<br>返回字符串 text 中按字典序排列最小的子序列，该子序列包含 text 中所有不同字符一次。</p>
<p>样例<br>输入：<code>&quot;cdadabcc&quot;</code><br>输出：<code>&quot;adbc&quot;</code><br>输入：<code>&quot;abcd&quot;</code><br>输出：<code>&quot;abcd&quot;</code><br>输入：<code>&quot;ecbacba&quot;</code><br>输出：<code>&quot;eacb&quot;</code><br>输入：<code>&quot;leetcode&quot;</code><br>输出：<code>&quot;letcod&quot;</code><br>注意<br>1 &lt;= text.length &lt;= 1000<br>text 由小写英文字母组成。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>单调栈  + 贪心<br>要想字典序越小那么我们的第一个字符一定是越小越好，于是我们就需要维护的是一个单调递增的单调栈<br>入栈： </p>
<ol>
<li>（如果这个字符后面还会再出现） 要求这个字符不在栈中并且栈顶元素比他要更大</li>
<li>(如果这个字符在后面不会再出现）这个字符不在栈中（由于题目要求最后求的字符串每个字符都要出现）所以这个字符一定要入栈</li>
</ol>
<p>出栈： </p>
<ol>
<li>如果栈顶这个字符后面还会再出现，并且当前栈顶字符大于当前字符的话，那么栈顶字符出栈</li>
<li>反之栈顶在这个字符不会再出现，就不能出栈</li>
</ol>
<p>在这里我们用cnt来保存每个字符出现次数，然后再遍历原字符串的时候，每次字符出现cnt—，这里的cnt数组记录的是从这个字符往后的还会出现多少次，如果为0了那么往后就不会再出现了。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>,N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt[<span class="number">30</span>];    <span class="comment">// 记录每个字符出现的次数</span></span><br><span class="line"><span class="type">char</span> st[N];  <span class="comment">//   单调递增栈</span></span><br><span class="line"><span class="type">bool</span> sta[<span class="number">30</span>]; <span class="comment">// 记录字符是否在栈里面出现了</span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">    <span class="type">int</span> n = s.size();</span><br><span class="line">    <span class="comment">// 记录每个字符出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">        cnt[s[i]-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单调栈 + 贪心 处理 字典序问题</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>; st[<span class="number">0</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// &gt; 表示了单调递增，cnt[] &gt; 0 说明了后面这个元素至少还会出现一次</span></span><br><span class="line">        cnt[s[i] - <span class="string">&#x27;a&#x27;</span>] --; <span class="comment">//  每次字符出现一次就把他减去，表示的是从这个字符位置往后还有多少个</span></span><br><span class="line">        <span class="keyword">if</span>(sta[s[i] - <span class="string">&#x27;a&#x27;</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 出栈，更新栈顶指针与栈顶元素的状态</span></span><br><span class="line">        <span class="keyword">while</span>(hh &amp;&amp; st[hh] &gt; s[i] &amp;&amp; cnt[st[hh] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) sta[st[hh] - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">false</span>, hh --;<span class="comment">// 这里要注意hh的顺序是在后面的</span></span><br><span class="line">        st[++hh] = s[i];</span><br><span class="line">        sta[s[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= hh; i ++) <span class="built_in">cout</span> &lt;&lt; st[i];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 1201 Intervals</title>
    <url>/2022/07/22/POJ-1201-Intervals/</url>
    <content><![CDATA[<h2 id="POJ-1201-Intervals"><a href="#POJ-1201-Intervals" class="headerlink" title="POJ - 1201 Intervals"></a><a href="https://vjudge.net/problem/POJ-1201">POJ - 1201 Intervals</a></h2><p>You are given n closed, integer intervals [ai, bi] and n integers c1, …, cn.<br>Write a program that:<br>reads the number of intervals, their end points and integers c1, …, cn from the standard input,<br>computes the minimal size of a set Z of integers which has at least ci common elements with interval [ai, bi], for each i=1,2,…,n,<br>writes the answer to the standard output.<br>Input<br>The first line of the input contains an integer n (1 &lt;= n &lt;= 50000) — the number of intervals. The following n lines describe the intervals. The (i+1)-th line of the input contains three integers ai, bi and ci separated by single spaces and such that 0 &lt;= ai &lt;= bi &lt;= 50000 and 1 &lt;= ci &lt;= bi - ai+1.<br>Output<br>The output contains exactly one integer equal to the minimal size of set Z sharing at least ci elements with interval [ai, bi], for each i=1,2,…,n.</p>
<p>Sample<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 7 3</span><br><span class="line">8 10 3</span><br><span class="line">6 8 1</span><br><span class="line">1 3 1</span><br><span class="line">10 11 1</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>本题要我们去求的选取区间的中的元素个数最少。比如要求[1,6]至少选一个元素，[2,7]至少选一个元素，对于上面这个区间我们只需在其区间交集处选取元素，所以这个问题很有可能是一个<code>线段树问题 + 贪心</code>。<br>算法一<code>树状数组 + 贪心</code><br>（待补）</p>
<p>算法二 <code>差分约束</code><br>差分约束无非就是求解不等式系统问题，所以关键的是我们如果构造出不等式组。<br>在此借用前缀和数组的思想<code>s[i]</code>表示从1～i中选取<code>j</code>个元素<br>因为在这里我们需要求最小值，所以应该化成最长路问题<br>约束条件</p>
<ol>
<li><code>s[i] &gt;= s[i-1]</code></li>
<li><code>s[i] - s[i-1] &lt;= 1</code> -&gt; <code>s[i-1] &gt;= s[i] -1 1</code>(相隔一位的区间最多只能选一个或者不选)</li>
<li><code>s[b] - s[a] &gt;= c</code> -&gt; <code>s[b] &gt;= s[a] + c</code> （因为我们需要在这个区间中选取至少c个元素）</li>
<li>s[0]第0个元素之前没有元素可以选<br><strong>i的下标取值范围[1,50001]，差分约束这里的边要开到点数的三倍，有三个不等数组三组约束</strong><br>本题<br>构造完不等式组我们就可以建图(不会建图可以看这篇<a href="差分约束.md">差分约束</a>，计算最长路即可。</li>
</ol>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; <span class="built_in">assert</span>(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>, M = N * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N],e[M],w[M],ne[M], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> dist[N],q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[tt ++] = <span class="number">0</span>;</span><br><span class="line">    st[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="comment">// 最长路</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &lt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt ++] = j;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀和数组从一开始（都加一）</span></span><br><span class="line">    <span class="comment">// 初始化 si &gt;= si-1 si-1 &gt;= si - 1</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50001</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(i,i<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">add</span>(i<span class="number">-1</span>, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// s[b] &gt;= s[a-1] + c</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        a ++, b ++;</span><br><span class="line">        <span class="built_in">add</span>(a<span class="number">-1</span>, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dist[<span class="number">50001</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>图论</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-1321 棋盘问题</title>
    <url>/2022/10/15/POJ-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="POJ-1321-棋盘问题"><a href="#POJ-1321-棋盘问题" class="headerlink" title="POJ-1321 棋盘问题"></a><a href="https://vjudge.net/problem/POJ-1321">POJ-1321 棋盘问题</a></h2><p>在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。<br>Input<br>输入含有多组测试数据。<br>每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n<br>当为-1 -1时表示输入结束。<br>随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。<br>Output<br>对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C<2^31）。
Sample
Input
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">#.</span><br><span class="line">.#</span><br><span class="line">4 4</span><br><span class="line">...#</span><br><span class="line">..#.</span><br><span class="line">.#..</span><br><span class="line">#...</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题有棋子的个数限制，所以有可能会出现棋子不足/棋子过量的情况，所以不能想八皇后问题，第一行一定会摆棋子。</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll res;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 记录每一列的状况</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == m) res ++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[x][i] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; !st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x + <span class="number">1</span>,cnt + <span class="number">1</span>);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(x + <span class="number">1</span>, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m, ~n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,g[i]);</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>POJ</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 1947 Rebuilding Roads</title>
    <url>/2022/08/06/POJ-1947-Rebuilding-Roads/</url>
    <content><![CDATA[<h2 id="POJ-1947-Rebuilding-Roads"><a href="#POJ-1947-Rebuilding-Roads" class="headerlink" title="POJ - 1947 Rebuilding Roads"></a><a href="https://vjudge.net/problem/POJ-1947#author=0">POJ - 1947 Rebuilding Roads</a></h2><p>The cows have reconstructed Farmer John’s farm, with its N barns (1 &lt;= N &lt;= 150, number 1..N) after the terrible earthquake last May. The cows didn’t have time to rebuild any extra roads, so now there is exactly one way to get from any given barn to any other barn. Thus, the farm transportation system can be represented as a tree.</p>
<p>Farmer John wants to know how much damage another earthquake could do. He wants to know the minimum number of roads whose destruction would isolate a subtree of exactly P (1 &lt;= P &lt;= N) barns from the rest of the barns.</p>
<p><strong>Input</strong></p>
<ul>
<li><p>Line 1: Two integers, N and P</p>
</li>
<li><p>Lines 2..N: N-1 lines, each with two integers I and J. Node I is node J’s parent in the tree of roads.</p>
</li>
</ul>
<p><strong>Output</strong><br>A single line containing the integer that is the minimum number of roads that need to be destroyed for a subtree of P nodes to be isolated.</p>
<p>Sample<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11 6</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">2 6</span><br><span class="line">2 7</span><br><span class="line">2 8</span><br><span class="line">4 9</span><br><span class="line">4 10</span><br><span class="line">4 11</span><br></pre></td></tr></table></figure></p>
<p>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>大意：一颗n个节点树要我们剪最少的边最后得到一颗m个节点的树，求剪的最少的边数</p>
<p>树形dp<br>重要的是如何对集合的划分<br>在这里就相当一颗以u为根节点的数的，以他的孩子为根就相当于每一组分组，从每一个种选择某一种方案组成的最优方案<br>属性：剪的最少边数<br>集合：dp[i][j] 以i位根的树保留j个节点需要的剪的最少边数<br>状态转移：dp[u][j] = min(dp[u][j],dp[u][j - k] + dp[v][k]);</p>
<p>但本题有几个细节</p>
<ol>
<li>最优解不一定是通过的根节点决定</li>
<li>树上背包要是通过子节点来更新，那么一定要保留父节点到子节点之间的边</li>
</ol>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">155</span>, M = N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> son[N],dp[N][N];    <span class="comment">// son[i]表示一个节点的子节点有多少个</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的是以u为根节点的树的节点总数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只保留一个节点的话那么就把以u为根的节点到其所有的子节点的边都删掉</span></span><br><span class="line">    dp[u][<span class="number">1</span>] = son[u];</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        sum += <span class="built_in">dfs</span>(v);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = sum; j &gt;= <span class="number">0</span>; j --)  </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= j; k ++)    <span class="comment">// 表子树保留k个节点的</span></span><br><span class="line">                dp[u][j] = <span class="built_in">min</span>(dp[u][j],dp[v][k] + dp[u][j-k] - <span class="number">1</span>); <span class="comment">// 要是用v来更新父节点的话，u-&gt;v之间的边是不能删去的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        son[a] ++;</span><br><span class="line">        st[b] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(st[root]) root ++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = dp[root][m];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可能在子树上(也就是如果我们剪一刀就剪出来一颗子树为m个节点那么很显然答案就是“1”)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">if</span>(dp[i][m] &lt; res)</span><br><span class="line">            res = dp[i][m] + <span class="number">1</span>; <span class="comment">// 要加一因为一刀就切出来m个节点的树那么这一刀是切在这颗子树的根节点上面</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>POJ</category>
        <category>动态规划</category>
        <category>树形dp</category>
        <category>树上背包</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-2251 Dungeon Master</title>
    <url>/2022/10/16/POJ-2251-Dungeon-Master/</url>
    <content><![CDATA[<h2 id="POJ-2251-Dungeon-Master"><a href="#POJ-2251-Dungeon-Master" class="headerlink" title="POJ-2251 Dungeon Master"></a><a href="https://vjudge.net/problem/POJ-2251#author=StelaYuri">POJ-2251 Dungeon Master</a></h2><p>You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides.</p>
<p>Is an escape possible? If yes, how long will it take?<br>你被困在一个 L\times R\times CL×R×C 的三维迷宫内，每分钟你只能够往上、下、左、右、前、后这六个方向的任意一个方向走一个单位。初始时你位于 SS 位置，迷宫的出口为 EE 位置，迷宫中标 ## 的位置无法通过，并且你也不能够走出迷宫的边界。</p>
<p>你是否能够走出这个迷宫？如果能，求出最少的时间。</p>
<p>Input<br>The input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).<br>L is the number of levels making up the dungeon.<br>R and C are the number of rows and columns making up the plan of each level.<br>Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a ‘#’ and empty cells are represented by a ‘.’. Your starting position is indicated by ‘S’ and the exit by the letter ‘E’. There’s a single blank line after each level. Input is terminated by three zeroes for L, R and C.<br>迷宫有 L 层，每层长宽为 $R\times C。(L,R,C\le 30)$</p>
<p>输入有多组，以 L=R=C=0 结束。</p>
<p>Output<br>Each maze generates one line of output. If it is possible to reach the exit, print a line of the form Escaped in x minute(s). where x is replaced by the shortest time it takes to escape.<br>If it is not possible to escape, print the line Trapped!<br>Sample<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 5</span><br><span class="line">S....</span><br><span class="line">.###.</span><br><span class="line">.##..</span><br><span class="line">###.#</span><br><span class="line"></span><br><span class="line">#####</span><br><span class="line">#####</span><br><span class="line">##.##</span><br><span class="line">##...</span><br><span class="line"></span><br><span class="line">#####</span><br><span class="line">#####</span><br><span class="line">#.###</span><br><span class="line">####E</span><br><span class="line"></span><br><span class="line">1 3 3</span><br><span class="line">S##</span><br><span class="line">#E#</span><br><span class="line">###</span><br><span class="line"></span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Escaped in 11 minute(s).</span><br><span class="line">Trapped!</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对于迷宫问题或者说使用的是dx/dy 这类数组涉及到-1/+1操作的情况，存储的边界建议的是从1开始存储，否则很容易SF错误</p>
<p>对于像POJ这样的老的不行的评测机</p>
<ul>
<li>写结构体时候务必写构造函数并带上默认值。</li>
<li>不能使用auto</li>
<li>不能直接使用{x,y}这类，必须使用构造函数</li>
</ul>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define rep(i,a,n) for (int i=a;i&lt;n;i++)</span><br><span class="line">#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span><br><span class="line">#define pb push_back</span><br><span class="line">#define eb emplace_back</span><br><span class="line">#define mp make_pair</span><br><span class="line">#define all(x) (x).begin(),(x).end()</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">#define SZ(x) ((int)(x).size())</span><br><span class="line">typedef vector&lt;int&gt; VI;</span><br><span class="line">typedef basic_string&lt;int&gt; BI;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">typedef double db;</span><br><span class="line">const ll mod=1000000007;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">ll gcd(ll a,ll b) &#123; return b?gcd(b,a%b):a;&#125;</span><br><span class="line">// head</span><br><span class="line">const int N =35, M = N * N * N;</span><br><span class="line"></span><br><span class="line">struct loc</span><br><span class="line">&#123;</span><br><span class="line">    int x,y,z;</span><br><span class="line">    loc(int x = 0, int y = 0, int z = 0):x(x), y(y), z(z)&#123;&#125;</span><br><span class="line">&#125;q[M];</span><br><span class="line"></span><br><span class="line">char g[N][N][N];</span><br><span class="line">int dx[] = &#123;0,0,1,-1,0,0&#125;, dy[] = &#123;0,0,0,0,1,-1&#125;, dz[] = &#123;1,-1,0,0,0,0&#125;;</span><br><span class="line">int dist[N][N][N];</span><br><span class="line">int x,y,z;</span><br><span class="line">loc st, ed;</span><br><span class="line"></span><br><span class="line">int bfs(int sx, int sy, int sz)</span><br><span class="line">&#123;</span><br><span class="line">    memset(dist, -1, sizeof dist);</span><br><span class="line">    int hh = 0, tt = 0;</span><br><span class="line">    q[0] = loc(sx,sy,sz);</span><br><span class="line">    dist[sy][sx][sz] = 0;</span><br><span class="line"></span><br><span class="line">    while(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        loc t = q[hh ++];</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; 6; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            int cx = t.x + dx[i], cy = t.y + dy[i], cz = t.z + dz[i];</span><br><span class="line">            if(cx &lt;= 0 || cx &gt; x || cy &lt;= 0 || cy &gt; y || cz &lt;= 0 || cz &gt; z) continue;</span><br><span class="line">            if(~dist[cy][cx][cz] || g[cy][cx][cz] == &#x27;#&#x27;) continue;</span><br><span class="line">            q[++ tt] = loc(cx,cy,cz);</span><br><span class="line">            dist[cy][cx][cz] = dist[t.y][t.x][t.z]  + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dist[ed.y][ed.x][ed.z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin &gt;&gt; y &gt;&gt; x &gt;&gt; z, y &amp;&amp; x &amp;&amp; z)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 1; i &lt;= y; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j = 1; j &lt;= x; j ++)</span><br><span class="line">                for(int k = 1; k &lt;= z; k ++)</span><br><span class="line">                &#123;</span><br><span class="line">                    cin &gt;&gt; g[i][j][k];</span><br><span class="line">                    if(g[i][j][k] == &#x27;S&#x27;)</span><br><span class="line">                        st = loc(j,i,k);</span><br><span class="line">                    if(g[i][j][k] == &#x27;E&#x27;)</span><br><span class="line">                        ed = loc(j,i,k);</span><br><span class="line">                &#125;</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(st.x == ed.x &amp;&amp; st.y == ed.y &amp;&amp; st.z == ed.z) </span><br><span class="line">            printf(&quot;Escaped in 0 minute(s).\n&quot;);</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            int ans = bfs(st.x,st.y,st.z);</span><br><span class="line">            if(ans == -1) puts(&quot;Trapped!&quot;);</span><br><span class="line">            else printf(&quot;Escaped in %d minute(s).\n&quot;,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>POJ</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 2528 Mayor&#39;s posters</title>
    <url>/2022/07/27/POJ-2528-Mayor-s-posters/</url>
    <content><![CDATA[<h2 id="POJ-2528-Mayor’s-posters"><a href="#POJ-2528-Mayor’s-posters" class="headerlink" title="POJ - 2528 Mayor’s posters"></a><a href="https://vjudge.net/problem/POJ-2528">POJ - 2528 Mayor’s posters</a></h2><p>The citizens of Bytetown, AB, could not stand that the candidates in the mayoral election campaign have been placing their electoral posters at all places at their whim. The city council has finally decided to build an electoral wall for placing the posters and introduce the following rules:<br>Every candidate can place exactly one poster on the wall.<br>All posters are of the same height equal to the height of the wall; the width of a poster can be any integer number of bytes (byte is the unit of length in Bytetown).<br>The wall is divided into segments and the width of each segment is one byte.<br>Each poster must completely cover a contiguous number of wall segments.</p>
<p>They have built a wall 10000000 bytes long (such that there is enough place for all candidates). When the electoral campaign was restarted, the candidates were placing their posters on the wall and their posters differed widely in width. Moreover, the candidates started placing their posters on wall segments already occupied by other posters. Everyone in Bytetown was curious whose posters will be visible (entirely or in part) on the last day before elections.<br>Your task is to find the number of visible posters when all the posters are placed given the information about posters’ size, their place and order of placement on the electoral wall.<br>Input<br>The first line of input contains a number c giving the number of cases that follow. The first line of data for a single case contains number 1 &lt;= n &lt;= 10000. The subsequent n lines describe the posters in the order in which they were placed. The i-th line among the n lines contains two integer numbers li and ri which are the number of the wall segment occupied by the left end and the right end of the i-th poster, respectively. We know that for each 1 &lt;= i &lt;= n, 1 &lt;= li &lt;= ri &lt;= 10000000. After the i-th poster is placed, it entirely covers all wall segments numbered li, li+1 ,… , ri.<br>Output<br>For each input data set print the number of visible posters after all the posters are placed.</p>
<p>The picture below illustrates the case of the sample input.<br><img src="https://vj.csgrandeur.cn/85d8df2191db8df82ba259ebe2bfe93e?v=1658733874" alt="例图"></p>
<p>Sample<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">1 4</span><br><span class="line">2 6</span><br><span class="line">8 10</span><br><span class="line">3 4</span><br><span class="line">7 10</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目要我们求出现完整的没有完全被挡住的海报的个数<br>每次出现一张海报我们都要在该位置坐标上记录其出现次数，用次数来维护没有被完整挡住的海报个数。<br>分类讨论是否仅使用cnt就能维护<br>区间覆盖问题<br>思路一：<br>如果区间被包含的话，那么如果这个区间先被贴上海报的话，那么这个区间就是被覆盖，这样我们就可以知道，前面的区间是会被后面的区间所影响，但是后面的出现的区间却不会被前面的区间影响。所以在计算答案的时候考虑从后面区间往前面区间开始计算。<br>思路二：<br>染色<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> co;</span><br><span class="line">    <span class="type">int</span> tag;    <span class="comment">// tag = 0表示这个区间没有被染色, tag = 1表示这个区间被染色且这个区间是相同颜色, tag = 2表示这个区间被染色但是染色的颜色不是同一种颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> co; <span class="comment">// 表示在区间单色的情况下被染上的颜色</span></span><br><span class="line">    <span class="comment">// 懒标记</span></span><br><span class="line">    <span class="comment">//int tag; // tag = 0表示没有被染色 1表示区间染色的情况是单色, 2表示的是多色</span></span><br><span class="line">    <span class="type">int</span> val; <span class="comment">// 表示当前区间被染上的颜色</span></span><br><span class="line">&#125;tr[N * <span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> color[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vx;</span><br><span class="line">PII pos[N];</span><br><span class="line"><span class="type">int</span> n,res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// void pushup(int u) pushup操作比较麻烦（因为设计到判断这个节点是单色还是多色的问题），所以不如去根节点去找不同的染色情况</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(vx.<span class="built_in">begin</span>(),vx.<span class="built_in">end</span>(),x) - vx.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 涉及到懒标记下放的时候这时候区间一定是单色情况</span></span><br><span class="line">    <span class="comment">// 假设不是单色情况，但是懒标记没下放。显然是矛盾的，因为要想不是单色其子区间一定有不同颜色，一定会先涉及到区间修改</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].val)</span><br><span class="line">    &#123;</span><br><span class="line">        node &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], &amp;root = tr[u];</span><br><span class="line">        left.co = root.val;</span><br><span class="line">        right.co = root.val;</span><br><span class="line">        left.val = root.val;</span><br><span class="line">        right.val = root.val;</span><br><span class="line">        root.val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r;</span><br><span class="line">        tr[u].co = <span class="number">0</span>, tr[u].val = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r;</span><br><span class="line">        tr[u].co = <span class="number">0</span>, tr[u].val = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l ,<span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].val = d;</span><br><span class="line">        tr[u].co = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == tr[u].r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[tr[u].co] &amp;&amp; tr[u].co)</span><br><span class="line">        &#123;</span><br><span class="line">            color[tr[u].co] = <span class="literal">true</span>;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid =  tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        vx.<span class="built_in">clear</span>();</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="keyword">sizeof</span> color);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            pos[i] = <span class="built_in">mp</span>(a,b);</span><br><span class="line">            vx.<span class="built_in">pb</span>(a<span class="number">-1</span>),vx.<span class="built_in">pb</span>(a),vx.<span class="built_in">pb</span>(b),vx.<span class="built_in">pb</span>(b+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(vx));</span><br><span class="line">        vx.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(vx)),vx.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 本题没有和其他点一样，一个点表示的一个区间，映射下表表示的是单点</span></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,vx.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,<span class="built_in">find</span>(pos[i].fi), <span class="built_in">find</span>(pos[i].se), i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, vx.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 3268 Silver Cow Party</title>
    <url>/2022/11/07/POJ-3268-Silver-Cow-Party/</url>
    <content><![CDATA[<h2 id="POJ-3268-Silver-Cow-Party"><a href="#POJ-3268-Silver-Cow-Party" class="headerlink" title="POJ - 3268 Silver Cow Party"></a><a href="https://www.acwing.com/problem/content/1134/">POJ - 3268 Silver Cow Party</a></h2><p>N 头牛要去参加在某农场举行的一场编号为 X 的牛的派对。</p>
<p>有 M 条有向道路，每条路长 Ti；每头牛参加完派对后都必须回到家，每头牛都会选择最短路径。</p>
<p>求这 N 头牛的最短路径（一个来回）中最长的一条的长度。</p>
<p>特别提醒：可能有权值不同的重边。</p>
<p>输入格式<br>第一行包含三个整数 N,M,X。</p>
<p>接下来 M 行，每行包含三个整数 Ai,Bi,Ti，表示有一条从 Ai 到 Bi 的路，长度为 Ti。</p>
<p>输出格式<br>共一行，一个数，表示最短路中最长的一条的长度。</p>
<p>数据范围<br>1≤N≤1000,<br>1≤X≤N,<br>1≤M≤105,<br>1≤Ti≤100<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 8 2</span><br><span class="line">1 2 4</span><br><span class="line">1 3 2</span><br><span class="line">1 4 7</span><br><span class="line">2 1 1</span><br><span class="line">2 3 5</span><br><span class="line">3 1 2</span><br><span class="line">3 4 4</span><br><span class="line">4 2 3</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>我们找除所有最短路径的中的最大值</strong><br>这里的路径由两部分组成</p>
<ol>
<li>从我们的源点到派对地方</li>
<li>从派对的地方回到起点</li>
</ol>
<p>第一部分是一个多源点最短路问题，所以我们一开始反向建图跑单源最短路<br>第二部分是一个普通的单源最短路问题</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h1[N],h2[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="type">int</span> n,m,sta;</span><br><span class="line"><span class="type">int</span> dist1[N], dist2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> h[], <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> h[], <span class="type">int</span> dist[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> st[N];</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist1);</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,sta&#125;);</span><br><span class="line">    dist[sta] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.se, dis = t.fi;</span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j],j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h1,<span class="number">-1</span>,<span class="keyword">sizeof</span> h1);</span><br><span class="line">    <span class="built_in">memset</span>(h2,<span class="number">-1</span>,<span class="keyword">sizeof</span> h2);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; sta;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(h1,b,a,c);</span><br><span class="line">        <span class="built_in">add</span>(h2,a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>(h1, dist1);</span><br><span class="line">    <span class="built_in">dijkstra</span>(h2,dist2);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        res = <span class="built_in">max</span>(res, dist1[i] + dist2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kuangbing</category>
        <category>专题四 最短路练习</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>kuangbing</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-3279 Fliptile</title>
    <url>/2022/10/18/POJ-3279-Fliptile/</url>
    <content><![CDATA[<h2 id="POJ-3279-Fliptile"><a href="#POJ-3279-Fliptile" class="headerlink" title="POJ-3279 Fliptile"></a><a href="https://vjudge.net/problem/POJ-3279">POJ-3279 Fliptile</a></h2><p>夫约翰知道，一头知识上满意的母牛是一头快乐的母牛，它将提供更多的牛奶。他为母牛安排了脑力活动，他们在其中操纵M × N 网格（1≤ M ≤15； 1≤ N ≤15）个正方形瓷砖，每个瓷砖的一面都涂成黑色，另一面则涂成白色。</p>
<p>正如人们所猜测的那样，当翻转单个白色瓷砖时，它会改变变黑翻转单个黑色图块时，它会变为白色。母牛在翻转砖块时会得到奖励，因此每块砖块的白色侧面都朝上。但是，母牛的蹄子相当大，当他们尝试翻转特定的砖块时，它们也会翻转所有相邻的砖块（与翻转后的砖块共享整个边缘的砖块）。由于翻转很累，奶牛希望尽量减少必须做的翻转次数。</p>
<p>帮助母牛确定所需的最小翻转次数，并确定要达到最小翻转次数的位置。如果有多种方法可以以最少的翻转次数来完成任务，则当将其视为字符串时，以输出中词典顺序最少的方式返回。如果无法完成任务，请用“ IMPOSSIBLE”一词打印一行。</p>
<p>Input<br>第1行：两个以空格分隔的整数： M 和 N<br>第2 .. M +1行：第 i +1行描述了网格中第i行（ N 以空格分隔的整数，黑色为1，白色为0。<br>Output<br>第1 .. M 行：每行包含 N 个以空格分隔的整数，每个整数指定翻转该特定位置的次数。</p>
<p>Sample Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 0 0 1</span><br><span class="line">0 1 1 0</span><br><span class="line">0 1 1 0</span><br><span class="line">1 0 0 1</span><br></pre></td></tr></table></figure><br>Sample Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0</span><br><span class="line">1 0 0 1</span><br><span class="line">1 0 0 1</span><br><span class="line">0 0 0 0</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>二进制压缩</strong><br>这里压缩状态意义是：<strong>每一位是否翻转</strong></p>
<p>如： 101 表示的第1位和第三位进行翻转，假如一共有三位，根据组合数学知道一共会有2^3 - 1个组成方式，我们即可以从000枚举到111(0表示没有对这个位置进行翻转，1表示对这个位置进行翻转)</p>
<p><strong>我们还要知道一点是，只要第一行确定了，下面的翻转的方案也就固定了</strong></p>
<p>如：第一行为101 应为要保证全0所以下一行的对应上一行1位置要进行翻转</p>
<p>本题是细节非常多！！</p>
<p>比如<br>（1）我们要清楚知道这里的状态压缩压缩的状态所代表的意义<br>（2）方案不一定成立，所以要检查枚举完最后的一行是否全0</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g为原图， test是通过每一次枚举第一行的方案进行测试</span></span><br><span class="line"><span class="comment">// save表示的是我们存下的最优方案（翻转次数最小且字典序最小）, backup表示的是当前存储的改变次数的数组</span></span><br><span class="line"><span class="type">int</span> g[N][N], test[N][N];</span><br><span class="line"><span class="type">int</span> save[N][N], backup[N][N];</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;, dy[] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> n, m, res,cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyArr</span><span class="params">(<span class="type">int</span> test[][N], <span class="type">int</span> g[][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            test[i][j] = g[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; n; i ++)</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; test[x-1][i] &lt;&lt; &quot; \n&quot;[i == n-1];</span></span><br><span class="line">    <span class="keyword">if</span>(x == m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;test&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; m; i ++)</span></span><br><span class="line">        <span class="comment">//     for(int j = 0; j &lt; n; j ++)</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; test[i][j] &lt;&lt; &quot; \n&quot;[j == n-1];</span></span><br><span class="line">        <span class="comment">// 检测一下最后一行是否全为0</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">if</span>(test[x<span class="number">-1</span>][i] == <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; cnt &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(test[x<span class="number">-1</span>][i])</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            backup[x][i] ++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 翻转</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> cx = x + dx[j], cy = i + dy[j];</span><br><span class="line">                <span class="keyword">if</span>(cx &gt;= <span class="number">0</span> &amp;&amp; cx &lt; m &amp;&amp; cy &gt;= <span class="number">0</span> &amp;&amp; cy &lt; n)</span><br><span class="line">                    test[cx][cy] ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 枚举第一行的所有可能性</span></span><br><span class="line">    <span class="comment">// 我们要知道一件事的就是无论的初始状态是什么，都能经过有限次的组合变化变沉另外一种状态</span></span><br><span class="line">    <span class="built_in">memset</span>(save , <span class="number">0</span>, <span class="keyword">sizeof</span> save);</span><br><span class="line">    res = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; n); k ++) <span class="comment">// 二进制压缩状态</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">copyArr</span>(test, g);</span><br><span class="line">        <span class="built_in">memset</span>(backup, <span class="number">0</span>, <span class="keyword">sizeof</span> backup);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line">        <span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;save&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; m; i ++)</span></span><br><span class="line">        <span class="comment">//     for(int j = 0; j &lt; n; j ++)</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; save[i][j] &lt;&lt; &quot; \n&quot;[j == n-1];</span></span><br><span class="line">        <span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line">        <span class="comment">// puts(&quot;&quot;);</span></span><br><span class="line"></span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j ++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> cx = <span class="number">0</span> + dx[j], cy = (n - i - <span class="number">1</span>) + dy[j];</span><br><span class="line">                    <span class="keyword">if</span>(cx &gt;= <span class="number">0</span> &amp;&amp; cx &lt; m &amp;&amp; cy &gt;= <span class="number">0</span> &amp;&amp; cy &lt; n)</span><br><span class="line">                    test[cx][cy] ^= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                backup[<span class="number">0</span>][n - i - <span class="number">1</span>] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;test&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; m; i ++)</span></span><br><span class="line">        <span class="comment">//     for(int j = 0; j &lt; n; j ++)</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; test[i][j] &lt;&lt; &quot; \n&quot;[j == n-1];</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(res &gt; t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; cnt &lt;&lt; endl;  </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                    save[i][j] = backup[i][j];</span><br><span class="line">            res = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; m; i ++)</span></span><br><span class="line">    <span class="comment">//         for(int j = 0; j &lt; n; j ++)</span></span><br><span class="line">    <span class="comment">//             cout &lt;&lt; g[i][j] &lt;&lt; &quot; \n&quot;[j == n-1];b</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;save&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span>(res == INF) <span class="built_in">puts</span>(<span class="string">&quot;IMPOSSIBLE&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                cout &lt;&lt; save[i][j] &lt;&lt; <span class="string">&quot; \n&quot;</span>[j == n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kuangbin</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 3342 Party at Hali-Bula</title>
    <url>/2022/08/03/POJ-3342-Party-at-Hali-Bula/</url>
    <content><![CDATA[<h2 id="POJ-3342-Party-at-Hali-Bula"><a href="#POJ-3342-Party-at-Hali-Bula" class="headerlink" title="POJ - 3342 Party at Hali-Bula"></a><a href="https://vjudge.net/problem/POJ-3342">POJ - 3342 Party at Hali-Bula</a></h2><p>Dear Contestant,</p>
<p>I’m going to have a party at my villa at Hali-Bula to celebrate my retirement from BCM. I wish I could invite all my co-workers, but imagine how an employee can enjoy a party when he finds his boss among the guests! So, I decide not to invite both an employee and his/her boss. The organizational hierarchy at BCM is such that nobody has more than one boss, and there is one and only one employee with no boss at all (the Big Boss)! Can I ask you to please write a program to determine the maximum number of guests so that no employee is invited when his/her boss is invited too? I’ve attached the list of employees and the organizational hierarchy of BCM.</p>
<p>Best,<br>—Brian Bennett</p>
<p>P.S. I would be very grateful if your program can indicate whether the list of people is uniquely determined if I choose to invite the maximum number of guests with that condition.</p>
<p>Input<br>The input consists of multiple test cases. Each test case is started with a line containing an integer n (1 ≤ n ≤ 200), the number of BCM employees. The next line contains the name of the Big Boss only. Each of the following n-1 lines contains the name of an employee together with the name of his/her boss. All names are strings of at least one and at most 100 letters and are separated by blanks. The last line of each test case contains a single 0.</p>
<p>Output<br>For each test case, write a single line containing a number indicating the maximum number of guests that can be invited according to the required condition, and a word Yes or No, depending on whether the list of guests is unique in that case.</p>
<p>Sample<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">Jason</span><br><span class="line">Jack Jason</span><br><span class="line">Joe Jack</span><br><span class="line">Jill Jason</span><br><span class="line">John Jack</span><br><span class="line">Jim Jill</span><br><span class="line">2</span><br><span class="line">Ming</span><br><span class="line">Cho Ming</span><br><span class="line">0</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 Yes</span><br><span class="line">1 No</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>最大独立集唯一性</strong><br>状态转移方程：<br>// 不选i<br>dp[i][0] += max(dp[j][1],dp[j][0]);<br>// 选<br>dp[i][1] += dp[j][0];</p>
<p>前提： 假设是以i为根的树， j是i的子节点</p>
<ol>
<li>显然如果以i位根的树dp[i][0] == dp[i][1]这种情况下，最大独立集不唯一。但是要注意不唯一情况下是有可能出现dp[i][0] != dp[i][1]</li>
<li>如果dp[j][0] == dp[j][1],并且如果max(dp[i][0],dp[i][1]) == dp[i]<a href="也就是说最大独立集通过子树j的最大独立集转移过来所以">0</a>，这个情况下最后的最大独立集一定不唯一<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(dp[j][0] == dp[j][1])</span><br><span class="line">     judge[i][0] = true;</span><br></pre></td></tr></table></figure></li>
<li>如果子节点不选的时候不唯一的情况下，那么当前节点选上了那么整个树也一定不唯一 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(judge[j][0])</span><br><span class="line">    judge[i][1] = true;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>本题要注意的是，在寻找唯一性不能对仅对数组dp检查，因为dp内保存的仅是所有方案中有一中最优方案</strong></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N],idx;</span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> judge[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,res;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; peo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    dp[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[u][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    judge[u][<span class="number">0</span>] = judge[u][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断唯一性（如果子树都不唯一了那么最后最大独立集一定也不唯一）</span></span><br><span class="line">        <span class="comment">// 更新judge数组</span></span><br><span class="line">        <span class="comment">// 当前节点不选的情况下，如果子节点最大独立集不唯一的话，那么总方案一定不唯一</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[j][<span class="number">0</span>] == dp[j][<span class="number">1</span>])</span><br><span class="line">            judge[u][<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 当子节点不选的情况下最大独立集不唯一的，总的最大独立集也不唯一</span></span><br><span class="line">        <span class="keyword">if</span>(!judge[j][<span class="number">0</span>])</span><br><span class="line">            judge[u][<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新dp数组</span></span><br><span class="line">        dp[u][<span class="number">0</span>] += <span class="built_in">max</span>(dp[j][<span class="number">0</span>], dp[j][<span class="number">1</span>]);</span><br><span class="line">        dp[u][<span class="number">1</span>] += dp[j][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init()</span></span><br><span class="line">        peo.<span class="built_in">clear</span>();</span><br><span class="line">        res = <span class="number">0</span>,idx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// big boss(root)</span></span><br><span class="line">        string a,b;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        peo[a] = num ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span>(!peo[a])</span><br><span class="line">                peo[a] = num ++;</span><br><span class="line">            <span class="keyword">if</span>(!peo[b])</span><br><span class="line">                peo[b] = num ++;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">add</span>(peo[b],peo[a]);</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">1</span>][<span class="number">0</span>] &gt; dp[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; judge[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d Yes\n&quot;</span>,dp[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dp[<span class="number">1</span>][<span class="number">0</span>] &lt; dp[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; judge[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d Yes\n&quot;</span>, dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d No\n&quot;</span>,<span class="built_in">max</span>(dp[<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>POJ</category>
        <category>树形dp</category>
        <category>最大独立集唯一性</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
        <tag>最大独立集</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1789 卡车历史</title>
    <url>/2022/07/14/POJ1789%E5%8D%A1%E8%BD%A6%E5%8E%86%E5%8F%B2/</url>
    <content><![CDATA[<h2 id="卡车历史"><a href="#卡车历史" class="headerlink" title="卡车历史"></a><a href="https://www.acwing.com/problem/content/4335/">卡车历史</a></h2><p>有 N 个点，每个点用一个长度为 7 的由小写字母构成的字符串表示。<br>不同点对应的字符串不同。<br>对于任意两点，它们对应的字符串在多少个位置上字母不同，则它们之间的距离就是多少。<br>例如，aaaa 和 baba 在第 1,3 个位置上字母不同，则它们之间的距离为 2。<br>现在，要将这 N 个点用边连接，组成一个树，要求组成树的所有边长之和尽可能小。<br>请你计算并输出最小边长和。</p>
<p>输入格式<br>输入包含多组测试数据。<br>每组数据第一行包含整数 N。<br>接下来 N 行，每行包含一个长度为 7 的由小写字母构成的字符串，表示一个点。<br>当输入 N=0 时，表示输入结束。</p>
<p>输出格式<br>输出一行，格式为 The highest possible quality is 1/Q.，其中 Q 为最小边长和。</p>
<p>数据范围<br>每组输入最多包含 10 组数据。<br>2≤N≤2000,<br>每个输入的所有 N 之和不超过 2000。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">aaaaaaa</span><br><span class="line">baaaaaa</span><br><span class="line">abaaaaa</span><br><span class="line">aabaaaa</span><br><span class="line">0</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The highest possible quality is 1/3.</span><br></pre></td></tr></table></figure></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>本题难点在于看出这是一个最小生成树问题，并对本题进行建图</strong><br>本题要求的是最小变换次数，一次只能改变一个位置的字符串<br>分析样例<br>aaaaaaa </p>
<ul>
<li>与 baaaaaa 只需变换第一位a变为b，一次变换</li>
<li>与 abaaaaa 只需变换第二位a变为b，一次变换</li>
<li>与 aabaaaa 只需变换第三位a变为b，一次变换</li>
</ul>
<p>baaaaaa</p>
<ul>
<li>abaaaaa 变换第一位b变为a，第二位a变为b，两次变换</li>
<li>aabaaaa 变换第一位b变为a，变换第三a变为b，两次变换</li>
</ul>
<p>abaaaaa</p>
<ul>
<li>aabaaaa 第二位b变为a，第三位a变为b，两次变换</li>
</ul>
<p>比如 aaaaaaa变换到baaaaaa  相当于aaaaaaa这个节点与baaaaaa连一条边，这个边的边权等于它们之间变换的次数<br>这样子就可以建立起一张完全图。要想所有的节点都变为相同的字符串，那么必然需要将其所有节点连通，并且最后一定是生成一棵树。</p>
<p>证明： 为什么一定会生成一棵树呢？？因为我们的所有边权都是正值，一定是没有负权边的，所以一共n个节点，其连通为连通图的最小边数为n-1条边就是一颗树的情况，每多加一条边，那么权值之和一定会增加。所以我们就将上面问题转换为一个最小生成树问题。</p>
<p>完全图：边数m = n*(n-1),所以在这里使用Prim算法会更优</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> mp[N][N];</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">char</span> s[N][<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">build</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">7</span>; k ++)</span><br><span class="line">                <span class="keyword">if</span>(s[i][k] != s[j][k]) cnt ++;</span><br><span class="line">            mp[i][j] = mp[j][i] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">prim</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dis[j] &lt; dis[t])) t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; dis[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i) res += dis[t];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) dis[j] = min(dis[j],mp[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(mp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> mp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j ++)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; s[i][j];</span><br><span class="line"></span><br><span class="line">        build();</span><br><span class="line">        <span class="type">int</span> ans = prim();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The highest possible quality is 1/&quot;</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>The 2021 CCPC Guilin Onsite I. PTSD</title>
    <url>/2022/07/15/The-2021-CCPC-Guilin-Onsite-I-PTSD/</url>
    <content><![CDATA[<h2 id="The-2021-CCPC-Guilin-Onsite-I-PTSD"><a href="#The-2021-CCPC-Guilin-Onsite-I-PTSD" class="headerlink" title="The 2021 CCPC Guilin Onsite I. PTSD"></a><a href="https://vjudge.net/problem/Gym-103409I#author=sunhaoyu">The 2021 CCPC Guilin Onsite I. PTSD</a></h2><p>有n个战士，编号为1~n，第i个战士的武力值为i，现在需要把n个战士分为若干组，每个战士都必须属于某个组，每个组都至少有一个战士，有一些战士会生一种怪病，就是当他所在的组有且仅有一名战士的武力值比他高时他就会难过qaq，然后现在你需要给这些战士分组，使得患病并难过的战士的武力值之和最大。<br>样例输入<br>有多组样例，第一行输入样例组数T，对于每一组样例：<br>第一行是一个整数 n [1,1e6],表明战士的数量</p>
<p>第二行是一个长度为n的01串，第i个位置为’0’表示第i个战士没有患病，第i个位置为’1’表示第i个战士患病，保证所有样例的n之和不超过1e6</p>
<p>样例输出<br>对于每一组样例，输出一行包含一个整数表示患病并难过的战士的武力值之和的最大值</p>
<p>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">10101</span><br><span class="line">8</span><br><span class="line">11111111</span><br><span class="line">4</span><br><span class="line">1100</span><br><span class="line">4</span><br><span class="line">0110</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">16</span><br><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure><br>Note<br>对于第一组样例，一个有效的分组方法是 [1, 2], [3, 4], [5],它使得第一个战士和第三个战士难过， [1, 2], [3, 5], [4] 也可以</p>
<p>对于第二组样例，一个有效的分组方法是 [1, 2], [3, 4], [5, 6], [7, 8].<br>对于第三组样例，一个有效的分组方法是[1, 3], [2, 4].<br>对于第四组样例，一个有效的分组方法是[1, 2, 3, 4].</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>等价于两两匹配。因为我们需要尽可能的组成更多的组，因为一组只能加一个权值，所以我们要组数越多那么组内的数据就要越小。<br>而且这里的匹配一定是大的数和大的数匹配，因为大的数和小的数匹配，这样最后的到匹配权值之和是&lt;=我们大的数和大的数匹配的（因为权值是加小的数）1111101<br>如果较小的为 PTSD 则对答案有贡献.<br>从大到小枚举每个数, 维护一个初值为 0 的计数器, 如果它是PTSD 且计数器大于 0, 说明有更大的数还未匹配, 那么统计进答案且计数器 −1. 否则计数器 +1. 可以发现这样答案是最优的. 复杂度 O(n)<br><strong>同时要注意这里的答案是有可能爆int的，1+…+1e6 = 1e12的级别</strong></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;    <span class="comment">// 计数器表示有没有比当前数更大的值(这个值有可能是0也有可能是1）没有与&#x27;1&#x27;匹配</span></span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt) res += i,cnt--;</span><br><span class="line">                <span class="keyword">else</span> cnt++;<span class="comment">//比他大的数都匹配完了，那么这个&#x27;1&#x27;就要下一步与别人匹配1110这个序列前两个要相互匹配</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>思维题</category>
      </categories>
      <tags>
        <tag>思维题</tag>
        <tag>构造</tag>
        <tag>CCPC</tag>
        <tag>代码能力</tag>
      </tags>
  </entry>
  <entry>
    <title>UESTC - 624 整数划分</title>
    <url>/2022/09/01/UESTC-624-%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<h2 id="UESTC-624-整数划分"><a href="#UESTC-624-整数划分" class="headerlink" title="UESTC - 624 整数划分"></a><a href="https://vjudge.net/problem/UESTC-624#author=0">UESTC - 624 整数划分</a></h2><p>一个整数可以写成多个整数相加的形式，比如44可以写成以下形式</p>
<p>4=4</p>
<p>4=3+1</p>
<p>4=2+2</p>
<p>4=2+1+1</p>
<p>4=1+1+1+1</p>
<p>注意 4=3+1和 4=1+3是一样的，现在多加一个要求，即等式右边的数不能相同，比如对于4来说，后面3种划分方式是不符合要求的，现在给定一个N，问有多少种划分方法，答案 mod 19901014</p>
<p>Input<br>第一行有个整数T，代表数据组数（T &lt;= 10000）</p>
<p>接下来有TT行，每行有个整数NN (1 ≤ N ≤ 1000)</p>
<p>Output<br>输出T行，每行输出一个整数，代表N的划分数 mod 19901014</p>
<p>Sample 1<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">10</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="算法一-类01背包计数类dp"><a href="#算法一-类01背包计数类dp" class="headerlink" title="算法一 类01背包计数类dp"></a>算法一 类01背包<code>计数类dp</code></h3><ul>
<li>错误的划分方法 dp[i][j] 表示整数i的划分的若干整数之和等于j<br>dp[i][j] = dp[i-1][j] + dp[i][j-i]， 这样子的求出来显然是会有相同数在方案里。<br>正确的划分方法 dp[i][j] 表示整数i划分的若干整数中最大值不超过j<br><strong>i &gt;= j时候</strong>   dp[i][j] = dp[i-j][j-1] + dp[i][j-1] (当前划分最大值选j， 当下划分最大值不选j)</li>
</ul>
<p>但是dp的做法最后的时间复杂度为 1000 <em> 1000 </em> 10000 (n <em> n </em> T)</p>
<h3 id="算法二-生成函数"><a href="#算法二-生成函数" class="headerlink" title="算法二 生成函数"></a>算法二 生成函数</h3><p><strong>普通的生成函数</strong>定义了对于有限数列{ai},定义其生成函数为∑ ai * x^i<br>举个例子对于数列为{2,4,6}的生成函数为 2 + 4x + 6x^2</p>
<p>在本题我们要求出来一个整数划分成不同的正整数，也就是说一个整数n划分，可以从1～n中每个数做选或不选即0/1，所以数列为{0,1,0,1…},每个数的数值作为次数<br>生成函数为：<br>g(x) = (1 + x)（1 + x^2)…(1 + x^n)<br>最后展开生成函数就知道划分成整数k的方案数就为生成函数k次项的系数</p>
<p><a href="https://zhuanlan.zhihu.com/p/106522599">生成函数</a></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><h4 id="计数类dp"><a href="#计数类dp" class="headerlink" title="计数类dp"></a>计数类dp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">19901014</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[N][N];  <span class="comment">// dp[i][j]表示 整数i划分成若干正整数最大值不超过j的情况下合法划分方案数</span></span><br><span class="line"><span class="type">int</span> T, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init 多组测试数据需要初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; N; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前的整数i划分最大值不超过j，情况可以分成两类严格不超过j， 非严格不超过j（也就是选j和不选j的情况）</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt;= i) dp[i][j] = (dp[i][j<span class="number">-1</span>] + dp[i-j][j<span class="number">-1</span>]) % mod;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = dp[i][i];</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; dp[n][n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">19901014</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];   <span class="comment">// f[k]:  表示k次项的系数 </span></span><br><span class="line"><span class="type">int</span> a[N], b[N]; <span class="comment">// 在多项式乘法的时候每次都是两个括号进行多项式乘法，a[i]：表示次数为i的系数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Poly</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N - i; j += k)</span><br><span class="line">            f[i + j] += (ll)(a[i] * b[j]) % mod;    <span class="comment">// 可能在乘法这里overflow所以先强制类型转化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>, a[<span class="number">1</span>] = <span class="number">1</span>;     <span class="comment">// 第一个括号(1 + x)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span> b);</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">1</span>, b[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">Poly</span>(i);</span><br><span class="line">        <span class="built_in">memcpy</span>(a,f,<span class="keyword">sizeof</span> f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UESTC</category>
        <category>数论</category>
        <category>生成函数</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA - 11795 Mega Man&#39;s Mission</title>
    <url>/2022/08/05/UVA-11795-Mega-Man-s-Mission/</url>
    <content><![CDATA[<h2 id="UVA-11795-Mega-Man’s-Mission"><a href="#UVA-11795-Mega-Man’s-Mission" class="headerlink" title="UVA - 11795 Mega Man’s Mission"></a><a href="https://vjudge.net/problem/UVA-11795">UVA - 11795 Mega Man’s Mission</a></h2><p>Mega Man is off to save the world again. His objective is to kill the Robots created by Dr. Wily whose motive is to<br>conquer the world. In each mission, he will try to destroy a particular Robot. Initially, Mega Man is equipped with a weapon, called the “Mega Buster” which can be used to destroy the Robots. Unfortunately, it may happen that his weapon is not capable of taking down every Robot. However,to his fortune, he is capable of using the weapons from Robots which he has completely destroyed and these weapons maybe able to take down Robots which he otherwise cannot with his own weapon. Note that, each of these enemy Robots carry exactly one weapon themselves for fighting Mega Man. He is able to take down the Robots in any order as long as he has at least one weapon capable of destroying the Robot at a particular mission. In this problem, given the information about the Robots and their weapons, you will have to determine the number of ways Mega Man can complete his objective of destroying all the Robots.</p>
<p><strong>Input</strong><br>Input starts with an integer T (T ≤ 50), the number of test cases.<br>Each test case starts with an integer N (1 ≤ N ≤ 16). Here N denotes the number of Robots to be<br>destroyed (each Robot is numbered from 1 to N). This line is followed by N + 1 lines, each containing<br>N characters. Each character will either be ‘1’ or ‘0’. These lines represent a (N + 1) × N matrix. The<br>rows are numbered from 0 to N while the columns are numbered from 1 to N. Row 0 represents the<br>information about the “Mega Buster”. The j-th character of Row 0 will be ‘1’ if the “Mega Buster”<br>can destroy the j-th Robot. For the remaining N rows, the j-th character of i-th row will be ‘1’ if<br>the weapon of i-th Robot can destroy the j-th Robot. Note that, a Robot’s weapon could be used to<br>destroy the Robot itself, but this will have no impact as the Robot must be destroyed anyway for its<br>weapon to be acquired.</p>
<p><strong>Output</strong><br>For each case of input, there will be one line of output. It will first contain the case number followed<br>by the number of ways Mega Man can complete his objective. Look at the sample output for exact<br>format.</p>
<p>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">11</span><br><span class="line">01</span><br><span class="line">10</span><br><span class="line">3</span><br><span class="line">110</span><br><span class="line">011</span><br><span class="line">100</span><br><span class="line">000</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Case 1: 1</span><br><span class="line">Case 2: 2</span><br><span class="line">Case 3: 3</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目要我们求杀光所有机器人的总方案数<br>我们有一个初始武器可以kill某几个机器人，然后用我们杀死的机器武器再kill别的机器人。</p>
<p>机器人的数目很少，所以可以考虑用二进制形式的状态压缩来枚举所有的状态</p>
<p>正常的状态压缩步骤</p>
<ol>
<li>预处理所有的合法状态</li>
<li>预处理我们的当前的状态可以从什么状态转移过来</li>
<li>dp</li>
</ol>
<p><strong>本题的预处理技巧值得关注</strong></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1</span> &lt;&lt; N]; <span class="comment">// dp[i]表示当前i状态下的所有方案</span></span><br><span class="line"><span class="type">int</span> head[<span class="number">1</span> &lt;&lt; N];   <span class="comment">// 预处理当前方案可以杀掉的机器人</span></span><br><span class="line"><span class="type">int</span> kill[<span class="number">1</span> &lt;&lt; N];    <span class="comment">// kill[i]表示的i号机器人可以kill的机器人</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="type">int</span> step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init()</span></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span> head);</span><br><span class="line">        <span class="built_in">memset</span>(kill,<span class="number">0</span>,<span class="keyword">sizeof</span> kill);</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="comment">// 预处理每一个机器人能kill的其他机器人</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            string s;</span><br><span class="line">            cin &gt;&gt; s;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    kill[i] |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理每一种状态下能kill的机器人</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> st = <span class="number">0</span>; st &lt; (<span class="number">1</span> &lt;&lt; n); st ++)</span><br><span class="line">        &#123;</span><br><span class="line">            head[st] = kill[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 从a0～an-1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 当前状态下这一位是1的话，1这个位置对应的机器人能kill的加到st能kill的里面</span></span><br><span class="line">                <span class="keyword">if</span>(st &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">                &#123;</span><br><span class="line">                    head[st] |= kill[i + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>]= <span class="number">1</span>;  <span class="comment">// 所有的机器人都不被杀掉只有一种方案什么都不选</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> st = <span class="number">1</span>; st &lt; (<span class="number">1</span> &lt;&lt; n); st ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从当前状态移除一个1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n<span class="number">-1</span>; i ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(st &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 移去一个1并判断边界</span></span><br><span class="line">                    <span class="comment">// 判断上一个状态是否可以转移过来当前状态(也就是判断上一个状态是否可以kill我们一去的机器人)</span></span><br><span class="line">                    <span class="keyword">if</span>(head[st^(<span class="number">1</span> &lt;&lt; i)] &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">                        dp[st] += dp[st^(<span class="number">1</span> &lt;&lt; i)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %lld\n&quot;</span>,step ++, dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVA</category>
        <category>动态规划</category>
        <category>状态压缩</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>ac自动机</title>
    <url>/2022/08/08/ac%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<p>本文章来自<a href="https://oi-wiki.org/string/ac-automaton/">OI WIKI</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>AC 自动机是 <strong>以 Trie 的结构为基础</strong>，结合 <strong>KMP 的思想</strong> 建立的。</p>
<p>简单来说，建立一个 AC 自动机有两个步骤：</p>
<ol>
<li>基础的 Trie 结构：将所有的模式串构成一棵 Trie。</li>
<li>KMP 的思想：对 Trie 树上所有的结点构造失配指针。</li>
</ol>
<p>然后就可以利用它进行多模式匹配了。</p>
<h2 id="字典树构建"><a href="#字典树构建" class="headerlink" title="字典树构建"></a>字典树构建</h2><p>AC 自动机在初始时会将若干个模式串丢到一个 Trie 里，然后在 Trie 上建立 AC 自动机。这个 Trie 就是普通的 Trie，该怎么建怎么建。</p>
<p>这里需要仔细解释一下 Trie 的结点的含义，尽管这很小儿科，但在之后的理解中极其重要。Trie 中的结点表示的是某个模式串的前缀。我们在后文也将其称作状态。一个结点表示一个状态，Trie 的边就是状态的转移。</p>
<p>形式化地说，对于若干个模式串 $s_1,s_2\dots s_n$，将它们构建一棵字典树后的所有状态的集合记作 $Q$。</p>
<h2 id="失配指针"><a href="#失配指针" class="headerlink" title="失配指针"></a>失配指针</h2><p>AC 自动机利用一个 fail 指针来辅助多模式串的匹配。</p>
<p>状态 $u$ 的 fail 指针指向另一个状态 $v$，其中 $v\in Q$，且 $v$ 是 $u$ 的最长后缀（即在若干个后缀状态中取最长的一个作为 fail 指针）。对于学过 KMP 的朋友，我在这里简单对比一下这里的 fail 指针与 KMP 中的 next 指针：</p>
<ol>
<li>共同点：两者同样是在失配的时候用于跳转的指针。</li>
<li>不同点：next 指针求的是最长 Border（即最长的相同前后缀），而 fail 指针指向所有模式串的前缀中匹配当前状态的最长后缀。</li>
</ol>
<p>因为 KMP 只对一个模式串做匹配，而 AC 自动机要对多个模式串做匹配。有可能 fail 指针指向的结点对应着另一个模式串，两者前缀不同。</p>
<p>没看懂上面的对比不要急（也许我的脑回路和泥萌不一样是吧），你只需要知道，AC 自动机的失配指针指向当前状态的最长后缀状态即可。</p>
<p>AC 自动机在做匹配时，同一位上可匹配多个模式串。</p>
<h3 id="构建指针"><a href="#构建指针" class="headerlink" title="构建指针"></a>构建指针</h3><p>下面介绍构建 fail 指针的 <strong>基础思想</strong>：（强调！基础思想！基础！）</p>
<p>构建 fail 指针，可以参考 KMP 中构造 Next 指针的思想。</p>
<p>考虑字典树中当前的结点 $u$，$u$ 的父结点是 $p$，$p$ 通过字符 <code>c</code> 的边指向 $u$，即 $trie[p,c]=u$。假设深度小于 $u$ 的所有结点的 fail 指针都已求得。</p>
<ol>
<li>如果 $\text{trie}[\text{fail}[p],c]$ 存在：则让 u 的 fail 指针指向 $\text{trie}[\text{fail}[p],c]$。相当于在 $p$ 和 $\text{fail}[p]$ 后面加一个字符 <code>c</code>，分别对应 $u$ 和 $fail[u]$。</li>
<li>如果 $\text{trie}[\text{fail}[p],c]$ 不存在：那么我们继续找到 $\text{trie}[\text{fail}[\text{fail}[p]],c]$。重复 1 的判断过程，一直跳 fail 指针直到根结点。</li>
<li>如果真的没有，就让 fail 指针指向根结点。</li>
</ol>
<p>如此即完成了 $\text{fail}[u]$ 的构建。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面放一张 GIF 帮助大家理解。对字符串 <code>i</code>  <code>he</code>  <code>his</code>  <code>she</code>  <code>hers</code> 组成的字典树构建 fail 指针：</p>
<ol>
<li>黄色结点：当前的结点 $u$。</li>
<li>绿色结点：表示已经 BFS 遍历完毕的结点，</li>
<li>橙色的边：fail 指针。</li>
<li>红色的边：当前求出的 fail 指针。</li>
</ol>
<p><img src="https://oi-wiki.org/string/images/ac-automaton1.gif" alt="AC_automation_gif_b_3.gif"></p>
<p>我们重点分析结点 6 的 fail 指针构建：</p>
<p><img src="https://oi-wiki.org/string/images/ac-automaton1.png" alt="AC_automation_6_9.png"></p>
<p>找到 6 的父结点 5，$\text{fail}[5]=10$。然而 10 结点没有字母 <code>s</code> 连出的边；继续跳到 10 的 fail 指针，$\text{fail}[10]=0$。发现 0 结点有字母 <code>s</code> 连出的边，指向 7 结点；所以 $\text{fail}[6]=7$。最后放一张建出来的图</p>
<p><img src="https://oi-wiki.org/string/images/ac-automaton4.png" alt="finish"></p>
<h2 id="字典树与字典图"><a href="#字典树与字典图" class="headerlink" title="字典树与字典图"></a>字典树与字典图</h2><p>我们直接上代码吧。字典树插入的代码就不分析了（后面完整代码里有），先来看构建函数 <code>build()</code>，该函数的目标有两个，一个是构建 fail 指针，一个是构建自动机。参数如下：</p>
<ol>
<li><code>tr[u,c]</code>：有两种理解方式。我们可以简单理解为字典树上的一条边，即 $\text{trie}[u,c]$；也可以理解为从状态（结点）$u$ 后加一个字符 <code>c</code> 到达的状态（结点），即一个状态转移函数 $\text{trans}(u,c)$。下文中我们将用第二种理解方式继续讲解。</li>
<li>队列 <code>q</code>：用于 BFS 遍历字典树。</li>
<li><code>fail[u]</code>：结点 $u$ 的 fail 指针。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">    <span class="keyword">if</span> (tr[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tr[u][i])</span><br><span class="line">        fail[tr[u][i]] = tr[fail[u]][i], q.<span class="built_in">push</span>(tr[u][i]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        tr[u][i] = tr[fail[u]][i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下上面的代码：build 函数将结点按 BFS 顺序入队，依次求 fail 指针。这里的字典树根结点为 0，我们将根结点的子结点一一入队。若将根结点入队，则在第一次 BFS 的时候，会将根结点儿子的 fail 指针标记为本身。因此我们将根结点的儿子一一入队，而不是将根结点入队。</p>
<p>然后开始 BFS：每次取出队首的结点 u（$\text{fail}[u]$ 在之前的 BFS 过程中已求得），然后遍历字符集（这里是 0-25，对应 a-z，即 $u$ 的各个子节点）：</p>
<ol>
<li>如果 $\text{trans}[u][i]$ 存在，我们就将 $\text{trans}[u][i]$ 的 fail 指针赋值为 $\text{trans}[\text{fail}[u]][i]$。这里似乎有一个问题。根据之前的讲解，我们应该用 while 循环，不停的跳 fail 指针，判断是否存在字符 <code>i</code> 对应的结点，然后赋值，但是这里通过特殊处理简化了这些代码。</li>
<li>否则，令 $\text{trans}[u][i]$ 指向 $\text{trans}[\text{fail}[u]][i]$ 的状态。</li>
</ol>
<p>这里的处理是，通过 <code>else</code> 语句的代码修改字典树的结构。没错，它将不存在的字典树的状态链接到了失配指针的对应状态。在原字典树中，每一个结点代表一个字符串 $S$，是某个模式串的前缀。而在修改字典树结构后，尽管增加了许多转移关系，但结点（状态）所代表的字符串是不变的。</p>
<p>而 $\text{trans}[S][c]$ 相当于是在 $S$ 后添加一个字符 <code>c</code> 变成另一个状态 $S’$。如果 $S’$ 存在，说明存在一个模式串的前缀是 $S’$，否则我们让 $\text{trans}[S][c]$ 指向 $\text{trans}[\text{fail}[S]][c]$。由于 $\text{fail}[S]$ 对应的字符串是 $S$ 的后缀，因此 $\text{trans}[\text{fail}[S]][c]$ 对应的字符串也是 $S’$ 的后缀。</p>
<p>换言之在 Trie 上跳转的时侯，我们只会从 $S$ 跳转到 $S’$，相当于匹配了一个 $S’$；但在 AC 自动机上跳转的时侯，我们会从 $S$ 跳转到 $S’$ 的后缀，也就是说我们匹配一个字符 <code>c</code>，然后舍弃 $S$ 的部分前缀。舍弃前缀显然是能匹配的。那么 fail 指针呢？它也是在舍弃前缀啊！试想一下，如果文本串能匹配 $S$，显然它也能匹配 $S$ 的后缀。所谓的 fail 指针其实就是 $S$ 的一个后缀集合。</p>
<p><code>tr</code> 数组还有另一种比较简单的理解方式：如果在位置 $u$ 失配，我们会跳转到 $\text{fail}[u]$ 的位置。所以我们可能沿着 fail 数组跳转多次才能来到下一个能匹配的位置。所以我们可以用 <code>tr</code> 数组直接记录记录下一个能匹配的位置，这样就能节省下很多时间。</p>
<p>这样修改字典树的结构，使得匹配转移更加完善。同时它将 fail 指针跳转的路径做了压缩（就像并查集的路径压缩），使得本来需要跳很多次 fail 指针变成跳一次。</p>
<p>好的，我知道大家都受不了长篇叙述。上图！我们将之前的 GIF 图改一下：</p>
<p><img src="https://oi-wiki.org/string/images/ac-automaton2.gif" alt="AC_automation_gif_b_pro3.gif"></p>
<ol>
<li>蓝色结点：BFS 遍历到的结点 u</li>
<li>蓝色的边：当前结点下，AC 自动机修改字典树结构连出的边。</li>
<li>黑色的边：AC 自动机修改字典树结构连出的边。</li>
<li>红色的边：当前结点求出的 fail 指针</li>
<li>黄色的边：fail 指针</li>
<li>灰色的边：字典树的边</li>
</ol>
<p>可以发现，众多交错的黑色边将字典树变成了 <strong>字典图</strong>。图中省略了连向根结点的黑边（否则会更乱）。我们重点分析一下结点 5 遍历时的情况。我们求 $\text{trans}[5][s]=6$ 的 fail 指针：</p>
<p><img src="https://oi-wiki.org/string/images/ac-automaton2.png" alt="AC_automation_b_7.png"></p>
<p>本来的策略是找 fail 指针，于是我们跳到 $\text{fail}[5]=10$ 发现没有 <code>s</code> 连出的字典树的边，于是跳到 $\text{fail}[10]=0$，发现有 $\text{trie}[0][s]=7$，于是 $\text{fail}[6]=7$；但是有了黑边、蓝边，我们跳到 $\text{fail}[5]=10$ 之后直接走 $\text{trans}[10][s]=7$ 就走到 $7$ 号结点了。</p>
<p>这就是 build 完成的两件事：构建 fail 指针和建立字典图。这个字典图也会在查询的时候起到关键作用。</p>
<h2 id="多模式匹配"><a href="#多模式匹配" class="headerlink" title="多模式匹配"></a>多模式匹配</h2><p>接下来分析匹配函数 <code>query()</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ Version</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *t)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> u = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; t[i]; i++) &#123;</span><br><span class="line">    u = tr[u][t[i] - <span class="string">&#x27;a&#x27;</span>];  <span class="comment">// 转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = u; j &amp;&amp; e[j] != <span class="number">-1</span>; j = fail[j]) &#123;</span><br><span class="line">      res += e[j], e[j] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 $u$ 作为字典树上当前匹配到的结点，<code>res</code> 即返回的答案。循环遍历匹配串，$u$ 在字典树上跟踪当前字符。利用 fail 指针找出所有匹配的模式串，累加到答案中。然后清零。在上文中我们分析过，字典树的结构其实就是一个 trans 函数，而构建好这个函数后，在匹配字符串的过程中，我们会舍弃部分前缀达到最低限度的匹配。fail 指针则指向了更多的匹配状态。最后上一份图。对于刚才的自动机：</p>
<p><img src="https://oi-wiki.org/string/images/ac-automaton3.png" alt="AC_automation_b_13.png"></p>
<p>我们从根结点开始尝试匹配 <code>ushersheishis</code>，那么 $p$ 的变化将是：</p>
<p><img src="https://oi-wiki.org/string/images/ac-automaton3.gif" alt="AC_automation_gif_c.gif"></p>
<ol>
<li>红色结点：$p$ 结点</li>
<li>粉色箭头：$p$ 在自动机上的跳转，</li>
<li>蓝色的边：成功匹配的模式串</li>
<li>蓝色结点：示跳 fail 指针时的结点（状态）。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望大家看懂了文章。</p>
<p>时间复杂度：定义 $|s_i|$ 是模板串的长度，$|S|$ 是文本串的长度，$|\Sigma|$ 是字符集的大小（常数，一般为 26）。如果连了 trie 图，时间复杂度就是 $O(\sum|s_i|+n|\Sigma|+|S|)$，其中 $n$ 是 AC 自动机中结点的数目，并且最大可以达到 $O(\sum|s_i|)$。如果不连 trie 图，并且在构建 fail 指针的时候避免遍历到空儿子，时间复杂度就是 $O(\sum|s_i|+|S|)$。</p>
<h3 id="例题-HDU-2222-Keywords-Search"><a href="#例题-HDU-2222-Keywords-Search" class="headerlink" title="例题 HDU - 2222 Keywords Search"></a>例题 <a href="https://vjudge.net/problem/HDU-2222">HDU - 2222 Keywords Search</a></h3><p>给定 n 个长度不超过 50 的由小写英文字母组成的单词准备查询，以及一篇长为 m 的文章，问：文中出现了多少种待查询的单词。多组数据。</p>
<p>输入格式<br>第一行一个整数 T，表示数据组数；</p>
<p>对于每组数据，第一行一个整数 n，接下去 n 行表示 n 个单词，最后一行输入一个字符串，表示文章。</p>
<p>输出格式<br>对于每组数据，输出一个数，表示文中出现了多少个待查询的单词。</p>
<p>输入样例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">she</span><br><span class="line">he</span><br><span class="line">say</span><br><span class="line">shr</span><br><span class="line">her</span><br><span class="line">yasherhs</span><br></pre></td></tr></table></figure><br>输出样例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, S = <span class="number">55</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tr[N * S][<span class="number">26</span>], cnt[N * S], idx;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> str[M];</span><br><span class="line"><span class="type">int</span> q[N * S], fail[N * S];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立一颗trie树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;  <span class="comment">// 从根节点开始找其是否有前缀的相同的字符串放一块（压缩空间）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++)    <span class="comment">// 字符串最后一位是&#x27;\0&#x27;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!tr[p][t])</span><br><span class="line">            tr[p][t] = ++ idx;  <span class="comment">// 如果当前节点下没有这个字符的话在这个位置给当前位置字符赋上一个编号</span></span><br><span class="line">        p = tr[p][t];</span><br><span class="line">    &#125;   </span><br><span class="line">    cnt[p] ++;  <span class="comment">// 在没有字符串结尾的地方都记录上这个位置上有多少个字符串（属性值）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化fail数组和自动机</span></span><br><span class="line"><span class="comment">// next数组是找最大后缀和前缀相同，最少可以移动的步数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// next数组的遍历是通过的上一层next数组来对本层next数组进行更新的(所以用到bfs)</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 先把第一层的字符</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)    <span class="comment">// 26个英文字母</span></span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>][i])</span><br><span class="line">            q[++ tt] = tr[<span class="number">0</span>][i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> p = tr[t][i];</span><br><span class="line">            <span class="comment">// 朴素的操作是 if(!p) continue;</span></span><br><span class="line">            <span class="comment">// 优化成trie图</span></span><br><span class="line">            <span class="comment">// 如果当前有节点的话那么就要通过其父节点的失配指针指向的节点是否有一条边含义的i，如果没有就继续往上找(直到找到根节点)</span></span><br><span class="line">            <span class="keyword">if</span>(p) </span><br><span class="line">            &#123;</span><br><span class="line">                fail[p] = tr[fail[t]][i];</span><br><span class="line">                q[++ tt] = p;</span><br><span class="line">            &#125;     </span><br><span class="line">            <span class="keyword">else</span> tr[t][i] = tr[fail[t]][i]; <span class="comment">// 这里的是将不存在的状态接到失配指针的对应状态（是为了做一步压缩状态）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line">        <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span> fail);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">            <span class="built_in">insert</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找答案 匹配过程</span></span><br><span class="line">        <span class="comment">// 多模式串匹配过程</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; str[i]; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = str[i] - <span class="string">&#x27;a&#x27;</span>;   <span class="comment">// 当前遍历的字符</span></span><br><span class="line">            j = tr[j][t];   <span class="comment">// 表示的状态</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> p = j;</span><br><span class="line">            <span class="keyword">while</span>(p)</span><br><span class="line">            &#123;</span><br><span class="line">                res += cnt[p];  <span class="comment">// 如果当前这个状态如果是有字符串的，那么答案的加上</span></span><br><span class="line">                cnt[p] = <span class="number">0</span>; <span class="comment">// 避免过多累计贡献</span></span><br><span class="line">                <span class="comment">// 原串匹配到字符i的时候，最深到达的节点，所以当匹配到当前节点的时候，其节点的前缀节点也一定会匹配所以还要加上fail的分枝的答案</span></span><br><span class="line">                p = fail[p];  <span class="comment">// 同时还需要把这点点失配分支状态下的答案加上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模版</category>
        <category>数据结构</category>
        <category>ac自动机</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2022/09/12/git/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/08/31/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>python学习笔记</title>
    <url>/2022/09/09/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-python解释器"><a href="#1-python解释器" class="headerlink" title="1.python解释器"></a>1.python解释器</h2><p>在一开始的时候没有必要直接去使用ide, 在mac上<code>/usr/bin</code>使用命令python3即可以调出pyton解释器</p>
<h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h2><h3 id="2-1-列表详解"><a href="#2-1-列表详解" class="headerlink" title="2.1 列表详解"></a>2.1 列表详解</h3><p>Python 支持多种 复合 数据类型，可将不同值组合在一起。最常用的<em>列表</em>，是用方括号标注，逗号分隔的一组值。<em>列表</em>可以包含不同类型的元素，但一般情况下，各个元素的类型相同<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line">squares</span><br></pre></td></tr></table></figure><br>和字符串一样也支持索引<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squares[<span class="number">0</span>]  <span class="comment"># indexing returns the item</span></span><br><span class="line">squares[-<span class="number">1</span>]</span><br><span class="line">squares[-<span class="number">3</span>:]  <span class="comment"># slicing returns a new list</span></span><br></pre></td></tr></table></figure></p>
<h4 id="2-1-1-函数"><a href="#2-1-1-函数" class="headerlink" title="2.1.1 函数"></a>2.1.1 函数</h4><p>append(x) 与 insert(i,x)<br> insert函数必须告诉插入到哪个位置，如果默认插在最后的话那么就退化成append()，设计逻辑上是不对的</p>
<p>remove(x) 与 pop([i])<br> remove函数是根据函数值进行索引去除<br> pop函数是根据下标（索引值）来去除数值</p>
<p>index(x[,start[,end]])<br>用法一 从头开始搜索我们指定的值<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;Runoob 索引值为&#x27;</span>, list1.index(<span class="string">&#x27;Runoob&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;Taobao 索引值为&#x27;</span>, list1.index(<span class="string">&#x27;Taobao&#x27;</span>))</span><br></pre></td></tr></table></figure><br> 输出<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runoob 索引值为 1</span><br><span class="line">Taobao 索引值为 2</span><br><span class="line"></span><br></pre></td></tr></table></figure><br> 用法二 指定位置开始搜索<br> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;Runoob 索引值为&#x27;</span>, list1.index(<span class="string">&#x27;Runoob&#x27;</span>,<span class="number">1</span>)) <span class="comment"># 从下标为1的位置开始检索</span></span><br><span class="line"><span class="comment">#  异常报错</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;Runoob 索引值为&#x27;</span>, list1.index(<span class="string">&#x27;Runoob&#x27;</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><br> 输出<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runoob 索引值为 1</span><br><span class="line">触发 ValueError 异常。</span><br></pre></td></tr></table></figure></p>
<p>sort(*,key = None, reverse = False)<br> key 表示按照什么规则 比如可以按照长度规则或是按照数值大小规则来进行排序<br> reverse：True 表示要降序，某人为False</p>
<h3 id="2-2-堆栈"><a href="#2-2-堆栈" class="headerlink" title="2.2 堆栈"></a>2.2 堆栈</h3><p>使用列表方法实现堆栈非常容易，最后插入的最先取出（“后进先出”）。把元素添加到堆栈的顶端，使用 append() 。从堆栈顶部取出元素，使用 pop() ，不用指定索引。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stack = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">stack.append(<span class="number">6</span>)</span><br><span class="line">stack.append(<span class="number">7</span>)</span><br><span class="line">stack</span><br><span class="line"></span><br><span class="line">stack.pop()</span><br><span class="line"></span><br><span class="line">stack</span><br><span class="line"></span><br><span class="line">stack.pop()</span><br><span class="line"></span><br><span class="line">stack.pop()</span><br><span class="line"></span><br><span class="line">stack</span><br></pre></td></tr></table></figure>
<h3 id="2-3-用列表实现队列"><a href="#2-3-用列表实现队列" class="headerlink" title="2.3 用列表实现队列"></a>2.3 用列表实现队列</h3><p>列表也可以用作队列，最先加入的元素，最先取出（“先进先出”）；然而，列表作为队列的效率很低。因为，在列表末尾添加和删除元素非常快，但在列表开头插入或移除元素却很慢（因为所有其他元素都必须移动一位）。</p>
<p>实现队列最好用 collections.deque，可以快速从两端添加或删除元素。例如：</p>
<p><strong>要注意的是使用deque要引入头文件使用语句  <code>from collection import deque</code></strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque   <span class="comment"># 如何直接引入collections库的话下文的queue = collections.deque()</span></span><br><span class="line">queue = deque([<span class="string">&quot;Eric&quot;</span>, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Michael&quot;</span>])</span><br><span class="line">queue.append(<span class="string">&quot;Terry&quot;</span>)           <span class="comment"># Terry arrives</span></span><br><span class="line">queue.append(<span class="string">&quot;Graham&quot;</span>)          <span class="comment"># Graham arrives</span></span><br><span class="line">queue.popleft()                 <span class="comment"># The first to arrive now leaves</span></span><br><span class="line"></span><br><span class="line">queue.popleft()                 <span class="comment"># The second to arrive now leaves</span></span><br><span class="line"></span><br><span class="line">queue                           <span class="comment"># Remaining queue in order of arrival</span></span><br></pre></td></tr></table></figure></p>
<p><strong>但是我们可以从引入的这个库<code>deque</code>的名字我们可以知道这是一个双端队列，不仅仅是可以使用队列的<em>队头出队队尾入队</em>操作，还可以在两端都可以走进队出队操作，这里经常会在双端队列bfs算法中会使用</strong></p>
<h4 id="2-3-1-函数"><a href="#2-3-1-函数" class="headerlink" title="2.3.1 函数"></a>2.3.1 函数</h4><ul>
<li>queue.append() 表示队尾入队操作</li>
<li>queue.appendleft() 表示队头入队操作</li>
<li>queue.popleft() 表示队头元素弹出</li>
<li>queue.pop() 表示队尾元素弹出</li>
</ul>
<h2 id="3-其他流程控制工具"><a href="#3-其他流程控制工具" class="headerlink" title="3. 其他流程控制工具"></a>3. 其他流程控制工具</h2><h3 id="3-1-if-语句"><a href="#3-1-if-语句" class="headerlink" title="3.1 if 语句"></a>3.1 if 语句</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Please enter an integer: &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Negative changed to zero&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Zero&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> x == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Single&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;More&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-2-for语句"><a href="#3-2-for语句" class="headerlink" title="3.2 for语句"></a>3.2 for语句</h3><p><strong>python的for语句并不需要迭代值和c++中的auto迭代数组非常像</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : arr)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Measure some strings:</span></span><br><span class="line">words = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;window&#x27;</span>, <span class="string">&#x27;defenestrate&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">    <span class="built_in">print</span>(w, <span class="built_in">len</span>(w))</span><br></pre></td></tr></table></figure></p>
<p><strong>遍历集合时修改集合的内容，会很容易生成错误的结果。因此不能直接进行循环，而是应遍历该集合的副本或创建新的集合：</strong><br>创建副本-&gt;修改副本-&gt;将修改的副本复制会原文件当中<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create a sample collection</span></span><br><span class="line">users = &#123;<span class="string">&#x27;Hans&#x27;</span>: <span class="string">&#x27;active&#x27;</span>, <span class="string">&#x27;Éléonore&#x27;</span>: <span class="string">&#x27;inactive&#x27;</span>, <span class="string">&#x27;景太郎&#x27;</span>: <span class="string">&#x27;active&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Strategy:  Iterate over a copy</span></span><br><span class="line"><span class="keyword">for</span> user, status <span class="keyword">in</span> users.copy().items():</span><br><span class="line">    <span class="keyword">if</span> status == <span class="string">&#x27;inactive&#x27;</span>:</span><br><span class="line">        <span class="keyword">del</span> users[user]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Strategy:  Create a new collection</span></span><br><span class="line">active_users = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> user, status <span class="keyword">in</span> users.items():</span><br><span class="line">    <span class="keyword">if</span> status == <span class="string">&#x27;active&#x27;</span>:</span><br><span class="line">        active_users[user] = status</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3-range-函数"><a href="#3-3-range-函数" class="headerlink" title="3.3 range()函数"></a>3.3 range()函数</h3><p><strong>可以使用range函数来实现迭代的次数</strong><br>内置函数 range() 常用于遍历数字序列，该函数可以生成算术级数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><br>还有一些其他的奇奇怪怪的用法<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(-<span class="number">10</span>, -<span class="number">100</span>, -<span class="number">30</span>))</span><br><span class="line">[-<span class="number">10</span>, -<span class="number">40</span>, -<span class="number">70</span>]</span><br></pre></td></tr></table></figure><br>range() 和 len() 组合在一起，可以按索引迭代序列：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;had&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;little&#x27;</span>, <span class="string">&#x27;lamb&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i, a[i])</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> Mary</span><br><span class="line"><span class="number">1</span> had</span><br><span class="line"><span class="number">2</span> a</span><br><span class="line"><span class="number">3</span> little</span><br><span class="line"><span class="number">4</span> lamb</span><br></pre></td></tr></table></figure><br>range() 和 len() 组合在一起，可以按索引迭代序列：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><br>range() 和 sum()组成在一起<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; sum(range(4))  # 0 + 1 + 2 + 3</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>
<h3 id="3-4-循环中的-break、continue-语句及-else-子句"><a href="#3-4-循环中的-break、continue-语句及-else-子句" class="headerlink" title="3.4. 循环中的 break、continue 语句及 else 子句"></a>3.4. 循环中的 break、continue 语句及 else 子句</h3><p><code>break</code>,<code>continue</code>语句基本与c/c++中的语法无差。重要讲一下区别<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="built_in">print</span>(n, <span class="string">&#x27;equals&#x27;</span>, x, <span class="string">&#x27;*&#x27;</span>, n//x)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># loop fell through without finding a factor</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(n, <span class="string">&#x27;is a prime number&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">3</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">4</span> equals <span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">6</span> equals <span class="number">2</span> * <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">8</span> equals <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="number">9</span> equals <span class="number">3</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure><br><strong>看上面这个语句else子句并不属于if语句当中的而是属于第二个内循环当中的。</strong></p>
<p>循环语句支持<code>else</code>子句；<code>for</code>循环中，可迭代对象中的元素全部循环完毕，或<code>while</code>循环的条件为假时，执行该子句；<code>break</code> 语句终止循环时，不执行该子句。 `</p>
<p>与 if 语句相比，循环的 else 子句更像 try 的 else 子句： try 的 else 子句在未触发异常时执行，循环的 else 子句则在未运行 break 时执行。try 语句和异常详见 异常的处理。</p>
<h3 id="3-5-pass-语句"><a href="#3-5-pass-语句" class="headerlink" title="3.5 pass 语句"></a>3.5 pass 语句</h3><p>pass语句仅表示意思是占位符的<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span>  <span class="comment"># Busy-wait for keyboard interrupt (Ctrl+C)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><br>等同于<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-6-match语句"><a href="#3-6-match语句" class="headerlink" title="3.6 match语句"></a>3.6 match语句</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">http_error</span>(<span class="params">status</span>):</span><br><span class="line">    match status:</span><br><span class="line">        case <span class="number">400</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Bad request&quot;</span></span><br><span class="line">        case <span class="number">404</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Not found&quot;</span></span><br><span class="line">        case <span class="number">418</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a teapot&quot;</span></span><br><span class="line">        case _:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Something&#x27;s wrong with the internet&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>def 表示的是用户自定义函数</li>
<li>最后一个代码块：“变量名” _ 被作为<code>通配符</code>并必定会匹配成功。 如果没有<code>case</code>语句匹配成功，则不会执行任何分支。</li>
</ul>
<p>使用 | （“ or ”）在一个模式中可以组合多个字面值：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">case <span class="number">401</span> | <span class="number">403</span> | <span class="number">404</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Not allowed&quot;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-7-定义函数"><a href="#3-7-定义函数" class="headerlink" title="3.7 定义函数"></a>3.7 定义函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):    <span class="comment"># write Fibonacci series up to n</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;&quot;&quot;Print a Fibonacci series up to n.&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">... </span>    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> a &lt; n:</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(a, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="meta">... </span>        a, b = b, a+b</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Now call the function we just defined:</span></span><br><span class="line"><span class="meta">... </span>fib(<span class="number">2000</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span> <span class="number">1597</span></span><br></pre></td></tr></table></figure>
<p>定义 函数使用关键字 def，后跟函数名与括号内的形参列表。函数语句从下一行开始，<strong>并且必须缩进</strong>。<br>在c/c++当中空格所能有意义的用法非常稀少，但是python不用，应为没有中括号这类的符号标识，所以需要使用缩进表示的函数体</p>
<p>函数内的第一条语句是字符串时，该字符串就是文档字符串，也称为 docstring。<strong>利用文档字符串可以自动生成在线文档或打印版文档，还可以让开发者在浏览代码时直接查阅文档</strong>；Python 开发者最好养成在代码中加入文档字符串的好习惯。</p>
<p>函数在 执行 时使用函数局部变量符号表，所有函数变量赋值都存在局部符号表中；引用变量时，首先，在局部符号表里查找变量，然后，是外层函数局部符号表，再是全局符号表，最后是内置名称符号表。因此，尽管可以引用全局变量和外层函数的变量，但最好不要在函数内直接赋值（除非是 global 语句定义的全局变量，或 nonlocal 语句定义的外层函数变量）</p>
<p>在调用函数时会将实际参数（实参）引入到被调用函数的局部符号表中；因此，实参是使用 按值调用 来传递的（其中的 值 始终是对象的 引用 而不是对象的值）。 1 当一个函数调用另外一个函数时，会为该调用创建一个新的局部符号表。</p>
<p>函数定义在当前符号表中把函数名与函数对象关联在一起。解释器把函数名指向的对象作为用户自定义函数。还可以使用其他名称指向同一个函数对象，并访问访该函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib</span><br><span class="line">&lt;function fib at 10042ed0&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = fib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">100</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span></span><br></pre></td></tr></table></figure><br>函数返回值<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">fib2</span>(<span class="params">n</span>):  <span class="comment"># return Fibonacci series up to n</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;&quot;&quot;Return a list containing the Fibonacci series up to n.&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">... </span>    result = []</span><br><span class="line"><span class="meta">... </span>    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> a &lt; n:</span><br><span class="line"><span class="meta">... </span>        result.append(a)    <span class="comment"># see below</span></span><br><span class="line"><span class="meta">... </span>        a, b = b, a+b</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> result</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f100 = fib2(<span class="number">100</span>)    <span class="comment"># call it</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f100                <span class="comment"># write the result</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</span><br></pre></td></tr></table></figure></p>
<p>默认值在<em>定义</em>作用域里的函数定义中求值，所以<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">arg=i</span>):</span><br><span class="line">    <span class="built_in">print</span>(arg)</span><br><span class="line"></span><br><span class="line">i = <span class="number">6</span></span><br><span class="line">f()</span><br></pre></td></tr></table></figure><br>上例输出的是<code>5</code>。<br><strong>重要警告</strong>： 默认值只计算一次。默认值为列表、字典或类实例等可变对象时，会产生与该规则不同的结果。例如，下面的函数会累积后续调用时传递的参数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, L=[]</span>):</span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><br>输出结果如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><br>不想在后续调用之间共享默认值时，应以如下方式编写函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, L=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure></p>
<h2 id="4-copy-浅层和深层复制操作"><a href="#4-copy-浅层和深层复制操作" class="headerlink" title="4.copy 浅层和深层复制操作"></a>4.copy 浅层和深层复制操作</h2><p>Python 的赋值语句不复制对象，而是创建目标和对象的绑定关系。对于自身可变，或包含可变项的集合，有时要生成副本用于改变操作，而不必改变原始对象。本模块提供了通用的浅层复制和深层复制操作，（如下所述）。<br>接口摘要：<br>copy.copy(x)<br>返回 x 的浅层复制。<br>copy.deepcopy(x[, memo])<br>返回 x 的深层复制。<br>exception copy.Error<br>针对模块特定错误引发。</p>
<p>上面也就是说明了list实际上表示的一个引用的关系，比如<code>alist = [1]</code>,那么<code>alist</code>本质上等于一个指针指向存储数据1的内存， <code>alist = blist</code>这个赋值关系，实际上就是等同于两个指针都指向同一片内存，如果任意修改一个<code>alist</code> / <code>blist</code> 这时候相当于这一个内存的内容发生变化，只要修改了一个两个list都会同时发生错误。这就是浅拷贝，浅拷贝就是内容之间存在依赖关系，具有相互影响的关系，在c语言的严重极端的情况下，如果要删除一个内存空间，另外一个指针本来只想的地方就消失，很容易造成sf问题（段错误问题），指针指向了一片不明空间，这样是十分危险的。</p>
]]></content>
      <categories>
        <category>python</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路问题</title>
    <url>/2022/07/18/%E5%9B%BE%E8%AE%BA%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><h3 id="Bellman-ford算法"><a href="#Bellman-ford算法" class="headerlink" title="Bellman_ford算法"></a>Bellman_ford算法</h3><p>每次对所有边进行松弛操作，并迭代n次最后得到的就是单源最短路。<br>主要用于</p>
<ol>
<li>求含有负环的最短路</li>
<li>求有边数限制的最短路<br><em>因为有了spfa对bellman的优化，所以一般情况下不是求边数限制的话，不会用到bellman算法</em></li>
</ol>
<p>步骤：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 迭代n次（一个图中不含有环的最短路最长边数位n-1条边）  </span><br><span class="line">     for 对每一条边（m条）进行松弛</span><br></pre></td></tr></table></figure></p>
<p>因为内层对每一条边进行松弛，所以可能到不了的边最后也会被更新为非INF，所以在判断是否有最短路不能通过是否等于INF来判断，要通过INF/2来判断</p>
<h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><p>例题 <a href="https://www.acwing.com/problem/content/description/855/">AcWing853. 有边数限制的最短路</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).bEdgein(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,d;</span><br><span class="line">    <span class="comment">// Edge():a(),b(),d()&#123;&#125;</span></span><br><span class="line">    <span class="comment">// Edge(int a, int b, int d): a(a), b(b),d(d)&#123;&#125;</span></span><br><span class="line">&#125;Edge[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; Edge[i].a &gt;&gt; Edge[i].b &gt;&gt; Edge[i].d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="type">int</span> bak[N];</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(bak,dis,<span class="keyword">sizeof</span> dis);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = Edge[j].a, b = Edge[j].b;</span><br><span class="line">            <span class="type">int</span> d = Edge[j].d;</span><br><span class="line">            dis[b] = <span class="built_in">min</span>(dis[b],bak[a] + d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = dis[n];</span><br><span class="line">    <span class="keyword">if</span>(res &gt; INF / <span class="number">2</span>) cout&lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h3><p>对<code>bellman</code>的优化，因为<code>bellman</code>每次都松弛每一条边，但是这种对每一条边都进行松弛是有大量重复的操作的，是没有意义的。所以<code>spfa</code>使用了队列（循环队列）来进行优化，每次将元素出队，有且只会对这个元素的邻边进行更新。</p>
<p>存储方式：使用一个类邻接表的形式，树链前向星。</p>
<h3 id="例题spfa求最短路"><a href="#例题spfa求最短路" class="headerlink" title="例题spfa求最短路"></a>例题<a href="https://www.acwing.com/problem/content/853/">spfa求最短路</a></h3><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。</p>
<p>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 impossible。</p>
<p>数据保证不存在负权回路。</p>
<p>输入格式<br>第一行包含整数 n 和 m。</p>
<p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p>
<p>输出格式<br>输出一个整数，表示 1 号点到 n 号点的最短距离。</p>
<p>如果路径不存在，则输出 impossible。</p>
<p>数据范围<br>1≤n,m≤105,<br>图中涉及边长绝对值均不超过 10000。</p>
<p>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 5</span><br><span class="line">2 3 -3</span><br><span class="line">1 3 4</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[N], w[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;   <span class="comment">// stl里面的queue本质上就是一个循环队列</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">                <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    dist[j] = dist[t] + w[i];</span><br><span class="line">                    <span class="keyword">if</span>(!st[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(j);</span><br><span class="line">                        st[j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; inf / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist[n]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>手写循环队列的spfa版块<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[S] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q[N];</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    q[hh] = S, st[S] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line">        <span class="keyword">if</span>(hh == N) hh = <span class="number">0</span>;</span><br><span class="line">        st[t] = <span class="literal">false</span>;  <span class="comment">// 这里的状态不同与dijkstra这里是表示的是否在队列当中，一个节点可能被多次更新</span></span><br><span class="line">        <span class="comment">// spfa的过程等于 要想求的i～j之间的最短路，每次更新就在i～j的路径上再加一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j] &gt; dis[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[j] = dis[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt ++] =  j;</span><br><span class="line">                    <span class="keyword">if</span>(tt == N) tt = <span class="number">0</span>;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="O（n-2-dijkstra"><a href="#O（n-2-dijkstra" class="headerlink" title="O（n^2) dijkstra"></a>O（n^2) dijkstra</h3><p>外层迭代n次，每次选取到源点的最小值，维护dist数组（要注意与最小生成树中的dist数组做区分，最小生成树的中的dist数组是维护到连通块的最小值，在最短路问题中是维护的是到源点的最小值），由于dist是每个点到别的顶点的最短距离，所以内层也是迭代n遍<br>用选出来的这个点对其他点进行更新dist（如果对更新有别的决策要写入到更新边的板块中）<br>如：双权值，dijkstra问题<a href="https://vjudge.net/problem/HDU-3790">最短路径问题</a>,在板子后面会贴出代码</p>
<h4 id="例题Dijkstra求最短路"><a href="#例题Dijkstra求最短路" class="headerlink" title="例题Dijkstra求最短路"></a>例题<a href="https://www.acwing.com/problem/content/851/">Dijkstra求最短路</a></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t]) ) t = j;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        g[a][b] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dist[n] != inf) cout &lt;&lt; dist[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双权值问题<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; <span class="built_in">assert</span>(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> cost[N][N];</span><br><span class="line"><span class="type">int</span> n, m; </span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 双关键值 最短路问题</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="built_in">memset</span>(val,<span class="number">0x3f</span>, <span class="keyword">sizeof</span> val);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"></span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    val[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t  == <span class="number">-1</span> || dist[j] &lt; dist[t]))</span><br><span class="line">                t = j;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 与单权值问题的区别</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + g[t][j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + g[t][j];</span><br><span class="line">                val[j] = val[t] + cost[t][j];<span class="comment">//即使这里比原来花费的要更大的话也要更新，因为他们是有联系的</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dist[j] == dist[t] + g[t][j] &amp;&amp; val[j] &gt; val[t] + cost[t][j])</span><br><span class="line">            &#123;</span><br><span class="line">                val[j] = val[t] + cost[t][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m), n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,d,p;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">memset</span>(cost, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> cost);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;d,&amp;p);</span><br><span class="line">            <span class="keyword">if</span>(g[a][b] &gt; d)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 花费和边长是相互挂钩的</span></span><br><span class="line">                g[a][b] = g[b][a] = d;</span><br><span class="line">                cost[a][b] = cost[b][a] = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(g[a][b] == d &amp;&amp; cost[a][b] &gt; p)</span><br><span class="line">            &#123;</span><br><span class="line">                cost[a][b] = cost[b][a] = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> s,e;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;s,&amp;e);</span><br><span class="line">        <span class="built_in">dijkstra</span>(s);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; dist[e] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val[e] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="O（mlogn）的dijkstra"><a href="#O（mlogn）的dijkstra" class="headerlink" title="O（mlogn）的dijkstra"></a>O（mlogn）的dijkstra</h3><p><strong>对于dijkstra算法和bfs算法都是一样的，每个点只会别迭代一次，迭代完了之后就不会再被更新。</strong>所以一般会在这做优化如果st[i] = true, 就直接跳过更新这个点，而spfa中的st[i]记录的是i点这个点是否在队列当中，spfa不一样的是每个点是可以被更新多次的（所以这个性质也经常被用于求负环当中）<br><strong>实际上堆优化版的dijkstra就是优先队列bfs</strong>，只不过其实现在不同类型的图，假如是给定的图是迷宫图给出了一个迷宫的形状，我们只能上下左右走，那么应该使用bfs。在一些标定图（每个点都标定好编号）使用dijkstra比较方便</p>
<h3 id="例题Dijkstra求最短路-II"><a href="#例题Dijkstra求最短路-II" class="headerlink" title="例题Dijkstra求最短路 II"></a>例题<a href="https://www.acwing.com/problem/content/852/">Dijkstra求最短路 II</a></h3><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为非负值。</p>
<p>请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。</p>
<p>输入格式<br>第一行包含整数 n 和 m。</p>
<p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p>
<p>输出格式<br>输出一个整数，表示 1 号点到 n 号点的最短距离。</p>
<p>如果路径不存在，则输出 −1。</p>
<p>数据范围<br>1≤n,m≤1.5×105,<br>图中涉及边长均不小于 0，且不超过 10000。<br>数据保证：如果最短路存在，则最短路的长度不超过 109。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 2</span><br><span class="line">2 3 1</span><br><span class="line">1 3 4</span><br></pre></td></tr></table></figure><br>输出样例<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], w[N],idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;   <span class="comment">// 表示这个点的子节点是否有更新，更新过了接下来就不需要再更新了</span></span><br><span class="line">        st[ver] = <span class="literal">true</span>; <span class="comment">// 堆优化的对状态进行判断主要的同bfs一样，每个节点的只会更新一遍，防止其重复更新才做判断（防止走回头路）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dist[ver] + w[i] &lt; dist[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dist[n] != <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; dist[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模版</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>大学数学学习路线</title>
    <url>/2022/08/10/%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h2><p>本人的学习路线为：<a href="https://www.bilibili.com/video/BV1x7411x7XQ?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;vd_source=a0d3102b058feafe6e998d9731e0f0c6">浙大 微积分</a><br>老师的讲课风格主要在于公式的推导与证明，是适合与0基础的小白上手。讲课风格也非常具有学院派的气息，同时也会结合讲一些例题方便理解。我认为这个老师讲的课不是为了写题而讲，而是为了能过深入理解而学。<br>同时，大家也都推荐的<a href="https://space.bilibili.com/688379639?spm_id_from=333.337.0.0">武忠祥老师</a>、 <a href="https://space.bilibili.com/66607740?spm_id_from=333.337.0.0">宋浩老师</a>、<a href="https://space.bilibili.com/679237565?spm_id_from=333.337.0.0">张宇</a>,这些老师都是考研学生常听的课，有些老师也是出自于高等学府的教授，可以结合网上的课程考虑是否听他们课。</p>
<h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><p><a href="https://www.bilibili.com/video/BV1bb411H7JN?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">MIT 线性代数</a><br>作为美国的高等的学府教学质量自然不用说，教授教授的课程切入角度往往都非常神奇，是一门越看越想看，越看越兴奋的课程。同时网上也有很多的人也看过，同时也有相关方面的资料。但是一旦上这一门课，很有可能进度就与学校线下的课程进度不同，一定要耐住心好好走自己的节奏，学到东西才是根本目的！同时本课程也有可能涉及到没有课本的方面，但是就我个人来说并没有太大理想，当时上网课基本上都是上完课基本所有问题都能解决，很棒的课程。我也有不少的MIT这们课程的资料，日后我会给出，或者向我私信索取。</p>
<p>同理数学类的科目都适用与上面的考研高数老师</p>
]]></content>
  </entry>
  <entry>
    <title>差分约束</title>
    <url>/2022/07/19/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><h3 id="应用一：求解不等式组的可行解（只能求解出来一个组）"><a href="#应用一：求解不等式组的可行解（只能求解出来一个组）" class="headerlink" title="应用一：求解不等式组的可行解（只能求解出来一个组）"></a>应用一：求解不等式组的可行解（只能求解出来一个组）</h3><p>不等式组的的表示形式一般也有两种<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只有相对值的性质</span><br><span class="line">x1 &lt;= x2 + c1</span><br><span class="line">x2 &lt;= x3 + c2</span><br><span class="line">x3 &lt;= x1 + c3</span><br><span class="line">（只含有相对值，是不能可以有最大最小值的，因为没有定值约束）</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">含有一个绝对参数</span><br><span class="line">x1 &lt;= x2 + c1</span><br><span class="line">x2 &lt;= x3 + c2</span><br><span class="line">x3 &lt;= x1 + c3</span><br><span class="line">x1 &gt;= 0(0是坐标系中的绝对地址)</span><br></pre></td></tr></table></figure><br>从不等式的形式转换成图的形式<br>dist[x1] &lt;= dist[x2] + c1<br><strong>构造： 这里从x2-&gt;x1连上一条权值为c1的边</strong><br><em>这里的dist数组维护的是点x到源点的最短距离</em><br>反证法：如果dist[x2] + c1 &lt; dist[x1]的话，那么就说明x1到源点的最短路径应该是从x2到源点的最短路径在经过c1边到x1，所以x1的最短路径是可以被更新的</p>
<p>要知道这些不等式集合是不一定是可解的，所以要求其可行解先，我们应该判断其是否有解。<br>判断是否有解？<br>结论：</p>
<ol>
<li><p><strong>x1 &lt;= x2 + c1这种形式，图中没有负环的情况下是有解的</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x1 &lt;= x2 + c1</span><br><span class="line">x2 &lt;= x3 + c2</span><br><span class="line">x3 &lt;= x1 + c3</span><br></pre></td></tr></table></figure>
<p> 证明角度一：不等式运算<br> 我们可以把上面三个不等式加起来，可以得到<code>x1 + x2 + x3 &lt;= x1 + x2 + x3 + c1 + c2 + c3</code><br> 化简可得<code>0 &lt;= c1 + c2 +c3</code> 得到<code>c1 + c2 + c3</code>大于等于0是是有解的，<code>c1 + c2 + c3</code>是路径包含了x1,x2,x3的环，也就是当图中没有负环的时候是有解的。<br> 证明角度二：放缩<br> <code>x1 &lt;= x2 + c1 &lt;= x3 + c1 + c2 &lt;= x1 + c1 + c2 + c3</code>,化简得到 <code>x1 &lt;= x1 + c1 + c2 + c3</code>,很明显仅当<code>c1 + c2 + c3 &lt;= 0</code>的时候不等式才会成立</p>
</li>
<li><p><strong>x1 &gt;= x2 + c1这种形式，图中没有正环的情况下是有解的</strong></p>
</li>
</ol>
<p>在确定完了有解的情况下，我们求解不等式的可行解<br>我们从上面我们转换成图论问题使用了dist数组，表示到源点的最短/最长距离，所以我们首先要构造出来一个源点。<br>源点需要满足的条件：从源点出发，一定是可以达到所以的<strong>边</strong>的。<br>这里是什么源点是一定达到所有的边而不是所有的点呢？？ 很显然如果不能到达这个点的话，那么说明这个点是孤立点，孤立点不受到任何的约束，所以孤立点是可以去取得任何的值</p>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>先将每个不等式 xi &lt;= xj + cj 转换成一条j-&gt;i边权为cj的边</li>
<li>构造出一个超级源点（虚拟源点），使得源点一定是可以遍历到所有的边的</li>
<li>从源点求一遍单源最短路<ol>
<li>结果1:如果有负环，则原不等式组一定无解</li>
<li>结构2:如果没有负环，则dist[i]就是原不等式组的一个可行解</li>
</ol>
</li>
</ol>
<h3 id="应用二：求解最大值-最小值（每个值的最大值和最小值）"><a href="#应用二：求解最大值-最小值（每个值的最大值和最小值）" class="headerlink" title="应用二：求解最大值/最小值（每个值的最大值和最小值）"></a>应用二：求解最大值/最小值（每个值的最大值和最小值）</h3><p>现的<br><strong>结论：如果求的是最小值话，则应该求最长路，如果求的是最大值的话，则应该求最短路</strong><br>证明：以求xi的最小值为例<br>首先我们要知道这个不等式组一定是形式二，应为只有相对位置，没有绝对坐标约束是不可能有最大最小值的。<br>我们可以通过放缩（应用一的放缩思想）构造出来一些不等式<code>xi &lt;= xj + cj &lt;= ...&lt;= 0(xi &gt;= 0) + c1 + c2 + c3..+cn</code>,这里的c1，c2..是到xi的边，因为到xi的路径有可能有很多条所以，所以要想满足所有的xi &lt;= c1 + … + cn 的不不等式，我们只能取的上确界，也就是取所有路径的最大值，就一定满足所有的不等式了。<strong>于是就将求x的最小值转换成最长路径</strong></p>
<h4 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h4><p>建立一个超级源点，0，然后建立0-&gt;i,边权为c的边(绝对参考值)<br>计算出所有的上界/下界，最终的xi的最大值（最小值）等于所有上界（下界）的最小值（最大值）</p>
<h4 id="注意-与-总结"><a href="#注意-与-总结" class="headerlink" title="注意 与 总结"></a>注意 与 总结</h4><ul>
<li>我们上面的不等式组一定是可以统一成大于等于/小于等于的形式（大于等于和小于等于都是同时存在的，因为有两个变量在不等式的两边，假如对于不等式左边的变量是大于等于，那么就对于不等式右边的变量是小于等于）</li>
<li>求最小值的时候把不等式组统一形式成 a &gt;= b + c1, 把所有的常量（可正可负）都移到不等式的右边，b向a连上一条权值为c1的边（因为求最小值，等于求最长路，dist[a] &gt;= dist[b] + c1, 反证法 b向a有一条权值为c1的边，如果b的最长路径加上一条b-&gt;a路径比原来a的最长路径要大的话，那么就需要对a的最长路径进行更新，矛盾所以我们构造边成立）</li>
<li>求最大值的时候把不等式组统一形式成 a &lt;= b + c1, <code>b</code>向<code>a</code>连上一条权值为c1的边</li>
<li>转化不等式组：a &gt; b 可以等价于 a &gt;= b + 1</li>
<li>最小值（最长路） 正环无解， 最大值（最短路） 负环无解</li>
</ul>
<h3 id="例题-AcWing-1169-糖果"><a href="#例题-AcWing-1169-糖果" class="headerlink" title="例题 AcWing 1169. 糖果"></a>例题 <a href="https://www.acwing.com/problem/content/1171/">AcWing 1169. 糖果</a></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>幼儿园里有 N 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。</p>
<p>但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候， 老师需要满足小朋友们的 K 个要求。</p>
<p>幼儿园的糖果总是有限的，老师想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。</p>
<p>输入格式<br>输入的第一行是两个整数 N,K。</p>
<p>接下来 K 行，表示分配糖果时需要满足的关系，每行 3 个数字 X,A,B。</p>
<p>如果 X=1．表示第 A 个小朋友分到的糖果必须和第 B 个小朋友分到的糖果一样多。<br>如果 X=2，表示第 A 个小朋友分到的糖果必须少于第 B 个小朋友分到的糖果。<br>如果 X=3，表示第 A 个小朋友分到的糖果必须不少于第 B 个小朋友分到的糖果。<br>如果 X=4，表示第 A 个小朋友分到的糖果必须多于第 B 个小朋友分到的糖果。<br>如果 X=5，表示第 A 个小朋友分到的糖果必须不多于第 B 个小朋友分到的糖果。<br>小朋友编号从 1 到 N。</p>
<p>输出格式<br>输出一行，表示老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出 −1。</p>
<p>数据范围<br>1≤N&lt;105,<br>1≤K≤105,<br>1≤X≤5,<br>1≤A,B≤N</p>
<p>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">1 1 2</span><br><span class="line">2 3 2</span><br><span class="line">4 4 1</span><br><span class="line">3 4 5</span><br><span class="line">5 4 5</span><br><span class="line">2 3 5</span><br><span class="line">4 5 1</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure></p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>题目要求求最小值，先化简不等式组，判断是否有正环，没有正环，求解最长路</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">powmod</span><span class="params">(ll a,ll b)</span> </span>&#123;ll res=<span class="number">1</span>;a%=mod; <span class="built_in">assert</span>(b&gt;=<span class="number">0</span>); <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*a%mod;a=a*a%mod;&#125;<span class="keyword">return</span> res;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line">ll dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用stack判断正环</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> q[N];</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    st[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh != tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[--tt];</span><br><span class="line">        st[t] =<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &lt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q[tt ++] = j;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;a,&amp;b);</span><br><span class="line">        <span class="comment">// 因为要求的是最小值，所以我们需要找最长路径，并构造&gt;=的形式</span></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="built_in">add</span>(a,b,<span class="number">0</span>),<span class="built_in">add</span>(b,a,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">2</span>) <span class="built_in">add</span>(a,b,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">3</span>) <span class="built_in">add</span>(a,b,<span class="number">0</span>); <span class="comment">// 边权为0就无所谓方向了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">4</span>) <span class="built_in">add</span>(b,a,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">5</span>) <span class="built_in">add</span>(a,b,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造超级源点</span></span><br><span class="line">    <span class="comment">// 由于上面的不等式为相对值，没有绝对值得情况下是无法求的最值问题的</span></span><br><span class="line">    <span class="comment">// 我们由题意知所有小朋友都会得到糖果所以，每个朋友至少为一，所以构造虚拟源点时候，初始化为1就可以表示为绝对参考系</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) res += dist[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模版</category>
        <category>图论</category>
        <category>差分约束</category>
      </categories>
      <tags>
        <tag>差分约束</tag>
        <tag>笔记</tag>
        <tag>图论模版</tag>
      </tags>
  </entry>
  <entry>
    <title>数位dp</title>
    <url>/2022/08/03/%E6%95%B0%E4%BD%8Ddp/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://oi.wiki/dp/number/">引用OI.WIKI</a></p>
<p>数位：把一个数字按照个、十、百、千等等一位一位地拆开，关注它每一位上的数字。如果拆的是十进制数，那么每一位数字都是 0~9，其他进制可类比十进制。</p>
<p>数位 DP：用来解决一类特定问题，这种问题比较好辨认，一般具有这几个特征：</p>
<ol>
<li><p>要求统计满足一定条件的数的数量（即，最终目的为计数）；</p>
</li>
<li><p>这些条件经过转化后可以使用「数位」的思想去理解和判断；</p>
</li>
<li><p>输入会提供一个数字区间（有时也只提供上界）来作为统计的限制；</p>
</li>
<li><p>上界很大（比如 $10^{18}$），暴力枚举验证会超时。</p>
</li>
</ol>
<p>数位 DP 的基本原理：</p>
<p>考虑人类计数的方式，最朴素的计数就是从小到大开始依次加一。但我们发现对于位数比较多的数，这样的过程中有许多重复的部分。例如，从 7000 数到 7999、从 8000 数到 8999、和从 9000 数到 9999 的过程非常相似，它们都是后三位从 000 变到 999，不一样的地方只有千位这一位，所以我们可以把这些过程归并起来，将这些过程中产生的计数答案也都存在一个通用的数组里。此数组根据题目具体要求设置状态，用递推或 DP 的方式进行状态转移。</p>
<p>数位 DP 中通常会利用常规计数问题技巧，比如把一个区间内的答案拆成两部分相减（即 $\mathit{ans}<em>{[l, r]} = \mathit{ans}</em>{[0, r]}-\mathit{ans}_{[0, l - 1]}$</p>
<p>那么有了通用答案数组，接下来就是统计答案。统计答案可以选择记忆化搜索，也可以选择循环迭代递推。为了不重不漏地统计所有不超过上限的答案，要从高到低枚举每一位，再考虑每一位都可以填哪些数字，最后利用通用答案数组统计答案。</p>
<h3 id="例题AcWing-1081-度的数量"><a href="#例题AcWing-1081-度的数量" class="headerlink" title="例题AcWing 1081. 度的数量"></a>例题<a href="https://www.acwing.com/problem/content/1083/">AcWing 1081. 度的数量</a></h3><p>求给定区间 [X,Y] 中满足下列条件的整数个数：这个数恰好等于 K 个互不相等的 B 的整数次幂之和。</p>
<p>例如，设 X=15,Y=20,K=2,B=2，则有且仅有下列三个数满足题意：</p>
<p>17=24+20<br>18=24+21<br>20=24+22<br>输入格式<br>第一行包含两个整数 X 和 Y，接下来两行包含整数 K 和 B。</p>
<p>输出格式<br>只包含一个整数，表示满足条件的数的个数。</p>
<p>数据范围<br>1≤X≤Y≤231−1,<br>1≤K≤20,<br>2≤B≤10<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15 20</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p> 题目要求我们每个位置上的系数只能为一,因为进制数都是可以看作带权展开的，如十进制数：921， 9<em>10^2 + 2</em>10^1 + 1*10^0，这里的921就是按权展开的系数<br> 数位dp甚至是所有dp问题主要问题都是的在于分类讨论或者划分<br> 数位dp问题的划分（看成一颗树状会更好的划分问题)左分支位0~an-1, 右分支是an,所以一般是要结合当前位置的限位数来的填树的，然后把左右分支的所有的情况加起来就是我们所求的方案总数。<br>对于本题的填数<br>当前位置如果为0的情况：那么这位置上只能有右分支且为0（为了方便统一形式把填0的情况都统一在左分支上）<br>当前位置如果为1的情况，左分支只能填0，右分支填1<br>当前位置如果&gt;1的情况，同上。</p>
<p>实在不理解可以看<a href="https://lishizheng.blog.csdn.net/article/details/113665599">这位同学的博客</a></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l,r,K,B;</span><br><span class="line"><span class="type">int</span> C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理C(i,j) = C(i-1, j) + C(i-1, j-1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!j) C[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> C[i][j] = C[i<span class="number">-1</span>][j<span class="number">-1</span>] + C[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="comment">// 把x数值转换成B进制，倒着存放进数组内部</span></span><br><span class="line">    <span class="keyword">while</span>(x) nums.<span class="built_in">pb</span>(x%B), x /= B;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;    <span class="comment">// 表示[0,r]上有多少个合法的数</span></span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>;   <span class="comment">// 在本题记录的是从当前位置之前出现1的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = nums[i];</span><br><span class="line">        <span class="comment">// 题目要求我们每个位置上的系数只能为一（因为进制数都是可以看作带权展开的，如十进制数：921， 9*10^2 + 2*10^1 + 1*10^0，这里的921就是按权展开的系数)</span></span><br><span class="line">        <span class="comment">// 数位dp甚至是所有dp问题主要问题都是的在于分类讨论或者划分</span></span><br><span class="line">        <span class="comment">// 数位dp问题的划分（看成一颗树状会更好的划分问题)左分支位0~an-1, 右分支是an</span></span><br><span class="line">        <span class="comment">// 因为每位上只能填0/1,我们要需要结合限位数来讨论</span></span><br><span class="line">        <span class="comment">// 当这一位上的数是0（&lt;1)，那我们这一位就只能填0，如果这一位上的数&gt;=1,那么这一位如果填0，后面的数随便填，如果这一位数上填一，后面的数还需要重新再讨论（重复上面的讨论）</span></span><br><span class="line">        <span class="keyword">if</span>(x)   <span class="comment">// 左边分支</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 首先这一位上一定是可以放上的是0，所以应该是后面这么多位上可以选这K-last个1</span></span><br><span class="line">            res += C[i][K - last];</span><br><span class="line">            <span class="keyword">if</span>(x &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="comment">// 当前位填1，从剩下的所有位（共有i位）中选K-last-1个数 </span></span><br><span class="line">                <span class="keyword">if</span>(K - last - <span class="number">1</span> &gt;= <span class="number">0</span>) res += C[i][K - last - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 表示如果x&gt;1的话就应该是分类讨论右分支(右分支是要等于an的，但是an大于一，又因为本题的要求系数只能为0/1，所以x&gt;1是不存在右分支的状况所以要剪枝break掉)</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">// x == 1</span></span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="comment">// 表示当前位填一</span></span><br><span class="line">                last ++;</span><br><span class="line">                <span class="keyword">if</span>(last &gt; K) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!i &amp;&amp; last == K) res ++; <span class="comment">// 最右侧分支上的方案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r &gt;&gt; K &gt;&gt; B;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp(r)表示的前r个数里有多少个满足条件的</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">dp</span>(r) - <span class="built_in">dp</span>(l<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模版</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>模版</tag>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2022/07/27/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>树状数组是一个简化版的线段树，其利用二进制数的特性，解决区间查询（主要是区间和查询），以及单点修改操作问题。</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p> <img src="../../themes/butterfly/source/img/树状数组概念.png" alt="树状数组概念"></p>
<ol>
<li>树状数组的下标可以表示出其区间长度是多少。<br>如 4 = 0100 lowbit是最低有效位表示的值, lowbit(4) = 4也就是说其表示的区间为[1,4]<br>再比如 5 = 0101 lowbit(5) = 1也就是其表示的区间为[5,5]<br>所以要求其的前缀和就要涉及到其前驱节点，那么修改某个点必然会影响到其他区间所以就要设计的后继节点的概念</li>
<li>直接前驱 c[i] -&gt; c[i - lowbit(i)]</li>
<li>直接后继 c[i] -&gt; c[i + lowbit(i)]</li>
<li>查询前i个位置的前缀和，那么就要将所有的c[i]前驱节点都加起来</li>
<li>要想修改第i个位置的数值，那么就需要讲所有c[i]后继节点都修改</li>
</ol>
<h3 id="AcWing-241-楼兰图腾"><a href="#AcWing-241-楼兰图腾" class="headerlink" title="AcWing 241. 楼兰图腾"></a><a href="https://www.acwing.com/problem/content/243/">AcWing 241. 楼兰图腾</a></h3><p>在完成了分配任务之后，西部 314 来到了楼兰古城的西部。<br>相传很久以前这片土地上(比楼兰古城还早)生活着两个部落，一个部落崇拜尖刀(V)，一个部落崇拜铁锹(∧)，他们分别用 V 和 ∧ 的形状来代表各自部落的图腾。<br>西部 314 在楼兰古城的下面发现了一幅巨大的壁画，壁画上被标记出了 n 个点，经测量发现这 n 个点的水平位置和竖直位置是两两不同的。<br>西部 314 认为这幅壁画所包含的信息与这 n 个点的相对位置有关，因此不妨设坐标分别为 (1,y1),(2,y2),…,(n,yn)，其中 y1∼yn 是 1 到 n 的一个排列。<br>西部 314 打算研究这幅壁画中包含着多少个图腾。<br>如果三个点 (i,yi),(j,yj),(k,yk) 满足 1≤i<j<k≤n 且 yi>yj,yj<yk，则称这三个点构成`V`图腾;
如果三个点 (i,yi),(j,yj),(k,yk) 满足 1≤i<j<k≤n 且 yi<yj,yj>yk，则称这三个点构成 <code>∧</code> 图腾;<br>西部 314 想知道，这 n 个点中两个部落图腾的数目。<br>因此，你需要编写一个程序来求出 V 的个数和 ∧ 的个数。</p>
<p>输入格式<br>第一行一个数 n。<br>第二行是 n 个数，分别代表 y1，y2,…,yn。</p>
<p>输出格式<br>两个数，中间用空格隔开，依次为 V 的个数和 ∧ 的个数。</p>
<p>数据范围<br>对于所有数据，n≤200000，且输出答案不会超过 int64。<br>y1∼yn 是 1 到 n 的一个排列。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 5 3 2 4</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我们可以讲几何问题转换成代数问题，比如<code>V</code> 也就是我们需要找到一组<code>(i,j,k)</code>, <code>i&gt;=j</code>, <code>k &gt;=j</code>这样的三元组,所以我们需要设置Greater[i],表示第i个位置前面和后面的有多少个数比我们当前第i个位置数值为a[i]的数要大，最后根据乘法原理来匹配（左边任何一个比j要大的树都可以的与右边任何一个比j要大的数匹配）左右两边的数相乘就好。</p>
<p>建立树状数组，我们树状数组内部记录的是某个数值在原数组出现的次数<br>比如add（y,1)表示数值为<code>y</code>在我们坐标轴为<code>y</code>的上面出现次数加一，边建树，边查询我们就可以知道在某个位置之前出现数值的次数的</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> Greater[N], lower[N];</span><br><span class="line"><span class="type">int</span> tr[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取最低有效位置（表示其区间能表示的长度）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在x位置上加上c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x;i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前1～x的前缀和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Greater[i]表示的i的左右比a[i]要大的数的个数</span></span><br><span class="line">    <span class="comment">// 同理lower</span></span><br><span class="line">    <span class="comment">// 现在先计算数值为y的左边比他大（小）的数的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = a[i];</span><br><span class="line">        <span class="comment">// sum(n) - sum(y) 表示数值在[y,n],我们原数组内出现的个数</span></span><br><span class="line">        Greater[i] = <span class="built_in">sum</span>(n) - <span class="built_in">sum</span>(y); </span><br><span class="line">        lower[i] = <span class="built_in">sum</span>(y<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">add</span>(y,<span class="number">1</span>);   <span class="comment">// 将y这个数值加入的树状数组当中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="keyword">sizeof</span> tr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i; i --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = a[i];</span><br><span class="line">        res1 += Greater[i] * ((ll)(<span class="built_in">sum</span>(n) - <span class="built_in">sum</span>(y)));</span><br><span class="line">        res2 += lower[i] * (ll)<span class="built_in">sum</span>(y<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">add</span>(y,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,res1, res2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>模版</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>树的直径</title>
    <url>/2022/07/15/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><h3 id="算法一-两次dfs"><a href="#算法一-两次dfs" class="headerlink" title="算法一 两次dfs"></a>算法一 两次dfs</h3><p>一次dfs求该点的最长距离，第二次从上一个最长路径的另一个端点再一次求解最长路径</p>
<h3 id="算法二-树形dp"><a href="#算法二-树形dp" class="headerlink" title="算法二 树形dp"></a>算法二 树形dp</h3><p>任意选择一个点u，以u为根节点找其的最长路径和最短路径。这两条路径就构造出我们的树的直径。</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],w[N],idx;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father)</span>  <span class="comment">// 返回的是以u为根节点的的树的最长路</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 我们每次枚举都是以u这个节点为最高点(根节点）找其作为根的树的直径</span></span><br><span class="line">    <span class="type">int</span> dist = <span class="number">0</span>; <span class="comment">//从这个点开始往下找的最长路径</span></span><br><span class="line">    <span class="type">int</span> d1 = <span class="number">0</span>, d2 = <span class="number">0</span>; <span class="comment">// d1为最长路径 d2为次长路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == father) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">dfs</span>(j,u) + w[i];</span><br><span class="line">        dist = <span class="built_in">max</span>(dist,d);</span><br><span class="line">        <span class="comment">// 用其子节点的子树的树的直径更新 父节点作为根节点的树的直径</span></span><br><span class="line">        <span class="keyword">if</span>(d &gt;= d1) d2 = d1, d1 = d;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d &gt; d2) d2 = d;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, d1 + d2);</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    m = n<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span> ,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>树的直径</tag>
        <tag>知识点笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>次小生成树</title>
    <url>/2022/07/14/%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h2 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h2><h3 id="定义：给定一个带权的图，把图的所有生成树按权值从小到大排序，第二小的称为次小生成树"><a href="#定义：给定一个带权的图，把图的所有生成树按权值从小到大排序，第二小的称为次小生成树" class="headerlink" title="定义：给定一个带权的图，把图的所有生成树按权值从小到大排序，第二小的称为次小生成树"></a>定义：给定一个带权的图，把图的所有生成树按权值从小到大排序，第二小的称为次小生成树</h3><p><strong>非严格次小生成树的权值 &gt;= 最小生成树</strong><br><strong>严格次小生成树的权值 &gt; 最小生成树</strong>   </p>
<h3 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h3><p><strong>方法一</strong>：先求最小生成树，再枚举删去最小生成树中的边求解。<em>要注意</em>本方法不能求解严格次小生成树。 时间复杂度为O(mlogm + nm)<br><strong>方法二</strong>：先求最小生成树，然后依次枚举非树边，然后将改变加入树中，同时从树中去掉一条边，使得最终的图仍是一颗树。则最后一定会得到一颗次小生成树。</p>
<p>方法二的证明。我们在最小生成树上加入一条非树边一定会形成一个环，由于我们的kruskal算法选择策略是按不连通块之间最小边来选，所以当前加入的这一条非树边一定是&gt;=环上的任意一条边的。如果加入的这一条非树边严格&gt;环上的任意一条边，那么最后我们可以得到一颗严格次小生成树，否则为非严格次小生成树。</p>
<p>定理：次小生成树一定在最小生成树的邻集中。// 也就是说一定有一颗次小生成树（无论严格次小还是非严格）仅与最小生成树差一条边</p>
<h3 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h3><p><strong>这里主要是对方法二</strong>  </p>
<ol>
<li>求最小生成树，统计标记每条边是树边还是非树边；同时把最小生成树建立出来</li>
<li>预处理人任意两点间的边权最大值</li>
<li>一次枚举所有非树边，求min(sum + w - dist[a][b])，满足w &gt; dist[a][b] </li>
</ol>
<h3 id="例题-秘密的牛奶运输"><a href="#例题-秘密的牛奶运输" class="headerlink" title="例题  秘密的牛奶运输"></a>例题  <a href="https://www.acwing.com/problem/content/1150/">秘密的牛奶运输</a></h3><p>农夫约翰要把他的牛奶运输到各个销售点。</p>
<p>运输过程中，可以先把牛奶运输到一些销售点，再由这些销售点分别运输到其他销售点。</p>
<p>运输的总距离越小，运输的成本也就越低。</p>
<p>低成本的运输是农夫约翰所希望的。</p>
<p>不过，他并不想让他的竞争对手知道他具体的运输方案，所以他希望采用费用第二小的运输方案而不是最小的。</p>
<p>现在请你帮忙找到该运输方案。</p>
<p>注意：：</p>
<p>如果两个方案至少有一条边不同，则我们认为是不同方案；<br>费用第二小的方案在数值上一定要严格大于费用最小的方案；<br>答案保证一定有解；<br>输入格式<br>第一行是两个整数 N,M，表示销售点数和交通线路数；</p>
<p>接下来 M 行每行 3 个整数 x,y,z，表示销售点 x 和销售点 y 之间存在线路，长度为 z。</p>
<p>输出格式<br>输出费用第二小的运输方案的运输总距离。</p>
<p>数据范围<br>1≤N≤500,<br>1≤M≤104,<br>1≤z≤109,<br>数据中可能包含重边。</p>
<p>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 2 100</span><br><span class="line">2 4 200</span><br><span class="line">2 3 250</span><br><span class="line">3 4 100</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">450</span><br></pre></td></tr></table></figure></p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><h4 id="朴素版本（可以在求-a-b-上的最大边作优化，这里是朴素版本所以使用的是dfs）"><a href="#朴素版本（可以在求-a-b-上的最大边作优化，这里是朴素版本所以使用的是dfs）" class="headerlink" title="朴素版本（可以在求(a,b)上的最大边作优化，这里是朴素版本所以使用的是dfs）"></a>朴素版本（可以在求(a,b)上的最大边作优化，这里是朴素版本所以使用的是dfs）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span>x</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> h[N], e[N * <span class="number">2</span>], ne[N * <span class="number">2</span>], w[N * <span class="number">2</span>], idx;</span><br><span class="line"><span class="type">int</span> d1[N][N], d2[N][N]; <span class="comment">//d1表示a到b上的这个最长树边，d2表示次长树边</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> f; <span class="comment">// 标记这条边是否在树边</span></span><br><span class="line">    <span class="type">bool</span> operator &lt;(<span class="type">const</span> edge &amp;t) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;eg[M];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x] != x) f[x] = find(f[x]);</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maxd1到u节点最长树边，同理maxd2， 这里的d1[]是对d1[i][]的二维操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father, <span class="type">int</span> maxd1, <span class="type">int</span> maxd2, <span class="type">int</span> d1[], <span class="type">int</span> d2[])</span></span><br><span class="line">&#123;</span><br><span class="line">    d1[u] = maxd1, d2[u] = maxd2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="type">int</span> v = w[i];</span><br><span class="line">        <span class="keyword">if</span>(j != father)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> nd1 = maxd1, nd2 = maxd2;</span><br><span class="line">            <span class="comment">// v等于最大值的时候不要更新，最大值和次大值相等的情况是没有意义的</span></span><br><span class="line">            <span class="keyword">if</span>(v &gt; nd1) nd2 = nd1, nd1 = v;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v &gt; nd2 &amp;&amp; v &lt; nd1) nd2 = v;</span><br><span class="line">            dfs(j,u,nd1,nd2,d1,d2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// build</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        eg[i] = &#123;a,b,c, <span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) f[i] = i;</span><br><span class="line">    sort(eg, eg + m);</span><br><span class="line">    <span class="comment">// kruskal</span></span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = eg[i].a, b = eg[i].b, w = eg[i].w;</span><br><span class="line">        <span class="comment">//因为我们需要在构造最小生成树的情况下同时建图，所以切记使用a=find(a)</span></span><br><span class="line">        <span class="type">int</span> pa = find(a), pb = find(b);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb)</span><br><span class="line">        &#123;</span><br><span class="line">            f[pa] = pb;</span><br><span class="line">            sum += w;</span><br><span class="line">            eg[i].f = <span class="literal">true</span>;</span><br><span class="line">            add(a,b,w);</span><br><span class="line">            add(b,a,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// init d1[],d2[]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) dfs(i,<span class="number">-1</span>,<span class="number">-1e9</span>,<span class="number">-1e9</span>,d1[i],d2[i]);</span><br><span class="line"></span><br><span class="line">    LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!eg[i].f)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = eg[i].a, b = eg[i].b, v = eg[i].w;</span><br><span class="line">            <span class="comment">// 这里是严格次小生成树</span></span><br><span class="line">            <span class="comment">// 非严格在这里变化</span></span><br><span class="line">            LL t;</span><br><span class="line">            <span class="keyword">if</span>(v &gt; d1[a][b]) t = sum + v - d1[a][b];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v &gt; d2[a][b]) t = sum + v - d2[a][b];</span><br><span class="line">            res = min(res, t);  <span class="comment">//最好使得两边都是相同的类型</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化版本（待续）"><a href="#优化版本（待续）" class="headerlink" title="优化版本（待续）"></a>优化版本（待续）</h4>]]></content>
      <categories>
        <category>模版</category>
        <category>图论</category>
        <category>次小生成树</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>图论模版</tag>
        <tag>次小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 - P4147 玉蟾宫</title>
    <url>/2022/07/16/%E6%B4%9B%E8%B0%B7-P4147-%E7%8E%89%E8%9F%BE%E5%AE%AB/</url>
    <content><![CDATA[<h2 id="玉蟾宫"><a href="#玉蟾宫" class="headerlink" title="玉蟾宫"></a><a href="https://vjudge.net/problem/%E6%B4%9B%E8%B0%B7-P4147">玉蟾宫</a></h2><p>有一天，小猫 rainbow 和 freda 来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。</p>
<p>Description<br>这片土地被分成 N\times MN×M 个格子，每个格子里写着 ‘R’ 或者 ‘F’，R 代表这块土地被赐予了 rainbow，F 代表这块土地被赐予了 freda。</p>
<p>现在 freda 要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着 ‘F’ 并且面积最大。</p>
<p>但是 rainbow 和 freda 的 OI 水平都弱爆了，找不出这块土地，而蓝兔也想看 freda 卖萌（她显然是不会编程的……），所以它们决定，如果你找到的土地面积为 SS，它们每人给你 SS 两银子。</p>
<p>Input<br>第一行两个整数 NN，MM，表示矩形土地有 NN 行 MM 列。</p>
<p>接下来 NN 行，每行 MM 个用空格隔开的字符 <code>F</code> 或 <code>R</code>，描述了矩形土地。</p>
<p>Output<br>输出一个整数，表示你能得到多少银子，即 （3×最大 <code>F</code> 矩形土地面积) 的值。</p>
<p>Sample<br>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 6 </span><br><span class="line">R F F F F F </span><br><span class="line">F F F F F F </span><br><span class="line">R R R F F F </span><br><span class="line">F F F F F F </span><br><span class="line">F F F F F F</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">45</span><br></pre></td></tr></table></figure></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>枚举每一行，每一个的每一个位置连续F的最高高度，在每一行都做一次直方图最大面积<br>用dp[i][j] 记录（i,j)这个点往上的最高高度，如果（i，j）这个点存放的字符是<code>F</code>的话，那么dp[i][j] = dp[i-1][j] + 1,如果这个点存放的数据不是<code>F</code>的话那么dp[i][j] = 0</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> mp[N][N];</span><br><span class="line"><span class="type">int</span> st[N],l[N],r[N];  <span class="comment">// 每一行往上都可以构造成一个直方图最大矩阵问题，所以在这记录的是单调增</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dp[N][N];   <span class="comment">// 枚举每一行的每一个位置看这个位置往上有多少个连续的F</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> c;<span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">            mp[i][j] = c;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;F&#x27;</span>) dp[i][j] = dp[i<span class="number">-1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 单调栈处理当前这行往上的矩形最大面积问题</span></span><br><span class="line">        <span class="type">int</span> hh = <span class="number">0</span>; st[hh] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(hh &amp;&amp; dp[i][st[hh]] &gt;= dp[i][j]) hh --;</span><br><span class="line">            l[j] = st[hh] + <span class="number">1</span>;</span><br><span class="line">            st[++hh] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hh = <span class="number">0</span>, st[hh] = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">1</span>; j --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(hh &amp;&amp; dp[i][st[hh]] &gt;= dp[i][j]) hh --;</span><br><span class="line">            r[j] = st[hh] - <span class="number">1</span>;</span><br><span class="line">            st[++hh] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = (r[j] - l[j] + <span class="number">1</span>) * dp[i][j];</span><br><span class="line">            res = max(res, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res * <span class="number">3</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>移掉K位数字</title>
    <url>/2022/07/15/%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="移掉K位数字"><a href="#移掉K位数字" class="headerlink" title="移掉K位数字"></a><a href="https://www.acwing.com/problem/content/1455/">移掉K位数字</a></h2><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p>
<p>注意：</p>
<p>空字符串被视为0。<br>如果结果中包含前导零，则需要将前导零删除，最后删除的前导零不用包含在移除的 k 个数字中。<br>输入格式<br>第一行输入一个字符串，用来表示非负整数 num。</p>
<p>第二行输入一个整数，表示 k。</p>
<p>输出格式<br>输出一个字符串，表示移除 k 位数字后所能得到的最小数字。</p>
<p>数据范围<br>0≤k≤ 字符串长度 ≤100000，<br>num 中不包含任何前导 0。</p>
<p>输入样例1：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1432219</span><br><span class="line">3</span><br></pre></td></tr></table></figure><br>输出样例1：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1219</span><br></pre></td></tr></table></figure><br>样例1解释<br>移除掉三个数字 4,3,2 可形成一个新的最小的数字 1219。</p>
<p>输入样例2：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10200</span><br><span class="line">1</span><br></pre></td></tr></table></figure><br>输出样例2：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200</span><br></pre></td></tr></table></figure><br>样例2解释：<br>移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</p>
<p>输入样例3：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">2</span><br></pre></td></tr></table></figure><br>输出样例3：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><br>样例3解释<br>从原数字移除所有的数字，剩余为空就是 0。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为输出数的数的为数是确定的 == n-k 位，所以最高位越小对于整个的数值就越小，这里可以结合带权展开<br>所以我们需要使用一个单调栈来构造一个递增序列<br>还要注意的一些细节<br>全部删除输出 0<br>单调栈里面全部为0是保留一位0<br>如果这个数不是全为0，前面的0就是前导0，所以要全部去掉，这里可以使用i &lt; n来判断</p>
<h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>, N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ;i ++) <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>; st[hh] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> ck = k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(hh &amp;&amp; st[hh] &gt; s[i] &amp;&amp; ck)</span><br><span class="line">        &#123;</span><br><span class="line">            hh--,ck --;</span><br><span class="line">        &#125;</span><br><span class="line">        st[++hh] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有删完的情况ck&gt;0,因为没有删完的元素全部入栈了，所以我们需要从栈顶开始退栈</span></span><br><span class="line">    <span class="keyword">while</span>(ck --) hh--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n-k == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(st[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; i &lt; hh) i ++;  <span class="comment">// 删去前导0，全是0的情况但是至少要保留一个0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= hh; j ++) <span class="built_in">cout</span> &lt;&lt; st[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>单调栈</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>算法课程设计- Miller-Rabin &amp; Pollard</title>
    <url>/2022/09/29/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1-Miller-Rabin-Pollard/</url>
    <content><![CDATA[<h1 id="前言（引言）"><a href="#前言（引言）" class="headerlink" title="前言（引言）"></a>前言（引言）</h1><h2 id="课程设计目的："><a href="#课程设计目的：" class="headerlink" title="课程设计目的："></a>课程设计目的：</h2><p>现阶段的的RSA是作为世界上公认的最安全加密算法之一，许多的重要机构都在使用这RSA算法。一旦当今的RSA算法被成功破解世界上将会发生一系列重大的转折。在RSA算法的诞生之前每个几年或是十几年都会有一位密码学家破解出来，但是RSA算法诞生之后几十年来每个人都在挑战的这一个大数分解困难问题，并且无任何一人破解出来。 </p>
<h2 id="课程设计范围："><a href="#课程设计范围：" class="headerlink" title="课程设计范围："></a>课程设计范围：</h2><p>实现素数测试算法和分解因数算法，并可视化原理过程。  </p>
<h2 id="工作描述及理论基础："><a href="#工作描述及理论基础：" class="headerlink" title="工作描述及理论基础："></a>工作描述及理论基础：</h2><p>通过费马小定理和二次探测原理实现素数测试。通过构造伪随机序列实现因数分解。  </p>
<h2 id="预期结果和意义："><a href="#预期结果和意义：" class="headerlink" title="预期结果和意义："></a>预期结果和意义：</h2><p>实现大整数素数测试和因数分解。深刻体验在大数下对程序即使优化时间复杂度的O(√),都能带来很大的变化，也深刻体验到大数分解的世界级难题。   </p>
<h2 id="可行性分析："><a href="#可行性分析：" class="headerlink" title="可行性分析："></a>可行性分析：</h2><p>大数分解问题人类至今仍未找到一个正确的认识，也就是我们还不能认识到素数内的深刻含义。当前我们实现的算法只是在认识素数道路上的坚实的一步，前路还远，需要不断探索数字的奥秘。    </p>
<h2 id="总体设计："><a href="#总体设计：" class="headerlink" title="总体设计："></a>总体设计：</h2><p>大数通过数组进行模拟，所以基本的运算在本程序都需要的重载。并对算法进行更改。编写Miller-Rabin,Pollard’s Rho模块。高精度的快速幂和GCD函数作为辅助。</p>
<h1 id="第一章-预处理及数据结构"><a href="#第一章-预处理及数据结构" class="headerlink" title="第一章 预处理及数据结构"></a>第一章 预处理及数据结构</h1><h2 id="1-1-头文件"><a href="#1-1-头文件" class="headerlink" title="1.1 头文件"></a>1.1 头文件</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> <span class="comment">//工程性头文件</span></span></span><br></pre></td></tr></table></figure>
<h2 id="1-2-宏定义"><a href="#1-2-宏定义" class="headerlink" title="1.2 宏定义"></a>1.2 宏定义</h2><p>算法编写习惯，将许多较长繁琐的简化<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se secondb</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br></pre></td></tr></table></figure></p>
<h2 id="1-3-结构体"><a href="#1-3-结构体" class="headerlink" title="1.3 结构体"></a>1.3 结构体</h2><p>有大数的存储结构<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">20100</span>];	<span class="comment">// 存储数据</span></span><br><span class="line">    <span class="type">int</span> len;	<span class="comment">// 这个大数的位数</span></span><br><span class="line">    <span class="type">char</span> op;	<span class="comment">// 这个大数正负性</span></span><br><span class="line">    <span class="built_in">Data</span>()&#123;<span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(num)); len=<span class="number">1</span>; op=<span class="string">&#x27;+&#x27;</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="第二章-函数"><a href="#第二章-函数" class="headerlink" title="第二章 函数"></a>第二章 函数</h1><h2 id="2-1-最大公约数-gcd-Data-a-Data-b"><a href="#2-1-最大公约数-gcd-Data-a-Data-b" class="headerlink" title="2.1 最大公约数 gcd(Data a, Data b)"></a>2.1 最大公约数 gcd(Data a, Data b)</h2><p>功能设计：找出两个数之间的最大公约数<br>求两个正整数 a 和 b 的 最大公约数 d<br>则有 gcd(a,b) = gcd(b,a%b)<br>证明：<br>设a%b = a - k<em>b 其中k = a/b(向下取整)<br>    若d是(a,b)的公约数 则知 d|a 且 d|b 则易知 d|a-k</em>b 故d也是(b,a%b) 公约数<br>若d是(b,a%b)的公约数 则知 d|b 且 d|a-k<em>b 则 d|a-k</em>b+k*b = d|a 故而d|b 故而 d也是(a,b)的公约数<br>    因此(a,b)的公约数集合和(b,a%b)的公约数集合相同 所以他们的最大公约数也相同 证毕<br>代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="function">Data <span class="title">gcd</span><span class="params">(Data a,Data b)</span> </span>&#123;   </span><br><span class="line">	    <span class="keyword">if</span>(b &gt; <span class="built_in">turn</span>(<span class="number">0</span>)) <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);  </span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">return</span> a;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>
<h2 id="2-2-高进度快速幂"><a href="#2-2-高进度快速幂" class="headerlink" title="2.2 高进度快速幂"></a>2.2 高进度快速幂</h2><p>功能设计：利用二进制优化计算一个大数的幂<br>计算 $a$ 的 $n$ 次方表示将 $n$ 个 $a$ 乘在一起：$a^{n} = \underbrace{a \times a \cdots \times a}<em>{n\text{ 个 a}}$。然而当 $a,n$ 太大的时侯，这种方法就不太适用了。不过我们知道：$a^{b+c} = a^b \cdot a^c,\,\,a^{2b} = a^b \cdot a^b = (a^b)^2$。二进制取幂的想法是，我们将取幂的任务按照指数的 <strong>二进制表示</strong> 来分割成更小的任务。<br>如果把 $n$ 写作二进制为 $(n_tn</em>{t-1}\cdots n_1n_0)_2$，那么有：</p>
<script type="math/tex; mode=display">
n = n_t2^t + n_{t-1}2^{t-1} + n_{t-2}2^{t-2} + \cdots + n_12^1 + n_02^0</script><p>其中 $n_i\in{0,1}$。那么就有</p>
<script type="math/tex; mode=display">
\begin{aligned}
a^n & = (a^{n_t 2^t + \cdots + n_0 2^0})\\\\
& = a^{n_0 2^0} \times a^{n_1 2^1}\times \cdots \times a^{n_t2^t}
\end{aligned}</script><p>根据上式我们发现，原问题被我们转化成了形式相同的子问题的乘积，并且我们可以在常数时间内从 $2^i$ 项推出 $2^{i+1}$ 项。</p>
<p>这个算法的复杂度是 $\Theta(\log n)$ 的，我们计算了 $\Theta(\log n)$ 个 $2^k$ 次幂的数，然后花费 $\Theta(\log n)$ 的时间选择二进制为 1 对应的幂来相乘。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Data <span class="title">ksm</span><span class="params">(Data a, Data b, Data p)</span>  <span class="comment">// 快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="built_in">turn</span>(<span class="number">0</span>)) <span class="keyword">return</span> <span class="built_in">turn</span>(<span class="number">1</span>)%p;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="built_in">turn</span>(<span class="number">1</span>)) <span class="keyword">return</span> a % p;</span><br><span class="line">    Data t = <span class="built_in">ksm</span>(a, b/<span class="built_in">turn</span>(<span class="number">2</span>), p);</span><br><span class="line">    <span class="keyword">if</span>(b % <span class="built_in">turn</span>(<span class="number">2</span>) == <span class="built_in">turn</span>(<span class="number">0</span>)) <span class="keyword">return</span> t * t % p;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">return</span> (((t*t)%p)*a)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-3-素数测试-millerRabin-Data-n"><a href="#2-3-素数测试-millerRabin-Data-n" class="headerlink" title="2.3 素数测试 millerRabin(Data n)"></a>2.3 素数测试 millerRabin(Data n)</h2><p>功能设计：实现判断一个数是合数还是素数  </p>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>如果a是一个整数， p是一个素数一定满足</p>
<script type="math/tex; mode=display">a^{p - 1} \equiv 1modp</script><p>证明费马小定理：<br>要知到$\left( \frac{p}{n} \right) = \frac{p!}{n!(p - n)!}modp = = 0$<br>首先看分子，分子上是有p这一项的，而分母$n!$ 和<br>$(p - n)!$很明显没有单独项<code>p</code>。再讨论能否通过多项相乘得到p呢？由于p是一个素数，其因子只有<code>1</code>和<code>p</code>自身，所以当没有<code>p</code>这一项是不可能相乘组合成<code>p</code>的。<strong>所以通过上式我们知道了</strong>$\left( \frac{p}{n} \right)$<strong>是p的倍数</strong></p>
<script type="math/tex; mode=display">(b + 1)^{p} \equiv (通过多项式展开) \rightarrow \left( \frac{p}{p} \right)b^{p} + \left( \frac{p}{p - 1} \right)b^{p - 1} + ... + \left( \frac{p}{0} \right)b^{0}\mspace{6mu} mod\ p</script><script type="math/tex; mode=display">\Leftrightarrow 因为组合数和p取模等于0</script><script type="math/tex; mode=display">\Leftrightarrow \left( \frac{p}{p} \right)b^{p} + \left( \frac{p}{0} \right)b^{0}\mspace{6mu} mod\ p</script><script type="math/tex; mode=display">\Leftrightarrow (b + 1)^{p} \equiv b^{p} + 1\mspace{6mu} mod\ p</script><p>用$b = a - 1$ 代换到原公式当中就证得我们的费马小定理</p>
<p>费马小定理告诉我们只要p是质数就满足上面的等式。其逆定理经常用来证明这个数不是素数。也就是当p不是素数的情况下，就不会满足上式。这个也叫做<strong>费马伪素数</strong>。虽然费马逆定理可以基本证明绝大多数合数都是符合逆定理，但是有一类卡迈尔数是费马伪素数的反例。（最小的卡迈尔数是<code>561 = 3 * 11 * 17</code>）</p>
<h3 id="二次探测定理"><a href="#二次探测定理" class="headerlink" title="二次探测定理"></a>二次探测定理</h3><p>对于奇质数p和正整数e有</p>
<script type="math/tex; mode=display">x^{2} \equiv 1\mspace{6mu} mod\ p^{e}</script><p>化简得到：\<br>$\Leftrightarrow (x - 1)(x + 1) \equiv 0\mspace{6mu} mod\ p^{e}$<br>也就是说，如果找到一个$a \neq \pm 1$,使得$a^{2} \equiv 1\mspace{6mu} mod\ n$,<br>那么说明n一定不是质数</p>
<p>证明：</p>
<script type="math/tex; mode=display">x^{2^{i}k} - 1 = \left( x^{2^{i - 1}k} \right)^{2} - 1 = \left( x^{2^{i - 1}k} - 1 \right)\left( x^{2^{i - 1}k} + 1 \right)</script><script type="math/tex; mode=display">\Leftrightarrow \left( x^{k} - 1 \right)\left( x^{k} + 1 \right)\left( x^{2k} + 1 \right)\left( x^{4k} + 1 \right)...\left( x^{2^{i - 1}k} + 1 \right)</script><p>当p是素数的时候 $a \in \lbrack 1,p\rbrack$,有费马小定理</p>
<script type="math/tex; mode=display">a^{p - 1} \equiv 1\mspace{6mu} mod\ p</script><p>当$p - 1$等于$2^{i}k$时候可以由上式知道</p>
<script type="math/tex; mode=display">\left( x^{k} - 1 \right)\left( x^{k} + 1 \right)\left( x^{2k} + 1 \right)\left( x^{4k} + 1 \right)...\left( x^{2^{i - 1}k} + 1 \right) \equiv 0\mspace{6mu} mod\ p</script><p>根据上式知道如果p是素数，一定有$x^{k} \equiv 1\mspace{6mu} mod\ p$<br><strong>OR</strong> $x^{2^{i}k} \equiv - 1\mspace{6mu} mod\ p$<br>运用其逆定理我们就可以知道算法来<strong>伪素数</strong></p>
<h3 id="Miller-Rabin-素数测试-CODE"><a href="#Miller-Rabin-素数测试-CODE" class="headerlink" title="Miller-Rabin 素数测试 CODE"></a>Miller-Rabin 素数测试 CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">millerRabin</span><span class="params">(Data n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 偶数一定点不是素数（除2外）</span></span><br><span class="line">    <span class="comment">// &lt; 3的数只有2是素数</span></span><br><span class="line">    Data num3 = <span class="built_in">turn</span>(<span class="number">3</span>), num2 = <span class="built_in">turn</span>(<span class="number">2</span>), num0 = <span class="built_in">turn</span>(<span class="number">0</span>), num1 = <span class="built_in">turn</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n &lt; num3 || n % num2 == num0) <span class="keyword">return</span> n == num2;</span><br><span class="line">    <span class="comment">// 费马小定理 a^(p-1) mod p同余1</span></span><br><span class="line">    <span class="comment">// 使用费马小定理转化成二次探测</span></span><br><span class="line">    <span class="comment">// 即用(2^e)k 表示成 n-1</span></span><br><span class="line">    <span class="comment">// b是次数</span></span><br><span class="line">    Data a = n - num1;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a % num2 == num0) a = a / num2, b = b + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 表头(需要可视化)</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;millerRabin算法&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;底数x\t次数a\t与p同余\tn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test_time 为测试次数,建议设为不小于 8</span></span><br><span class="line">    <span class="comment">// 的整数以保证正确率,但也不宜过大,否则会影响效率</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j; i &lt;= test_time; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 理论上1&lt;=a&lt;p, 但是底数为1来计算没什么大的意义只会浪费测试次数(其实底数也没有特定的要求，随机数即可)</span></span><br><span class="line">        Data x = <span class="built_in">turn</span>(<span class="number">1ll</span> * <span class="built_in">rand</span>());</span><br><span class="line">        <span class="comment">// 快速幂</span></span><br><span class="line">        <span class="comment">// Data v = quickPow(x,a,n);</span></span><br><span class="line">        Data v = <span class="built_in">ksm</span>(x,a,n);</span><br><span class="line">        <span class="built_in">print</span>(x),<span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>),<span class="built_in">print</span>(a), <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>),<span class="built_in">print</span>(v),<span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>),<span class="built_in">print</span>(n),<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// printf(&quot;%lld\t%lld\t%lld\t%lld\n&quot;, x, a, v, n);</span></span><br><span class="line">        <span class="keyword">if</span>(v == num1) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; b; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v == n - num1) <span class="keyword">break</span>;</span><br><span class="line">            a = a * num2;</span><br><span class="line">            v = v * v % n;</span><br><span class="line">            <span class="built_in">print</span>(x),<span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>),<span class="built_in">print</span>(a), <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>),<span class="built_in">print</span>(v),<span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>),<span class="built_in">print</span>(n),<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="comment">// printf(&quot;%lld\t%lld\t%lld\t%lld\n&quot;, x, a, v, n);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果测完了之后都没有同余就说明当前的数不是素数</span></span><br><span class="line">        <span class="keyword">if</span>(j &gt;= b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-Pollard-大数分解-pollard-rho-Data-n"><a href="#2-4-Pollard-大数分解-pollard-rho-Data-n" class="headerlink" title="2.4 Pollard 大数分解 pollard_rho(Data n)"></a>2.4 Pollard 大数分解 pollard_rho(Data n)</h2><p>功能设计： 实现寻找大数的因子  </p>
<h3 id="生日问题"><a href="#生日问题" class="headerlink" title="生日问题"></a>生日问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>生日问题是指最少需要几人，当中的两个人生日相同的概率才会大于50%。这个题目的答案是23人。<br>这就意味着在一个典型的标准小学班级（30人）中，存在两人生日相同的可能性更高。对于60或者更多的人，这种概率会大于99%。这个问题有时也被称做生日悖论，但从引起逻辑矛盾的角度来说生日悖论并不是一种悖论，它被称作悖论只是因为这个数学事实与一般直觉相抵触而已。大多数人会认为，23人中有2人生日相同的概率应该远远小于50%。计算与此相关的概率被称为生日问题，在这个问题之后的数学理论已被用于设计著名的密码攻击方法：生日攻击。</p>
<h4 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a>问题解释</h4><p>可以把生日悖论理解成一个盲射打靶的问题。对于一个23人的房间，先考虑问题的补集：23人生日两两不同的概率是多少？为此，可以让23个人依次进入，那么每个人生日都与其他人不同的概率依次是1，364/365，363/365，362/365，361/365，等等。先进入房间的这些人生日两两不同的概率是很大的，比如说前面5个是1×364/365×363/365×362/365×361/365=97.3%。而对于最后进入房间的几个人情况就完全不同。最后几个人进入房间并且找不到同生日者的概率是…<br>345/365，344/365，343/365。可以把这种概率看成对一张靶的盲射：靶上有365个小格，其中有17个左右是黑格，其余是白格。假设每枪必中靶并且分布符合几何概型的话，那么连续射12枪左右任何一发都没有击中黑格的概率（投射于房间里的人生日都两两不同）是多少呢？想必大家立即会感觉到这个概率十分微小。</p>
<p>理解生日悖论的关键，在于考虑上述”依次进入房间”模型中最后几个进入房间的人”全部都没碰到相同生日的人”概率有多大这件事情。</p>
<p>简而言之，大多数人之所以会认为23人中有2人生日相同的概率应该远远小于50%，是因为将问题理解为”其他22人与你的生日相同的概率”，而非问题本意”23人之中两两之间存在生日相同”。如果考虑到这一点，直觉上会将原来的概率乘以23（注意：此算法并不正确），则会意识到概率很大了。</p>
<h4 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> mult = <span class="number">1.0</span>;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 23 个人</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">23</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        mult *= (<span class="number">365</span> - i + <span class="number">1</span>) / <span class="number">365.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans -= mult;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以根据上面的代码计算出来只要一个班有23个人的话，两个人在同一个天生日的概率就大概在<code>0.507297</code></p>
<h3 id="构造伪随机函数"><a href="#构造伪随机函数" class="headerlink" title="构造伪随机函数"></a>构造伪随机函数</h3><p>我们通过 $f(x) = \left( x^{2} + c \right)\ mod\ n$ 来生成一个随机数序列<br>${ x_{i}}$，其中 $c = rand()$，是一个随机的常数。</p>
<p>随机取一个<br>$x<em>{1},令x</em>{2} = f\left( x<em>{1} \right),x</em>{3} = f\left( x<em>{2} \right),\ldots,x</em>{i} = f\left( x_{i - 1} \right)$，在一定范围内可以认为这个数列是”随机”的。</p>
<p>举个例子，设 $N = 50,c = 2,x_{1} = 1$ $f(x)$ 生成的数据为</p>
<script type="math/tex; mode=display">1,3,11,23,31,11,23,31,\ldots</script><p>可以发现数据在 3 以后都在 11,23,31 之间循环，这也是 $f(x)$<br>被称为伪随机函数的原因。</p>
<p>如果将这些数如下图一样排列起来，会发现这个图像酷似一个<br>$\rho$，算法也因此得名 rho。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>我们知道对于每一个数来说一定存在一个最大公约数gcd</li>
<li>根据生日悖论知道，<br>即使对于一小部分人来说，两个人同一个天生日的概率依然会是很高</li>
<li>floyd判环</li>
</ul>
<p>算法： <strong>通过floyd优化后的算法只能分解出来任意一个因数</strong> 1. 从随机 x 和<br>c 开始。取 y 等于 x 和 f(x) = x 2 + c。 2. 虽然没有获得除数 2.1 将 x<br>更新为 f(x)（模 n）[乌龟移动] 2.2 将 y 更新为 f(f(y)) (模 n) [Hare<br>Move] 2.3 计算 |xy| 的 GCD 和 n 如果 GCD 不是统一的 如果 GCD 为<br>n，则使用另一组 x、y 和 c 从步骤 2 开始重复 否则 GCD 是我们的答案</p>
<h3 id="Pollard-算法"><a href="#Pollard-算法" class="headerlink" title="Pollard 算法"></a>Pollard 算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找出大数中的其中一个质因子</span></span><br><span class="line"><span class="function">Data <span class="title">pollard_rho</span><span class="params">(Data n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;adasd&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// 伪随机序列 f(x) = x^2 + c mod n</span></span><br><span class="line">    Data num3 = <span class="built_in">turn</span>(<span class="number">3</span>), num2 = <span class="built_in">turn</span>(<span class="number">2</span>), num0 = <span class="built_in">turn</span>(<span class="number">0</span>), num1 = <span class="built_in">turn</span>(<span class="number">1</span>);</span><br><span class="line">    Data c = <span class="built_in">turn</span>(<span class="number">1ll</span> * <span class="built_in">rand</span>()) % (n-num1) + num1;</span><br><span class="line">    Data t = <span class="built_in">f</span>(<span class="built_in">turn</span>(<span class="number">1ll</span> * <span class="built_in">rand</span>()) % (n-num1) + num1, c, n);    Data r = <span class="built_in">f</span>( <span class="built_in">f</span>( <span class="built_in">turn</span>(<span class="number">1ll</span> * <span class="built_in">rand</span>()) % (n-num1) + num1, c, n ), c, n );</span><br><span class="line">    <span class="comment">// cout &lt;&lt; c.len &lt;&lt; &#x27; &#x27; &lt;&lt; t.len &lt;&lt; &#x27; &#x27; &lt;&lt; r.len &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; c.op &lt;&lt; &#x27; &#x27; &lt;&lt; t.op &lt;&lt; &#x27; &#x27; &lt;&lt; r.op &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// print(c), printf(&quot;\t&quot;),print(t),printf(&quot;\t&quot;),print(r),puts(&quot;&quot;);</span></span><br><span class="line">    Data d = num1;</span><br><span class="line">    <span class="comment">// 正因为mod n 算法我们知道最后会呈一个周期性的状态，所以当r追赶上的t的时候还没有退出循环，那么就意味找不到的我们想要的结果</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; t &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的输出需要可视化</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;pollard_rho算法&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = &quot;</span>),<span class="built_in">print</span>(c),<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;c = %ld\n&quot;, c);</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;xi + 1 = f(x)\txi+1 = f(y)\tc\td = gcd(|x-y|,n)&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(t != r)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;asdsahdkaj&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 通过生日悖论知道两个数有相同的最大公约数的概率其实是很大的</span></span><br><span class="line">        Data tmp;</span><br><span class="line">        <span class="keyword">if</span>( (t - r) &gt; num0) tmp = t - r;</span><br><span class="line">        <span class="keyword">else</span> tmp = r - t;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        d = <span class="built_in">gcd</span>(tmp, n); </span><br><span class="line">        <span class="built_in">print</span>(t),<span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>),<span class="built_in">print</span>(r), <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>),<span class="built_in">print</span>(c),<span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>),<span class="built_in">print</span>(d),<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// printf(&quot;%lld\t%lld\t%lld\t%lld\n&quot;, t, r, c, d);</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// gcd不唯一且非平凡因子时候才能返回值</span></span><br><span class="line">        <span class="keyword">if</span>(d &gt; num1) <span class="keyword">return</span> d;</span><br><span class="line">        <span class="comment">// gcd == n OR 1 重复寻找随机序列对</span></span><br><span class="line">        t = <span class="built_in">f</span>(t,c,n);</span><br><span class="line">        r = <span class="built_in">f</span>(<span class="built_in">f</span>(r,c,n),c,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第三章-主函数"><a href="#第三章-主函数" class="headerlink" title="第三章 主函数"></a>第三章 主函数</h1><h2 id="3-1-功能菜单"><a href="#3-1-功能菜单" class="headerlink" title="3.1 功能菜单"></a>3.1 功能菜单</h2><p>功能设计： 让用户选择三个功能  </p>
<ol>
<li>你认为它是一个合数，调用Pollard算法对它进行因数分解</li>
<li>你认为它是一个素数，调用Miller-Rabbin算法对它进行测试确认</li>
<li>你不知道它是合数还是素数，先尝试Pollard算法对它进行因数分解，打印分解的结果.如果分解失败，转而调用Miller-Rabbin对它进行检查，报告是否素数</li>
</ol>
<h1 id="课程设计代码"><a href="#课程设计代码" class="headerlink" title="课程设计代码"></a>课程设计代码</h1><h2 id="可视化CODE"><a href="#可视化CODE" class="headerlink" title="可视化CODE"></a>可视化CODE</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line">    <span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line">    <span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line">    <span class="type">const</span> ll mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a%b) : a; &#125;</span><br><span class="line">    <span class="comment">// head</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> test_time = <span class="number">8</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">INPUTCENT</span><span class="params">(<span class="type">char</span> *pst, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">INPUTCENT</span><span class="params">(ll nums, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DrawMBT</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DrawPBT</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">INITFACE</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 二进制优化快速幂</span></span><br><span class="line">    <span class="function">ll <span class="title">quickPow</span><span class="params">(ll a, ll b, ll p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll res = <span class="number">1</span> % p;</span><br><span class="line">        <span class="keyword">while</span> (b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % p;</span><br><span class="line">            a = a * a % p;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 素数测试</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">millerRabin</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 偶数一定点不是素数（除2外）</span></span><br><span class="line">        <span class="comment">// &lt; 3的数只有2是素数</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span> || n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> n == <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 费马小定理 a^(p-1) mod p同余1</span></span><br><span class="line">        <span class="comment">// 使用费马小定理转化成二次探测</span></span><br><span class="line">        <span class="comment">// 即用(2^e)k 表示成 n-1</span></span><br><span class="line">        <span class="comment">// b是次数</span></span><br><span class="line">        ll a = n - <span class="number">1</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a % <span class="number">2</span> == <span class="number">0</span>) a /= <span class="number">2</span>, ++b;</span><br><span class="line">        <span class="comment">// 表头(需要可视化)</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;millerRabin算法&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;底数x\t次数a\t与p同余\tn&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test_time 为测试次数,建议设为不小于 8</span></span><br><span class="line">        <span class="comment">// 的整数以保证正确率,但也不宜过大,否则会影响效率</span></span><br><span class="line">        <span class="built_in">INITFACE</span>();</span><br><span class="line">        <span class="built_in">DrawMBT</span>();</span><br><span class="line">        <span class="comment">// 第一行的数据</span></span><br><span class="line">        <span class="type">int</span> H = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j; i &lt;= test_time; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 理论上1&lt;=a&lt;p, 但是底数为1来计算没什么大的意义只会浪费测试次数</span></span><br><span class="line">            ll x = <span class="number">1ll</span> * <span class="built_in">rand</span>() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 快速幂</span></span><br><span class="line">            ll v = <span class="built_in">quickPow</span>(x, a, n);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\t%lld\t%lld\t%lld\n&quot;</span>, x, a, v, n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第L列的数据</span></span><br><span class="line">            <span class="type">int</span> L = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">INPUTCENT</span>(x, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">            L++;</span><br><span class="line">            <span class="built_in">INPUTCENT</span>(a, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">            L++;</span><br><span class="line">            <span class="built_in">INPUTCENT</span>(v, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">            L++;</span><br><span class="line">            <span class="built_in">INPUTCENT</span>(n, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">            L++;</span><br><span class="line">            H++;</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; b; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (v == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                v = v * v % n;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\t%lld\t%lld\t%lld\n&quot;</span>, x, a, v, n);</span><br><span class="line">                L = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">INPUTCENT</span>(x, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">                L++;</span><br><span class="line">                <span class="built_in">INPUTCENT</span>(a, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">                L++;</span><br><span class="line">                <span class="built_in">INPUTCENT</span>(v, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">                L++;</span><br><span class="line">                <span class="built_in">INPUTCENT</span>(n, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">                L++;</span><br><span class="line">                H++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果测完了之后都没有同余就说明当前的数不是素数</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*_getch();*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造伪随机序列</span></span><br><span class="line">    <span class="function">ll <span class="title">f</span><span class="params">(ll x, ll c, ll n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x * x + c) % n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出大数中的其中一个质因子</span></span><br><span class="line">    <span class="function">ll <span class="title">pollard_rho</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 伪随机序列 f(x) = x^2 + c mod n</span></span><br><span class="line">        ll c = <span class="number">1ll</span> * <span class="built_in">rand</span>() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        ll t = <span class="built_in">f</span>(<span class="number">1ll</span> * <span class="built_in">rand</span>() % (n - <span class="number">1</span>) + <span class="number">1</span>, c, n);</span><br><span class="line">        ll r = <span class="built_in">f</span>((<span class="number">1ll</span> * <span class="built_in">rand</span>() % (n - <span class="number">1</span>) + <span class="number">1</span>, c, n), c, n);</span><br><span class="line">        ll d = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 正因为mod n 算法我们知道最后会呈一个周期性的状态，所以当r追赶上的t的时候还没有退出循环，那么就意味找不到的我们想要的结果</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; t &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里的输出需要可视化</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;pollard_rho算法&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;c = %ld\n&quot;</span>, c);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;xi + 1 = f(x)\txi+1 = f(y)\tc\td = gcd(|x-y|,n)&quot;</span>);</span><br><span class="line">        <span class="built_in">INITFACE</span>();</span><br><span class="line">        <span class="built_in">DrawPBT</span>();</span><br><span class="line">        <span class="comment">// 第一行的数据</span></span><br><span class="line">        <span class="type">int</span> H = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t != r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 通过生日悖论知道两个数有相同的最大公约数的概率其实是很大的</span></span><br><span class="line">            d = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(t - r), n);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\t%lld\t%lld\t%lld\n&quot;</span>, t, r, c, d);</span><br><span class="line">            <span class="type">int</span> L = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">INPUTCENT</span>(t, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">            L++;</span><br><span class="line">            <span class="built_in">INPUTCENT</span>(r, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">            L++;</span><br><span class="line">            <span class="built_in">INPUTCENT</span>(c, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">            L++;</span><br><span class="line">            <span class="built_in">INPUTCENT</span>(d, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">            L++;</span><br><span class="line">            H++;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// gcd不唯一且非平凡因子时候才能返回值</span></span><br><span class="line">            <span class="keyword">if</span> (d &gt; <span class="number">1</span> &amp;&amp; d != n) <span class="keyword">return</span> d;</span><br><span class="line">            <span class="comment">// gcd == n OR 1 重复寻找随机序列对</span></span><br><span class="line">            t = <span class="built_in">f</span>(t, c, n);</span><br><span class="line">            r = <span class="built_in">f</span>(<span class="built_in">f</span>(r, c, n), c, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//_getch();</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">initgraph</span>(<span class="number">800</span>, <span class="number">800</span>, SHOWCONSOLE);</span><br><span class="line">        <span class="built_in">setbkcolor</span>(<span class="number">0x3a0a0a</span>);                                                   <span class="comment">// 设置背景颜色为黑色</span></span><br><span class="line">        <span class="built_in">cleardevice</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-----------------------------------------------------------------------------------------------------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\t\t\t功能菜单&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;1. 你认为它是一个合数，调用Pollard算法对它进行因数分解&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;2. 你认为它是一个素数，调用Miller-Rabbin算法对它进行测试确认&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;3. 你不知道它是合数还是素数，先尝试Pollard算法对它进行因数分解，打印分解的结果.如果分解失败，转而调用Miller-Rabbin对它进行检查，报告是否素数。&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        ll test;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;您需要先选择一个功能，然后在输入您需要测试的数据（以空格或换行分割）&quot;</span>);</span><br><span class="line">        cin &gt;&gt; p &gt;&gt; test;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机种子</span></span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">switch</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">millerRabin</span>(test))</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="built_in">puts</span>(<span class="string">&quot;这是一个素数&quot;</span>);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  ll d = <span class="built_in">pollard_rho</span>(test);</span><br><span class="line">                  <span class="keyword">while</span> (d == test) d = <span class="built_in">pollard_rho</span>(test);</span><br><span class="line">                  <span class="built_in">printf</span>(<span class="string">&quot;合数:%lld其中的一个因子为%lld\n&quot;</span>, test, d);</span><br><span class="line"></span><br><span class="line">        &#125;  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">millerRabin</span>(test)) <span class="built_in">puts</span>(<span class="string">&quot;这是一个素数&quot;</span>);</span><br><span class="line">                  <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;这不是一个素数&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        &#123;</span><br><span class="line">                  <span class="keyword">if</span> (!<span class="built_in">millerRabin</span>(test))</span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>,<span class="string">&quot;开始绘制下一个&quot;</span>,<span class="string">&quot;提示&quot;</span>,IDYES);</span><br><span class="line">                      ll d = <span class="built_in">pollard_rho</span>(test);</span><br><span class="line">                      <span class="built_in">printf</span>(<span class="string">&quot;合数:%lld其中的一个因子为%lld\n&quot;</span>, test, d);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;这是一个素数，不存在非平凡因子&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _getch();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">INPUTCENT</span><span class="params">(<span class="type">char</span> *pst, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">setlinestyle</span>(PS_SOLID | PS_ENDCAP_SQUARE, <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">setlinecolor</span>(<span class="number">0xFF5555</span>);</span><br><span class="line">        <span class="built_in">setfillcolor</span>(<span class="number">0x3a0a0a</span>);</span><br><span class="line">        <span class="built_in">fillrectangle</span>(x1, y1, x2, y2);</span><br><span class="line">        <span class="built_in">setbkmode</span>(TRANSPARENT);</span><br><span class="line">        <span class="built_in">settextcolor</span>(<span class="number">0xf4b1a4</span>);</span><br><span class="line">        <span class="built_in">settextstyle</span>(<span class="number">20</span>, <span class="number">0</span>, _T(<span class="string">&quot;楷体&quot;</span>));</span><br><span class="line">        RECT r = &#123; x1, y1, x2, y2 &#125;;</span><br><span class="line">        <span class="built_in">drawtext</span>(pst, &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">INPUTCENT</span><span class="params">(ll nums, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">setbkmode</span>(TRANSPARENT);</span><br><span class="line">        <span class="built_in">settextcolor</span>(<span class="number">0xEFFFFE</span>);</span><br><span class="line">        <span class="built_in">settextstyle</span>(<span class="number">15</span>, <span class="number">0</span>, _T(<span class="string">&quot;consolas&quot;</span>));</span><br><span class="line">        <span class="type">char</span> s[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(s, <span class="string">&quot;%lld&quot;</span>, nums);</span><br><span class="line">        RECT r = &#123; x1, y1, x2, y2 &#125;;</span><br><span class="line">        <span class="built_in">drawtext</span>(s, &amp;r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DrawMBT</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 第一行的数据</span></span><br><span class="line">        <span class="type">int</span> H = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第L列的数据</span></span><br><span class="line">        <span class="type">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">INPUTCENT</span>(<span class="string">&quot;x底数&quot;</span>, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">        L++;</span><br><span class="line">        <span class="built_in">INPUTCENT</span>(<span class="string">&quot;a次数&quot;</span>, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">        L++;</span><br><span class="line">        <span class="built_in">INPUTCENT</span>(<span class="string">&quot;与x同余&quot;</span>, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">        L++;</span><br><span class="line">        <span class="built_in">INPUTCENT</span>(<span class="string">&quot;n&quot;</span>, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">        L++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DrawPBT</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 第一行的数据</span></span><br><span class="line">        <span class="type">int</span> H = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第L列的数据</span></span><br><span class="line">        <span class="type">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">INPUTCENT</span>(<span class="string">&quot;Xi+1=f(x1)&quot;</span>, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">        L++;</span><br><span class="line">        <span class="built_in">INPUTCENT</span>(<span class="string">&quot;Xi+1=f(f(y1))&quot;</span>, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">        L++;</span><br><span class="line">        <span class="built_in">INPUTCENT</span>(<span class="string">&quot;c&quot;</span>, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">        L++;</span><br><span class="line">        <span class="built_in">INPUTCENT</span>(<span class="string">&quot;d=GCD(|x-y|,n)&quot;</span>, <span class="number">40</span> + <span class="number">190</span> * L, <span class="number">40</span> + H * <span class="number">20</span>, <span class="number">40</span> + <span class="number">190</span> * (L + <span class="number">1</span>), <span class="number">60</span> + H * <span class="number">20</span>);</span><br><span class="line">        L++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">INITFACE</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cleardevice</span>();</span><br><span class="line">        <span class="built_in">setlinecolor</span>(<span class="number">0XFD0392</span>);                                                 <span class="comment">// 蓝色</span></span><br><span class="line">        <span class="built_in">setlinestyle</span>(PS_SOLID | PS_ENDCAP_FLAT, <span class="number">2</span>);                             <span class="comment">// 最细的线宽度为2，其次为4</span></span><br><span class="line">        <span class="built_in">roundrect</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">798</span>, <span class="number">798</span>, <span class="number">12</span>, <span class="number">12</span>);                                      <span class="comment">// 圆角矩形</span></span><br><span class="line">        <span class="built_in">setlinestyle</span>(PS_SOLID | PS_ENDCAP_SQUARE, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">setlinecolor</span>(<span class="number">0x5555FF</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">39</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">line</span>(<span class="number">10</span>, <span class="number">40</span> + i * <span class="number">20</span>, <span class="number">790</span>, <span class="number">40</span> + i * <span class="number">20</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">line</span>(<span class="number">40</span> + i * <span class="number">190</span>, <span class="number">10</span>, <span class="number">40</span> + i * <span class="number">190</span>, <span class="number">782</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-根据用户的选择功能对其相应的输出"><a href="#3-2-根据用户的选择功能对其相应的输出" class="headerlink" title="3.2 根据用户的选择功能对其相应的输出"></a>3.2 根据用户的选择功能对其相应的输出</h2><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p> 在开发素数测试和大数分解的过程首先从容易的程序开始编写，从long long int到后来使用的黑科技__int128,再经过一遍遍的sf错误、答案错误的更正，现在才形成了大整数（现在拓展位了两万位）的程序。虽然对于大数（位数超过100位的情况）运行程序并没有那么的快，有因为不确定算法的原因可能造成的错误答案，但是还是形成了现在的代码。在过程中因为高进度算法的原因不能使用二进制移位操作而造成程序的SF错误，有因为大数不能通过普通的printf输出，还有多个环境下测试出来的结果不一样的问题。还有在实现本程序最后困扰我的问题，在本程序的开发过程中不断遇到了SF错误，大部分的SF错误都是应为某个数组，某个指针越界而造成的，但是本程序最后一个SF错误经过多天的思考，最后认定为栈的大小问题而造成的，通过<code>ulimit -s 102400</code>命令在linux系统下，成功的跑出。</p>
<h1 id="谢辞"><a href="#谢辞" class="headerlink" title="谢辞"></a>谢辞</h1><p> 我要感谢我的舍友，是他们在我改不出bug的时候鼓舞了我，是他们给我的精神上的支持才本程序才能成为现在这个版本。我还要感谢我的同学们，在我的疫情隔离在家的时候，是他们把课设的要求准确的传达给我。我还要感谢所有我咨询过问题的朋友们，是他们的一一解答所有的问题才能引刃而解。同时我要感谢我的老师，是老师的指导下，才能得以完成。</p>
]]></content>
      <categories>
        <category>数论</category>
        <category>素数</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>课设</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2022/07/25/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>线段树主要是用来动态维护并且对区间进行操作的，因为题目可能要求边操作边进行查询。<br>对于线段树题目主要考验的是代码能力以及使用变量去维护我们需要查询的信息。所以应当多写多练代码。</p>
<p>下面三道题目有且仅涉及到了单点操作，区间查询<br>pushup子节点更新父亲节点<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用子节点来更新父节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].v = <span class="built_in">max</span>(tr[u &lt;&lt; <span class="number">1</span>].v, tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>modify单点操作<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x表示要在x之后加入一个数据v</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 根节点的就返回(根节点的就是我们要修改的那个单点)</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == x &amp;&amp; tr[u].r == x)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].v = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不是根节点，那么这个节点就是父节点，那么继续递归找到根节点，然后用子节点来更新我们的父节点。</span></span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);  <span class="comment">// 操作完了区间就需要对区间维护的属性进行更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>query区间查询<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 查询区间主要包含的了两种情况</span></span><br><span class="line">    <span class="comment">// 1. 当前区间完全包含在了我们要查询的区间当中也就是ql &lt;= l &lt;= r &lt;= qr</span></span><br><span class="line">    <span class="comment">// 2. 当前区间与查询区间有交集 ql &lt;= l &lt;= qr &lt;= r （不等式的等号不同事成立）</span></span><br><span class="line">    <span class="comment">// 因为递归是二叉树形式递归所以我们要讨论端点和中值之间的关系</span></span><br><span class="line">    <span class="comment">// 2.1 l &lt;= mid, 那么就需要的查找当前区间的左孩子区间和当前区间的右孩子区间，反之只需要查找当前区间右孩子区间</span></span><br><span class="line">    <span class="comment">// 2.2 r &gt;= mid + 1 那么就需要的查找当前区间的左孩子区间和当前区间的右孩子区间，反之只需要查找当前区间左孩子区间</span></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;   <span class="comment">// mid是当前我们要查询的节点u的中值</span></span><br><span class="line">    <span class="comment">// 当前区间被完全包含在我们要查询的区间当中</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].v;</span><br><span class="line">    <span class="comment">// 有交集</span></span><br><span class="line">    <span class="type">int</span> v = <span class="number">-1</span>; <span class="comment">// 保存是孩子节点的最大值</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) v = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);    <span class="comment">// 要注意这里接口是[l,r]而不是[l,mid],因为我们始终要查询的是[l,r]区间,而不是孩子节点的区间端点</span></span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) v = <span class="built_in">max</span>(v,<span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="AcWing-1275-最大数"><a href="#AcWing-1275-最大数" class="headerlink" title="AcWing 1275. 最大数"></a><a href="https://www.acwing.com/problem/content/1277/">AcWing 1275. 最大数</a></h3><p>给定一个正整数数列 a1,a2,…,an，每一个数都在 0∼p−1 之间。</p>
<p>可以对这列数进行两种操作：</p>
<p>添加操作：向序列后添加一个数，序列长度变成 n+1；<br>询问操作：询问这个序列中最后 L 个数中最大的数是多少。<br>程序运行的最开始，整数序列为空。</p>
<p>一共要对整数序列进行 m 次操作。</p>
<p>写一个程序，读入操作的序列，并输出询问操作的答案。</p>
<p>输入格式<br>第一行有两个正整数 m,p，意义如题目描述；</p>
<p>接下来 m 行，每一行表示一个操作。</p>
<p>如果该行的内容是 Q L，则表示这个操作是询问序列中最后 L 个数的最大数是多少；</p>
<p>如果是 A t，则表示向序列后面加一个数，加入的数是 (t+a) mod p。其中，t 是输入的参数，a 是在这个添加操作之前最后一个询问操作的答案（如果之前没有询问操作，则 a=0）。</p>
<p>第一个操作一定是添加操作。对于询问操作，L&gt;0 且不超过当前序列的长度。</p>
<p>输出格式<br>对于每一个询问操作，输出一行。该行只有一个数，即序列中最后 L 个数的最大数。</p>
<p>数据范围<br>1≤m≤2×105,<br>1≤p≤2×109,<br>0≤t<p
输入样例：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 100</span><br><span class="line">A 97</span><br><span class="line">Q 1</span><br><span class="line">Q 1</span><br><span class="line">A 17</span><br><span class="line">Q 2</span><br><span class="line">A 63</span><br><span class="line">Q 1</span><br><span class="line">Q 1</span><br><span class="line">Q 3</span><br><span class="line">A 99</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">97</span><br><span class="line">97</span><br><span class="line">97</span><br><span class="line">60</span><br><span class="line">60</span><br><span class="line">97</span><br></pre></td></tr></table></figure><br>样例解释<br>最后的序列是 97,14,60,96。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>板题</strong><br>用一个变量维护我们需要查询的属性</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r; <span class="comment">// 表示区间的左端点和右端点</span></span><br><span class="line">    <span class="type">int</span> v;  <span class="comment">// 基本属性（本题是求的是最大值那我们就需要使用v表示区间的最大值来维护区间属性，有的属性并不能有单一的变量来维护则要多添加几个变脸来维护</span></span><br><span class="line">    <span class="comment">// node()&#123;&#125;</span></span><br><span class="line">    <span class="comment">// node(int l, int r):l(l),r(r),v(-1)&#123;&#125;</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>]; <span class="comment">// 线段树的节点个数开4倍</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u] = &#123;l,r&#125;;  <span class="comment">// 一定要把值先存起来，切忌不能放在return后面再保存值</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;   <span class="comment">// 线段树是一颗完全二叉树，其区间也划分的十分的均匀（正因为这种划分才使得所有的父节点一定有两个子节点）</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;  <span class="comment">// 根节点就要返回</span></span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);   <span class="comment">// 完全二叉树的属性 根节点从一开始编号，左孩子编号就是父节点编号的两倍，右孩子就是父节点的编号两倍加一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 查询区间主要包含的了两种情况</span></span><br><span class="line">    <span class="comment">// 1. 当前区间完全包含在了我们要查询的区间当中也就是ql &lt;= l &lt;= r &lt;= qr</span></span><br><span class="line">    <span class="comment">// 2. 当前区间与查询区间有交集 ql &lt;= l &lt;= qr &lt;= r （不等式的等号不同事成立）</span></span><br><span class="line">    <span class="comment">// 因为递归是二叉树形式递归所以我们要讨论端点和中值之间的关系</span></span><br><span class="line">    <span class="comment">// 2.1 l &lt;= mid, 那么就需要的查找当前区间的左孩子区间和当前区间的右孩子区间，反之只需要查找当前区间右孩子区间</span></span><br><span class="line">    <span class="comment">// 2.2 r &gt;= mid + 1 那么就需要的查找当前区间的左孩子区间和当前区间的右孩子区间，反之只需要查找当前区间左孩子区间</span></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;   <span class="comment">// mid是当前我们要查询的节点u的中值</span></span><br><span class="line">    <span class="comment">// 当前区间被完全包含在我们要查询的区间当中</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].v;</span><br><span class="line">    <span class="comment">// 有交集</span></span><br><span class="line">    <span class="type">int</span> v = <span class="number">-1</span>; <span class="comment">// 保存是孩子节点的最大值</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) v = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);    <span class="comment">// 要注意这里接口是[l,r]而不是[l,mid],因为我们始终要查询的是[l,r]区间,而不是孩子节点的区间端点</span></span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) v = <span class="built_in">max</span>(v,<span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用子节点来更新父节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].v = <span class="built_in">max</span>(tr[u &lt;&lt; <span class="number">1</span>].v, tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本题是修改（增加）某个区间中的一个值来影响区间max属性，当根究还是单点操作，所以单点操作也就是把其包含这个点的所有区间都做一遍操作是logn的</span></span><br><span class="line"><span class="comment">// x表示要在x之后加入一个数据v</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 根节点的就返回(根节点的就是我们要修改的那个单点)</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == x &amp;&amp; tr[u].r == x)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].v = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不是根节点，那么这个节点就是父节点，那么继续递归找到根节点，然后用子节点来更新我们的父节点。</span></span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);  <span class="comment">// 操作完了区间就需要对区间维护的属性进行更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, last = <span class="number">0</span>;    <span class="comment">// n表示数据量/当前序列尾部的位置（因为每次都需要在序列尾部加入数据）, last记录的上个数据每次加上的数据 == (t + a) % p</span></span><br><span class="line">    <span class="type">int</span> m, p;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,m);   <span class="comment">// 由于有m个操作，最极限的情况下每个操作都是加一个数，那么我们的区间右端点的最大为m</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            last = <span class="built_in">query</span>(<span class="number">1</span>,n-x+<span class="number">1</span>, n);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,last);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = ((ll)last + x ) % p;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, n + <span class="number">1</span>, v);</span><br><span class="line">            n ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AcWing-245-你能回答这些问题吗"><a href="#AcWing-245-你能回答这些问题吗" class="headerlink" title="AcWing 245. 你能回答这些问题吗"></a><a href="https://www.acwing.com/problem/content/246/">AcWing 245. 你能回答这些问题吗</a></h3><p>给定长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：</p>
<p>1 x y，查询区间 [x,y] 中的最大连续子段和，即 maxx≤l≤r≤y{∑i=lrA[i]}。<br>2 x y，把 A[x] 改成 y。<br>对于每个查询指令，输出一个整数表示答案。</p>
<p>输入格式<br>第一行两个整数 N,M。</p>
<p>第二行 N 个整数 A[i]。</p>
<p>接下来 M 行每行 3 个整数 k,x,y，k=1 表示查询（此时如果 x&gt;y，请交换 x,y），k=2 表示修改。</p>
<p>输出格式<br>对于每个查询指令输出一个整数表示答案。</p>
<p>每个答案占一行。</p>
<p>数据范围<br>N≤500000,M≤100000,<br>−1000≤A[i]≤1000<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">1 2 -3 4 5</span><br><span class="line">1 2 3</span><br><span class="line">2 2 -1</span><br><span class="line">1 3 2</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure></p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><ol>
<li>题目操作二告诉本题是单点操作是不需要懒标记的</li>
<li>如果使用子节点来更新父节点，也就是用什么变量来维护最大子段和</li>
</ol>
<p>首先一定需要的保存区间的最大连续子段和tmax，但是单使用两个子区间的tmax来更新父区间tmax是远远不过的。因为父区间的tmax不单单是可能等于左孩子的tmax或者右孩子tmax，还有可能子段和是横跨左右两个区间的。所以还需要最大前缀和与最大的后缀和。但是问题又来了仅靠当前的变量足够更新我们所有的属性吗？？比如前缀和的更新问题。区间的前缀和 == max(left.lmax, right.lmax) ?? 显然不是，区间的前缀和是可以延伸到有区间上去的，所以 lmax = max(left.lmax, left.sum + right.lmax)，所以还需要增加一个变量区间的总和。<br>所以我们一个区间节点要保存 <code>sum</code> <code>lmax</code> <code>rmax</code> <code>tmax</code>四个变量来更新我们需要查询的<code>最大子段和</code></p>
<h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="comment">// 维护区间子段和最大</span></span><br><span class="line">    <span class="type">int</span> sum, lmax, rmax, tmax;  <span class="comment">// sum区间和 lmax前缀和最大 rmax后缀和最大 tmax区间和最大</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N];   <span class="comment">// 记录每个点的数值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(node &amp;u, node &amp;l, node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;</span><br><span class="line">    u.lmax = <span class="built_in">max</span>(l.lmax, l.sum + r.lmax);</span><br><span class="line">    u.rmax = <span class="built_in">max</span>(r.rmax, r.sum + l.rmax);</span><br><span class="line">    u.tmax = <span class="built_in">max</span>(<span class="built_in">max</span>(l.tmax,r.tmax), l.rmax + r.lmax); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l == r) </span><br><span class="line">        tr[u] = &#123;l, r, w[r], w[r], w[r], w[r]&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l,r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        node res;</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="built_in">pushup</span>(res, left, right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == x &amp;&amp; tr[u].r == x)</span><br><span class="line">        tr[u] = &#123;x,x,v,v,v,v&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) </span><br><span class="line">            <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">if</span>(x &gt; mid)</span><br><span class="line">            <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="type">int</span> op , a, b;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;op,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a &gt; b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">            node res = <span class="built_in">query</span>(<span class="number">1</span>,a,b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res.tmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AcWing-246-区间最大公约数"><a href="#AcWing-246-区间最大公约数" class="headerlink" title="AcWing 246. 区间最大公约数"></a><a href="https://www.acwing.com/problem/content/247/">AcWing 246. 区间最大公约数</a></h3><p>给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：</p>
<p>C l r d，表示把 A[l],A[l+1],…,A[r] 都加上 d。<br>Q l r，表示询问 A[l],A[l+1],…,A[r] 的最大公约数(GCD)。<br>对于每个询问，输出一个整数表示答案。</p>
<p>输入格式<br>第一行两个整数 N,M。</p>
<p>第二行 N 个整数 A[i]。</p>
<p>接下来 M 行表示 M 条指令，每条指令的格式如题目描述所示。</p>
<p>输出格式<br>对于每个询问，输出一个整数表示答案。</p>
<p>每个答案占一行。</p>
<p>数据范围<br>N≤500000,M≤100000,<br>1≤A[i]≤1018,<br>|d|≤1018<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 3 5 7 9</span><br><span class="line">Q 1 5</span><br><span class="line">C 1 5 1</span><br><span class="line">Q 1 5</span><br><span class="line">C 3 3 6</span><br><span class="line">Q 2 4</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>操作一看似是一个区间操作问题但是如果使用差分数组的话，我们可以将其转化为单点操作</p>
<h4 id="一、将区间操作转换成了单点操作"><a href="#一、将区间操作转换成了单点操作" class="headerlink" title="一、将区间操作转换成了单点操作"></a>一、将区间操作转换成了单点操作</h4><p>原数组为 a1 a2 a3 a4 … an<br>前缀和数组 为 s1 s2 s3 s4 … sn<br>差分数组为 d1 d2 d3 d4 … dn = s1， s2 - s1, s3 - s2, … , sn - sn-1<br>sum[l,r] = dr + dr<br>假如要想在[l,r]区间加上一个d = dl + d, dr+1 - d</p>
<h4 id="二、gcd更相减损法"><a href="#二、gcd更相减损法" class="headerlink" title="二、gcd更相减损法"></a>二、gcd更相减损法</h4><p> gcd(a, b) = gcd(a, b - a)<br> 推广成为gcd(a1, a2, a3, … , an) = gcd(a1, a2 - a1, a3 - a2, …, an - an-1)<br> 这样就可以与差分数组结合在一起</p>
<p> 证明更相减损法的正确性<br> 首先证明<code>gcd(a1, a2, a3, ... , an)</code> &lt;= <code>gcd(a1, a2 - a1, a3 - a2, ..., an - an-1)</code><br> <code>gcd(a1, a2, a3, ... , an)</code> == <code>d</code>, <code>d</code>是这个序列的最大公约数所以一定也是<code>a1</code> <code>a2</code> <code>a3</code>…的公约数，那么<code>d</code>同理也是<code>a2-a1</code> <code>a3 - a2</code> …的公约数，所以知道左边序列的最大公约数是右边序列的任意一个公约数，所以证得<code>gcd(a1, a2, a3, ... , an)</code> &lt;= <code>gcd(a1, a2 - a1, a3 - a2, ..., an - an-1)</code></p>
<p> 同理 <code>gcd(a1, a2, a3, ... , an)</code> &gt;= <code>gcd(a1, a2 - a1, a3 - a2, ..., an - an-1)</code></p>
<p>差分数组<br>a数组是b数组的前缀和数组，b是a的差分数组<br>通过gcd更相减损法维护差分数组最后可以转换为<br>gcd[l,r] = gcd(a[l], a[l+1] - a[l], … , a[r] - a[r-1]) = gcd(a[l], b[l+1], b[l+2], … , b[r]) = gcd(a[l],gcd(b[l+1], … , b[r])) = 由于线段树维护的是差分数组,a是前缀和数组，所以a[l]是我们1～l的sum = gcd(l.sum, gcd(b[l+1], … , b[r]));<br>所以pushup操作是维护的<code>gcd(b[l+1], ... , b[r])</code><br>最后我们要查询的区间最大gcd是通过<code>sum</code> + <code>gcd(b[l+1], ... , b[r])</code> 来维护</p>
<h4 id="三、维护区间属性"><a href="#三、维护区间属性" class="headerlink" title="三、维护区间属性"></a>三、维护区间属性</h4><ol>
<li>区间和sum</li>
<li>区间的最大公约数</li>
</ol>
<h3 id="CODE-2"><a href="#CODE-2" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll sum, d;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般如果使用多变量维护区间属性重载两个pushup比较方便</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(node &amp;u, node &amp;l, node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;</span><br><span class="line">    u.d = <span class="built_in">gcd</span>(l.d, r.d); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll b = a[r] - a[r<span class="number">-1</span>];</span><br><span class="line">        tr[u] = &#123;l,r,b,b&#125;;  <span class="comment">// 差分数组内部点值 a数组是b数组的前缀和数组，b是a的差分数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r;   </span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l , r);</span><br><span class="line">        node res;</span><br><span class="line">        <span class="built_in">pushup</span>(res, left, right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 修改当点 a[l] + v, a[r + 1] - v</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l == x &amp;&amp; tr[u].r == x)</span><br><span class="line">    &#123;</span><br><span class="line">        ll b = tr[u].sum + v;</span><br><span class="line">        tr[u] = &#123;x,x,b,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">if</span>(x &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,l);</span><br><span class="line">            node right = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">if</span>(l + <span class="number">1</span> &lt;= r)</span><br><span class="line">                right = <span class="built_in">query</span>(<span class="number">1</span>,l + <span class="number">1</span>, r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">abs</span>(<span class="built_in">gcd</span>(left.sum,right.d)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ll v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;v);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,v);</span><br><span class="line">            <span class="keyword">if</span>(r + <span class="number">1</span> &lt;= n) <span class="built_in">modify</span>(<span class="number">1</span>,r + <span class="number">1</span>, -v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带有区间修改的（懒标记的线段树）"><a href="#带有区间修改的（懒标记的线段树）" class="headerlink" title="带有区间修改的（懒标记的线段树）"></a>带有区间修改的（懒标记的线段树）</h3><p>区间修改当然是可以依照我们前面的单点修改去操作，也就是一遍遍的遍历到根节点，然后用根节点去更新父亲节点。时间复杂度是O（nlogn）的<br>这样子时间复杂度甚至还比O（n）要大（比暴力更大），这显然是我们不能接受的。所以才会引入懒标记（延迟标记）来应付我们的查询。懒标记的思想可以类比到我们的区间查询。<br> <img src="../../themes/butterfly/source/img/懒标记的解释.png" alt="懒标记的解释"></p>
<h3 id="AcWing-243-一个简单的整数问题2"><a href="#AcWing-243-一个简单的整数问题2" class="headerlink" title="AcWing 243.一个简单的整数问题2"></a><a href="https://www.acwing.com/problem/content/description/244/">AcWing 243.一个简单的整数问题2</a></h3><p>给定一个长度为 N 的数列 A，以及 M 条指令，每条指令可能是以下两种之一：</p>
<p>C l r d，表示把 A[l],A[l+1],…,A[r] 都加上 d。<br>Q l r，表示询问数列中第 l∼r 个数的和。<br>对于每个询问，输出一个整数表示答案。</p>
<p>输入格式<br>第一行两个整数 N,M。</p>
<p>第二行 N 个整数 A[i]。</p>
<p>接下来 M 行表示 M 条指令，每条指令的格式如题目描述所示。</p>
<p>输出格式<br>对于每个询问，输出一个整数表示答案。</p>
<p>每个答案占一行。</p>
<p>数据范围<br>1≤N,M≤105,<br>|d|≤10000,<br>|A[i]|≤109<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 5</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">Q 4 4</span><br><span class="line">Q 1 10</span><br><span class="line">Q 2 4</span><br><span class="line">C 3 6 3</span><br><span class="line">Q 2 4</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">55</span><br><span class="line">9</span><br><span class="line">15</span><br></pre></td></tr></table></figure></p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>虽然说区间加和问题可以用差分思想转换成单点操作但是我们也可以很暴力使用pushdown对区间进行操作</p>
<h3 id="CODE-3"><a href="#CODE-3" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll w[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    ll sum, add;    <span class="comment">// add是区间的懒标记，表示以u为根的树给其子节点都加上一个数值add（注意不给根节点加）</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用父节点更新子节点信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].add)</span><br><span class="line">    &#123;</span><br><span class="line">        node &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">        left.sum += (left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        left.add += root.add;</span><br><span class="line">        right.sum += (right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;   <span class="comment">// 下放之后一定要清空否则会重复累加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r, tr[u].sum = w[r], tr[u].add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r;  </span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 我们的懒标记是延迟标记是为了避免做无用功，所以在我们查询的操作的使用才会对其子节点的区间的懒标记进行更新</span></span><br><span class="line">    <span class="comment">// 每次从父节点到子节点的时候懒标记都下放，因为只要树要继续往下遍历的话那么说明子区间就需要被查询，所以我们懒标记下放</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line"></span><br><span class="line">        ll res = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r) + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l , r);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum += (tr[u].r - tr[u].l + <span class="number">1</span>) * d;</span><br><span class="line">        tr[u].add += d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r,d);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l , r,d);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;w[i]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> l, r ,d;</span><br><span class="line">        <span class="keyword">while</span>(m --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op, &amp;l, &amp;r);</span><br><span class="line">            <span class="keyword">if</span>(*op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,l,r));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d);</span><br><span class="line">                <span class="built_in">modify</span>(<span class="number">1</span>,l,r,d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AcWing-1277-维护序列"><a href="#AcWing-1277-维护序列" class="headerlink" title="AcWing 1277. 维护序列"></a><a href="https://www.acwing.com/problem/content/description/1279/">AcWing 1277. 维护序列</a></h3><p>老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。</p>
<p>有长为 N 的数列，不妨设为 a1,a2,…,aN。</p>
<p>有如下三种操作形式：</p>
<p>把数列中的一段数全部乘一个值；<br>把数列中的一段数全部加一个值；<br>询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模 P 的值。<br>输入格式<br>第一行两个整数 N 和 P；</p>
<p>第二行含有 N 个非负整数，从左到右依次为 a1,a2,…,aN；</p>
<p>第三行有一个整数 M，表示操作总数；</p>
<p>从第四行开始每行描述一个操作，输入的操作有以下三种形式：</p>
<p>操作 1：1 t g c，表示把所有满足 t≤i≤g 的 ai 改为 ai×c；<br>操作 2：2 t g c，表示把所有满足 t≤i≤g 的 ai 改为 ai+c；<br>操作 3：3 t g，询问所有满足 t≤i≤g 的 ai 的和模 P 的值。<br>同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。</p>
<p>输出格式<br>对每个操作 3，按照它在输入中出现的顺序，依次输出一行一个整数表示询问结果。</p>
<p>数据范围<br>1≤N,M≤105,<br>1≤t≤g≤N,<br>0≤c,ai≤109,<br>1≤P≤109<br>输入样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 43</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">5</span><br><span class="line">1 2 5 5</span><br><span class="line">3 2 4</span><br><span class="line">2 3 7 9</span><br><span class="line">3 1 3</span><br><span class="line">3 4 7</span><br></pre></td></tr></table></figure><br>输出样例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">35</span><br><span class="line">8</span><br></pre></td></tr></table></figure><br>样例解释<br>初始时数列为 {1,2,3,4,5,6,7}；<br>经过第 1 次操作后，数列为 {1,10,15,20,25,6,7}；<br>对第 2 次操作，和为 10+15+20=45，模 43 的结果是 2；<br>经过第 3 次操作后，数列为 {1,10,24,29,34,15,16}；<br>对第 4 次操作，和为 1+10+24=35，模 43 的结果是 35；<br>对第 5 次操作，和为 29+34+15+16=94，模 43 的结果是 8。</p>
<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p><strong>多懒标记问题</strong><br>本题对区间修改有两个操作，一个是乘法操作，另外一个是加法操作。所以需要维护两个懒标记。<code>add</code> <code>mul</code></p>
<p>多懒标记更新，尽量要使得公式能统一一个形式<br>本题虽然是每次操作都是乘法或者加法，但是为了统一形式我们操作是无论加法和乘法都转换成<code>x * a + b</code> 的形式，<code>a = 1</code>时候为加法操作, <code>b = 0</code>为乘法操作，<br>如果多次对一个区间进行操作的话我们可以简化公式为<br>第一次对区间操作 <code>x * a + b</code><br>第二次对区间操作<code>sum * c + d</code> &lt;=&gt; <code>(x * a + b) * c + d</code> &lt;=&gt; <code>x * a * c + b * c + d</code> &lt;=&gt;<code>x * (a * c) + (b * c + d)</code><br>所以知道原<code>add(b)</code>= <code>b * c + d</code>, 原<code>mul(a)</code> = <code>a * c</code></p>
<p>如果是先加后乘的形式<br><code>(x + a) * b</code><br>第一次操作为<code>(x + a) * b</code><br>第二次操作为<code>(sum + c) * d</code> &lt;=&gt; <code>((x + a) * b + c) * d</code> &lt;=&gt; <code>(x * b + a * b + c) * d</code> &lt;=&gt;<code>x * b * d + a * b * d + c * d</code> 这样子我们原数值sum都有一系列的系数了，很难更新我们当前的节点值</p>
<h3 id="CODE-4"><a href="#CODE-4" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,a,n) for (int i=n-1;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eb emplace_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">int</span>&gt; BI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"><span class="comment">// head</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum, add, mul;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m, p;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// x * a + b + c = x * a + (b + c)</span></span><br><span class="line"><span class="comment">// (x * a + b) * c = x * a * c + b * c;</span></span><br><span class="line"><span class="comment">// 统一形式</span></span><br><span class="line"><span class="comment">// sum * c + d = (x * a + b) * c + d = x * (a * c) + (c*b + d)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">eval</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = ((ll)tr[u].sum * a + b * (ll)(tr[u].r - tr[u].l + <span class="number">1</span>)) % p;</span><br><span class="line">    tr[u].add = ((ll)a *  tr[u].add + b) % p;</span><br><span class="line">    tr[u].mul = ((ll)tr[u].mul * a) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = ((ll)tr[u &lt;&lt; <span class="number">1</span>]. sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(u &lt;&lt; <span class="number">1</span>, tr[u].mul, tr[u].add);</span><br><span class="line">    <span class="built_in">eval</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tr[u].mul, tr[u].add);</span><br><span class="line">    tr[u].add = <span class="number">0</span>;</span><br><span class="line">    tr[u].mul = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u ,<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r;</span><br><span class="line">        tr[u].add = <span class="number">0</span>, tr[u].mul = <span class="number">1</span>;</span><br><span class="line">        tr[u].sum = w[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].l = l, tr[u].r = r;</span><br><span class="line">        tr[u].add = <span class="number">0</span>, tr[u].mul = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid =  l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span> , r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l ,<span class="type">int</span> r, <span class="type">int</span> a, <span class="type">int</span> b)</span>  <span class="comment">// x * a + b</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">eval</span>(u, a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].r + tr[u].l &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, a, b);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, a, b);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid) res = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span>(r &gt; mid) res = ((ll)res + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l , r)) % p;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op,l,r,a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;a);</span><br><span class="line">            b = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,r,a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;b);</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,r,a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,l,r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模版</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数据结构笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2022/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h3><p>不太理解什么是可靠传输？<br> 海明码这类的纠错编码，虽然有纠错能力，但是纠错能力有限。比如<code>3</code>码距的海明码只能检验<code>两</code>位错，纠正<code>一</code>位错。如果出现两位错就无法完全的纠错了。所以纠错编码仍然不是可靠性传输。</p>
]]></content>
      <categories>
        <category>考研</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>负环</title>
    <url>/2022/07/20/%E8%B4%9F%E7%8E%AF/</url>
    <content><![CDATA[<h2 id="负环"><a href="#负环" class="headerlink" title="负环"></a>负环</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>权值之和为负的环称为负环（与之相对应的就是正环）</p>
<h3 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h3><ol>
<li>方法一：统计每个点入队的次数，如果某个点入队n次，则说明存在负环（bellman-ford)</li>
<li>构造一个虚拟源点与当前图上的每一个点相连，统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于n，则说明存在环.</li>
</ol>
<p>方法一的最坏情况比较糟糕，因为假如一个环1-2-3-4-n-1,一共有n个顶点，第一次这个圈所有点都进入队列当中仅当这个圈遍历到<code>n-1</code>圈才会出现某个点入队n次的情况 O（n*(n-1) + 1) = O(n^2)<br>方法二则是O（n）的，因为如果1-n上路径超过了n-1条边必然会有环</p>
<h3 id="例题spfa判断负环"><a href="#例题spfa判断负环" class="headerlink" title="例题spfa判断负环"></a>例题<a href="https://www.acwing.com/problem/content/854/">spfa判断负环</a></h3><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。</p>
<p>请你判断图中是否存在负权回路。</p>
<p>输入格式<br>第一行包含整数 n 和 m。</p>
<p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p>
<p>输出格式<br>如果图中存在负权回路，则输出 Yes，否则输出 No。</p>
<p>数据范围<br>1≤n≤2000,<br>1≤m≤10000,<br>图中涉及边长绝对值均不超过 10000。</p>
<p>Input<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 -1</span><br><span class="line">2 3 4</span><br><span class="line">3 1 -4</span><br></pre></td></tr></table></figure><br>Output<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>由于从某个起点开始的最短路径上不一定是含有负环的，但是我们需要判断图上的是否有负环怎么办？？<br><strong>构造虚拟源点</strong>， 虚拟源点向每个点都连一条边权为0的边<code>初始化dist[i] = 0</code>，要是有负环这个虚拟源点必然包含在其中。这里的dist数组就是维护到虚拟源点的最短距离</p>
<h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="comment">//把所有点放进队列里面</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="玄学优化"><a href="#玄学优化" class="headerlink" title="玄学优化"></a>玄学优化</h3><p>由于很多题目都出现了卡队列形式的spfa，当前呈现了spfa已死的情况，所以spfa还需要一些玄学优化，将时间复杂度降到O（nm）以下</p>
<h3 id="节点更新超过了n次直接判定有负环"><a href="#节点更新超过了n次直接判定有负环" class="headerlink" title="节点更新超过了n次直接判定有负环"></a>节点更新超过了n次直接判定有负环</h3>]]></content>
      <tags>
        <tag>负环</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学 个人易错点</title>
    <url>/2022/09/25/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%AA%E4%BA%BA%E6%98%93%E9%94%99%E7%82%B9/</url>
    <content><![CDATA[<h2 id="无穷大与无穷小"><a href="#无穷大与无穷小" class="headerlink" title="无穷大与无穷小"></a>无穷大与无穷小</h2><h3 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h3><ul>
<li><strong>两个</strong>无穷大相乘一定等于无穷大</li>
<li>无穷大与有界变量的和一定为无穷大</li>
</ul>
<h3 id="无穷小"><a href="#无穷小" class="headerlink" title="无穷小"></a>无穷小</h3><ul>
<li>有限个无穷小之和一定为无穷小</li>
<li>有限个无穷小之积一定为无穷小</li>
<li>无穷小与有界量之积仍是无穷小</li>
</ul>
<h2 id="等价无穷小代换"><a href="#等价无穷小代换" class="headerlink" title="等价无穷小代换"></a>等价无穷小代换</h2><p> $x-sinx$ ~ $arcsinx - x$ ~ ${x^3}\over {6}$<br> $x-tanx$ ~ $arctanx - x$ ~ ${x^3}\over {6}$</p>
]]></content>
      <categories>
        <category>考研</category>
        <category>高等数学</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学总结</title>
    <url>/2022/09/17/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="高等数学总结"><a href="#高等数学总结" class="headerlink" title="高等数学总结"></a>高等数学总结</h1><p><a href="http://course.sdu.edu.cn/Download/1ac3f6ef-3237-4579-9f3e-2d62ae413e4a.pdf">高等数学常用公式</a></p>
<h2 id="第一章-函数、极限、连续"><a href="#第一章-函数、极限、连续" class="headerlink" title="第一章 函数、极限、连续"></a>第一章 函数、极限、连续</h2><h3 id="一、函数"><a href="#一、函数" class="headerlink" title="一、函数"></a>一、函数</h3><h3 id="二、极限"><a href="#二、极限" class="headerlink" title="二、极限"></a>二、极限</h3><h4 id="极限的存在法则"><a href="#极限的存在法则" class="headerlink" title="极限的存在法则"></a>极限的存在法则</h4><ol>
<li><p>夹逼准则<br>n项和</p>
</li>
<li><p>单调有界<br>1）证明数列存在单调有界<br>2）计算出<code>a = f(a)</code></p>
</li>
</ol>
<h4 id="无穷大与无穷小"><a href="#无穷大与无穷小" class="headerlink" title="无穷大与无穷小"></a>无穷大与无穷小</h4><p>(1) 无穷大的比较  </p>
<ul>
<li>当$x\rightarrow +\infty$,有$\ln^\alpha{x} \ll x^\beta \ll a^x$  </li>
<li>当$b\rightarrow \infty, \ln^\alpha{n} \ll n^\beta \ll \alpha^n \ll n! \ll n^n$ </li>
</ul>
<h5 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h5><ul>
<li><strong>两个</strong>无穷大相乘一定等于无穷大</li>
<li>无穷大与有界变量的和一定为无穷大</li>
</ul>
<h4 id="无穷小"><a href="#无穷小" class="headerlink" title="无穷小"></a>无穷小</h4><ul>
<li>有限个无穷小之和一定为无穷小</li>
<li>有限个无穷小之积一定为无穷小</li>
<li>无穷小与有界量之积仍是无穷小</li>
</ul>
<h4 id="求解极限的方法"><a href="#求解极限的方法" class="headerlink" title="求解极限的方法"></a>求解极限的方法</h4><p>利用基本极限求极限  </p>
<ol>
<li><p>常用的基本极限<br>基础篇 P17<br>经过题目总结出来的基本极限<br>$\lim\limits_{x\to 0} x\ln{|x|} = 0$<br><strong>等价无穷小代换</strong><br>$1-\cos^\alpha x$ ~ $\frac{\alpha}{2}x^2$<br>$x-\sin(x)$ ~ $\arcsin(x) - x$ ~$\frac{1}{6} x^3$<br>$\tan(x) - x$ ~ $x - \arctan(x)$ ~ $\frac{1}{3}x^3$<br>$x - \ln{1+x}$ ~ $\frac{1}{2}x^2$</p>
</li>
<li><p>$1^\infty$ 型极限常用结论<br>知道$1^\infty$ 是不定式，所以要化成$e^x$ 的型。具体步骤<br>当$\lim \alpha(x) = 0$, $\lim \beta(x) = \infty$, $\lim \alpha(x)\beta(x) = A$<br>(1) 写成标准型 $\lim[1+\alpha(x)]^{\beta(x)}$<br>(2) 求出A的值 $\lim \alpha(x)\beta(x) = A$, $原式 = e^A$ </p>
</li>
<li><p>有理运算法则求极限<br>要注意三条经常使用的结论</p>
</li>
<li>洛必达法则求极限</li>
<li><p>泰勒公式<br>有必要去记忆（经常不记得）</p>
</li>
<li><p>利用夹逼原理求极限<br>常用的基本不等式有两个</p>
<ul>
<li>$\sin(x) &lt; x &lt; \tan(x), x\in(0,\frac{\pi}{2})$ </li>
<li>$\frac{x}{x + 1} &lt; \ln(1+X) &lt; x, x \in(0,+\infty)$<br>-&gt; $\frac{1}{x+1} &lt; \ln(x+1) - \ln(x) &lt; \frac{1}{x}$<br>例题 $\lim\limits_{x\to \infty} (\frac{1}{n+1} + \frac{1}{n+2} + … + \frac{1}{2n})$ 求极限<br>法一：使用第二条基本不等式推论来使用夹逼原理<br>法二：使用定积分的定义来求极限</li>
</ul>
</li>
<li><p>利用单调有界准则求极限<br><strong>题目主要会出现递推公式的情况下</strong></p>
</li>
</ol>
<ul>
<li><ol>
<li>利用单调有界证明极限存在。比如当一个函数有下届并且单调减的话，说明这个函数一定存在极限值</li>
</ol>
</li>
<li><ol>
<li>设极限值，将极限值带入到递推公式当中</li>
</ol>
</li>
</ul>
<ol>
<li>利用定积分定义求极限<ul>
<li>如果函数是<code>n</code>阶可导的话，那么用洛必达法则的话最多可以用到<code>n-1</code>阶</li>
<li>如果函数是<code>n</code>阶<code>连续</code>可导的话，那么洛必达法则最多可以用到<code>n</code>阶</li>
</ul>
</li>
</ol>
<h3 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h3><h4 id="极限中参数的确定（对应吉米P18）"><a href="#极限中参数的确定（对应吉米P18）" class="headerlink" title="极限中参数的确定（对应吉米P18）"></a>极限中参数的确定（对应吉米P18）</h4><p>  对于这类题，因为告诉了极限存在，所以需要再找出来一个存在的值，利用高阶无穷大和高阶无穷小的极限性质找参数的取值</p>
<h3 id="三、连续"><a href="#三、连续" class="headerlink" title="三、连续"></a>三、连续</h3><h4 id="连续性定义"><a href="#连续性定义" class="headerlink" title="连续性定义"></a>连续性定义</h4><p> 要注意的是连续定义在某个去心邻域当中（也就是说当前点有可能不存在定义）</p>
<h4 id="间断点"><a href="#间断点" class="headerlink" title="间断点"></a>间断点</h4><ul>
<li><p>间断点的计算（不太会讨论啥时候要左右极限啥时候不用讨论左右极限直接求出极限）<br><strong>第一类间断点</strong><br>首先， <strong>左右极限都存在</strong>。如果左右极限都相等但是不等于函数值的话叫做<strong>可去间断点</strong>。如果左右极限不相等的话就是<strong>跳跃间断点</strong>。<br><strong>第二类间断点</strong><br>首先，<strong>左右极限至少有一个不存在</strong>，要注意的是不存在不代表极限值为无穷，也有可能是在振荡。如果左右极限都为无穷的话，就是<strong>无穷间断点</strong>。如果左右极限都是振荡的性质，就是<strong>振荡间断点</strong>。</p>
<p>注意的是第二类间断点，不是除了无穷间断点就是振荡间断点。因为有可能一遍是振荡另外一个方向是趋向于无穷的。</p>
</li>
</ul>
<h4 id="连续性的运算和性质"><a href="#连续性的运算和性质" class="headerlink" title="连续性的运算和性质"></a>连续性的运算和性质</h4><p>区别定义域和定义区间</p>
<ul>
<li>定义域是是的函数有定义的点的集合</li>
<li>定义区间是定义域的子区间，所谓区间就是不能为<code>点</code></li>
</ul>
<h4 id="连续性定理"><a href="#连续性定理" class="headerlink" title="连续性定理"></a>连续性定理</h4><ul>
<li>零点定理<br>  设f(x)在闭区间[a,b]上连续，且f(a)*f(b) &lt; 0,则至少存在一个点$\xi \in (a,b), 使得f(\xi) = 0$</li>
</ul>
<p><strong>重要的定理</strong>： 初等函数在其定义区间内都是连续的<br>如: $f(x) = \sqrt{\cos x - 1}$ 这个定义域只有离散的点，也就是说其定义区间为空集</p>
<h2 id="第二章-导数与微分"><a href="#第二章-导数与微分" class="headerlink" title="第二章 导数与微分"></a>第二章 导数与微分</h2><h3 id="连续、可导、可微之间的关系"><a href="#连续、可导、可微之间的关系" class="headerlink" title="连续、可导、可微之间的关系"></a>连续、可导、可微之间的关系</h3><ul>
<li>f(x) 在 $x_0$的某个领域上可导，推导不出来两个易错结论  <ol>
<li>$\dot{f(x)}$ 在 $x_0$ 处连续，只能推出低一阶的连续</li>
<li>$\lim\limits_{x \to x_0}\dot{f(x)} 存在$</li>
</ol>
</li>
</ul>
<h3 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h3><ul>
<li>设$\psi(x) 连续则 f(x) = \psi(x)|x-a|在的x == a 处可导的话 \Leftrightarrow \psi(a) == 0$</li>
<li>无穷小和无穷大在一线函数当中总是能相互转换的，如$x \rightarrow \infty: e^x \rightarrow e^{-x}$</li>
<li>导数不会改变周期函数的周期性</li>
</ul>
<h2 id="第三章-微分中值定理及导数应用"><a href="#第三章-微分中值定理及导数应用" class="headerlink" title="第三章 微分中值定理及导数应用"></a>第三章 微分中值定理及导数应用</h2><h3 id="一、微分中值定理"><a href="#一、微分中值定理" class="headerlink" title="一、微分中值定理"></a>一、微分中值定理</h3><p><strong>微分中值定理的主要意义在于联系起来函数值和导数值</strong></p>
<ul>
<li>费马定理</li>
<li>罗尔定理<br>（1） 在闭区间[a,b]上连续<br>（2） 在开区间(a,b)上可导<br>（3） f(a) = f(b)<br><strong>则在(a,b)内至少存在一点 $\xi,使得f^\prime(\xi) = 0$</strong></li>
<li>拉格朗日中值定理<br>(1） 在闭区间[a,b]上连续<br>(2) 在开区间(a,b)上可导<br><strong>则在(a,b)内至少存在一点$\xi, 使得 f(b) - f(a) = f^\prime(\xi)(b-a)$</strong></li>
<li>柯西中值定理 如果f(x),F(x)满足一下条件：<br>(1） 在闭区间[a,b]上连续<br>(2) 在开区间(a,b)上可导,且$F^\prime(x)在(a,b)内每一点都不为0$<br><strong>则在(a,b)内至少存在一点$\xi,使得$</strong>  <script type="math/tex; mode=display">\frac{f(b)-f(a)}{F(b)-F(a)} = \frac{f^\prime(\xi)}{F^\prime(\xi)}</script></li>
</ul>
<h3 id="二、导数应用"><a href="#二、导数应用" class="headerlink" title="二、导数应用"></a>二、导数应用</h3><h4 id="5-曲线的渐近线"><a href="#5-曲线的渐近线" class="headerlink" title="5. 曲线的渐近线"></a>5. 曲线的渐近线</h4><p><strong>水平渐近线</strong>  </p>
<script type="math/tex; mode=display">\lim_{x\to \infty} f(x) = A (OR \lim_{x\to +\infty} f(x) = A, OR\lim_{x\to -\infty} f(x) = A)</script><p><strong>垂直渐近线</strong>  </p>
<script type="math/tex; mode=display">\lim_{x\to x_0}f(x) = \infty(OR\lim_{x\to x_0^-}f(x) = \infty OR \lim_{x\to x_0^+}f(x) = \infty)</script><p><strong>斜渐近线</strong>  </p>
<script type="math/tex; mode=display">\lim_{x\to \infty} \frac{f(x)}{x} = a 且\lim_{x\to \infty}(f(x) - ax) = b(OR  x \rightarrow -\infty / x \rightarrow -\infty), 则 y = ax + b</script><h3 id="第三章题目总结"><a href="#第三章题目总结" class="headerlink" title="第三章题目总结"></a>第三章题目总结</h3><p><strong>渐近线</strong>  </p>
<ul>
<li>当函数存在一个斜渐近线的话，一定会有形如$f(x) = ax + b + \alpha(x),\alpha(x) \rightarrow 0$</li>
<li>找垂直渐近线的时候，就是找x是否在一个有限值当中，函数值不存在</li>
</ul>
<h2 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h2><h3 id="吉米多维奇"><a href="#吉米多维奇" class="headerlink" title="吉米多维奇"></a>吉米多维奇</h3><ul>
<li>证明连续性 84（page 23/33）87（page 24/34）, 主要在于不是很会函数没有给出式子的题目，根据极限讨论x的大小求出函数的等式。</li>
<li>根据极限求函数等式 </li>
</ul>
<h2 id="第四章-不定积分"><a href="#第四章-不定积分" class="headerlink" title="第四章 不定积分"></a>第四章 不定积分</h2><p>常用公式</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/390928056">三角函数公式汇总</a></li>
<li>常用的三种变量代换<script type="math/tex; mode=display">\sqrt{a^2 - x^2}, 令x = a\sin t(OR  a\cos t</script><script type="math/tex; mode=display">\sqrt{a^2 + x^2}, 令x = a\tan t</script><script type="math/tex; mode=display">\sqrt{x^2 - a^2}, 令x = a\sec t</script></li>
<li>高阶分式展开<script type="math/tex; mode=display">\frac{1 + x + x^2}{x (1 + x^2)} = \frac{A}{x} + \frac{Bx + C}{x^2 + 1}, 然后通过分式相加根据等式一一对应的到参数的值</script></li>
</ul>
<h2 id="第五章-定积分"><a href="#第五章-定积分" class="headerlink" title="第五章 定积分"></a>第五章 定积分</h2><h3 id="定积分的概念题目"><a href="#定积分的概念题目" class="headerlink" title="定积分的概念题目"></a>定积分的概念题目</h3><p>由于定积分可以写成合式的极限问题，所以考其概念的题目的时候的一半会要我们求合式的极限<br>例 </p>
<script type="math/tex; mode=display">\lim_{x\to \infty} (\frac{1}{n + 1} + \frac{1}{n + 2} + \frac{1}{n + n})=</script><p>首先我们一定是先进行夹逼的，但是构造出来的两端数值不等，所以夹逼很难求解。<br>然后我们就需要提出来可爱因子$\frac{1}{n}$,提出来之后看是否能看出来原函数的式子f(x)进行求解</p>
<h3 id="定积分存在的充分条件"><a href="#定积分存在的充分条件" class="headerlink" title="定积分存在的充分条件"></a>定积分存在的充分条件</h3><ul>
<li>定理 $f(x), [a,b]上连续的话，则\int_a^b f(x) dx$ 必定存在</li>
<li>定理 $f(x),[a,b]$上有界，且只有又有限个间断点（很明显这个间断点不能是无穷间断点, …</li>
<li>定理 $f(x),[a,b]$上只有有限个第一类间断点,…(但是这个结论是把条件放小了些许，也就是满足这个条件的定积分一定存在，但是不满足也有可能存在)</li>
</ul>
<h3 id="定积分的几何意义"><a href="#定积分的几何意义" class="headerlink" title="定积分的几何意义"></a>定积分的几何意义</h3><p>对于$\int_a^b f(x)dx$ 这类的定积分的几何意义是，其与x轴之间围成的面积。这里的要<strong>注意</strong>的是$a \le b$</p>
<h3 id="不等式性质"><a href="#不等式性质" class="headerlink" title="不等式性质"></a>不等式性质</h3><ul>
<li>$[a,b] 上 f(x) \le g(x)， \int_a^b f(x)dx \le \int_a^b g(x)dx$</li>
<li>M,m分别是f(x)在[a,b]上的最大值和最小值，$m(b-a) \le \int_a^b f(x) dx \le M(b-a)$</li>
<li>$|\int_a^b f(x) dx| \le \int_a^b |f(x)|dx$</li>
</ul>
<h3 id="积分中值定理"><a href="#积分中值定理" class="headerlink" title="积分中值定理"></a>积分中值定理</h3><ul>
<li>f(x) 在[a,b]上连续，$\int_a^b f(x) dx = f(\xi)(b-a)$,这个定理可以用拉格朗日微分中值定理证明</li>
<li>f(x),g(x)在[a,b]上连续，g(x)不变号，$\int_a^b f(x)g(x) dx = f(\xi)\int_a^b g(x) dx$</li>
</ul>
<h3 id="积分上限函数"><a href="#积分上限函数" class="headerlink" title="积分上限函数"></a>积分上限函数</h3><p><strong>微积分基本定理</strong>  </p>
<p>  如果f(x)在区间[a,b]上连续，则$F(x) = \int_a^b f(x) dx,$在[a,b]上可导，且 $\frac{dF(x)}{dx} = f(x)$，这个定理说明了如果f(x)在[a,b]上连续，就一定在[a,b]区间上存在原函数的F(x)。拓展来说也就是的连续函数一定存在原函数，且原函数的可以通过积分上限函数来获得。</p>
<p><strong>积分基本定理的拓展</strong>  </p>
<p>  如果f(x)在[a,b]上连续函数,$\varphi_1(x),  \varphi_2(x)$为可导函数则存在</p>
<script type="math/tex; mode=display">(\int_a^b f(x) dx)^\prime = f[\varphi_1(x)]\varphi_1(x)^\prime - f[\varphi_2(x)]\varphi_2(x)^\prime</script><p><strong>定理</strong>  设函数f(x)在[-l,l]上连续则<br>  如果f(x)为奇函数，$\int_0^x f(x) dx$ 必然为偶函数<br>  可以拓展撤$\int_a^x f(x) dx \rightarrow \int_a^0 f(x) dx + \int_0^x f(x) dx$ 偶函数上加上一个常数C并不会改变奇偶性。<br>  同理如果f(x)为偶函数，$\int_0^x f(x) dx$ 必然为奇函数。注意这里的不能同上面一样拓展。</p>
<p><strong>积分常用的公式</strong></p>
<script type="math/tex; mode=display">
\int_0^\frac{\pi}{2} \sin^n(x) dx = \int_0^\frac{\pi}{2} \cos^n(x) dx = 
\begin{cases}
\frac{n-1}{n} \frac{n-3}{n-2}...\frac{1}{2} \frac{\pi}{2}, n 为正偶数\\
\frac{n-1}{n} \frac{n-3}{n-2} ... \frac{2}{3}, n为大于1的奇数
\end{cases}</script><p>$\int_0^\pi xf(\sin) dx = \frac{\pi}{2} \int_0^\pi f(\sin) dx$,其中f(x)连续</p>
<p><strong>反常积分</strong><br>反常积分是是对定积分的一个扩展<br>$定积分\begin{cases}<br>对积分上下限进行了拓展，将有界区间拓展成为了一个无穷区间 \<br>将有界的被积函数拓展成了无界的被积函数<br>\end{cases}$</p>
<p><strong>判断积分的敛散性</strong><br>这里的f(x)是我们要判断敛散性的函数，g(x)是我们已知的函数，所以我们都是以g(x)的敛散性来判定f(x)的敛散性  </p>
<p><strong>一、对于无穷区间形式的反常积分来说</strong><br>定理一 比较法</p>
<p>如果f(x), g(x) 在[a,$+ \infty$]上连续（这里是保证了函数的可积性），$0 \le f(x) \le g(x)$（这里的条件比较苛刻，在很多时候都是有交叉点的，但是如果交叉点之后满足也可以使用）<br>$(1)\int_a^{+\infty} g(x) 收敛，则 \int_a^{+\infty} f(x) 也收敛$(也就是说大的收敛小的一定收敛)<br>$(2)\int_a^{+\infty} f(x) 发散，则 \int_a^{+\infty} g(x) 也发散$</p>
<p>定理二 比较法的极限形式<br>如果f(x), g(x) 在[a,$+ \infty$]上非负连续,$\lim\limits_{x\to +\infty}\frac{f(x)}{g(x)} = \alpha$<br>$(1)\alpha \neq 0$ (说明了这里是同阶的)，所以这里的f(x) 与g(x)的敛散性是相同的)<br>$(2) \alpha = 0$f(x)是g(x)在趋向无穷时候是更小的那个函数，所以g(x)收敛，f(x)一定也收敛<br>$(3) \alpha = +\infty$,g(x)分散，f(x)一定也发散  </p>
<p><strong>常用结论</strong><br>$\int_a^{+\infty}\frac{1}{x^p} dx<br>\begin{cases}<br>p &gt; 1, 收敛 \<br>p \le 1,发散<br>\end{cases}<br>(a &gt; 0)<br>$</p>
<p><strong>二、对于无界函数的反常积分</strong><br>定义上基本和无穷区间的反常积分一致，所以主要看不同点  </p>
<p><strong>常用结论</strong>  </p>
<script type="math/tex; mode=display">\int_a^b \frac{1}{(x-a)^p} dx
\begin{cases}
  p < 1, 收敛 \\
  p\ge 1, 发散
\end{cases}</script><script type="math/tex; mode=display">\int_a^b \frac{1}{(b-x)^p} dx
\begin{cases}
  p < 1, 收敛 \\
  p\ge 1, 发散
\end{cases}</script><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>反常积分</strong></p>
<p><strong>敛散性</strong></p>
<ul>
<li>$\int_a^{+\infty} \frac{x^{any}}{e^x}$一定收敛</li>
</ul>
<p><strong>反常积分的计算</strong></p>
<p>一共就两种做法分部和</p>
]]></content>
      <categories>
        <category>考研</category>
        <category>高等数学</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>高等数学</tag>
      </tags>
  </entry>
</search>
